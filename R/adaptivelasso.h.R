
# This file is automatically generated, you probably don't want to edit this

adaptivelassoOptions <- if (requireNamespace("jmvcore", quietly=TRUE)) R6::R6Class(
    "adaptivelassoOptions",
    inherit = jmvcore::Options,
    public = list(
        initialize = function(
            time = NULL,
            event = NULL,
            predictors = NULL,
            strata = NULL,
            weight_method = "ridge",
            alpha = 1,
            gamma = 1,
            cv_folds = 10,
            cv_measure = "deviance",
            lambda_sequence = "auto",
            lambda_min_ratio = 0.001,
            n_lambda = 100,
            stability_selection = FALSE,
            stability_threshold = 0.6,
            bootstrap_samples = 100,
            subsampling_ratio = 0.8,
            proportional_hazards = TRUE,
            influence_diagnostics = FALSE,
            goodness_of_fit = TRUE,
            risk_groups = 3,
            time_points = "1, 2, 5",
            baseline_survival = TRUE,
            show_coefficients = TRUE,
            show_selection_path = TRUE,
            show_cv_results = TRUE,
            show_diagnostics = TRUE,
            plot_selection_path = TRUE,
            plot_cv_curve = TRUE,
            plot_stability = FALSE,
            plot_survival_curves = FALSE,
            plot_baseline_hazard = FALSE,
            plot_diagnostics = FALSE,
            tie_method = "breslow",
            standardize = TRUE,
            intercept = FALSE,
            parallel_computing = FALSE,
            n_cores = 2,
            convergence_threshold = 1e-7,
            max_iterations = 10000,
            random_seed = 123, ...) {

            super$initialize(
                package="ClinicoPath",
                name="adaptivelasso",
                requiresData=TRUE,
                ...)

            private$..time <- jmvcore::OptionVariable$new(
                "time",
                time,
                suggested=list(
                    "continuous"),
                permitted=list(
                    "numeric"))
            private$..event <- jmvcore::OptionVariable$new(
                "event",
                event,
                suggested=list(
                    "ordinal",
                    "nominal"),
                permitted=list(
                    "factor",
                    "numeric"))
            private$..predictors <- jmvcore::OptionVariables$new(
                "predictors",
                predictors,
                suggested=list(
                    "continuous",
                    "ordinal",
                    "nominal"),
                permitted=list(
                    "numeric",
                    "factor"))
            private$..strata <- jmvcore::OptionVariable$new(
                "strata",
                strata,
                suggested=list(
                    "nominal",
                    "ordinal"),
                permitted=list(
                    "factor"))
            private$..weight_method <- jmvcore::OptionList$new(
                "weight_method",
                weight_method,
                options=list(
                    "ridge",
                    "univariate",
                    "cox",
                    "correlation",
                    "equal"),
                default="ridge")
            private$..alpha <- jmvcore::OptionNumber$new(
                "alpha",
                alpha,
                default=1,
                min=0,
                max=1)
            private$..gamma <- jmvcore::OptionNumber$new(
                "gamma",
                gamma,
                default=1,
                min=0.1,
                max=5)
            private$..cv_folds <- jmvcore::OptionInteger$new(
                "cv_folds",
                cv_folds,
                default=10,
                min=3,
                max=20)
            private$..cv_measure <- jmvcore::OptionList$new(
                "cv_measure",
                cv_measure,
                options=list(
                    "deviance",
                    "C",
                    "brier",
                    "auc"),
                default="deviance")
            private$..lambda_sequence <- jmvcore::OptionList$new(
                "lambda_sequence",
                lambda_sequence,
                options=list(
                    "auto",
                    "custom",
                    "single"),
                default="auto")
            private$..lambda_min_ratio <- jmvcore::OptionNumber$new(
                "lambda_min_ratio",
                lambda_min_ratio,
                default=0.001,
                min=0.000001,
                max=0.1)
            private$..n_lambda <- jmvcore::OptionInteger$new(
                "n_lambda",
                n_lambda,
                default=100,
                min=10,
                max=500)
            private$..stability_selection <- jmvcore::OptionBool$new(
                "stability_selection",
                stability_selection,
                default=FALSE)
            private$..stability_threshold <- jmvcore::OptionNumber$new(
                "stability_threshold",
                stability_threshold,
                default=0.6,
                min=0.5,
                max=0.95)
            private$..bootstrap_samples <- jmvcore::OptionInteger$new(
                "bootstrap_samples",
                bootstrap_samples,
                default=100,
                min=50,
                max=1000)
            private$..subsampling_ratio <- jmvcore::OptionNumber$new(
                "subsampling_ratio",
                subsampling_ratio,
                default=0.8,
                min=0.5,
                max=0.95)
            private$..proportional_hazards <- jmvcore::OptionBool$new(
                "proportional_hazards",
                proportional_hazards,
                default=TRUE)
            private$..influence_diagnostics <- jmvcore::OptionBool$new(
                "influence_diagnostics",
                influence_diagnostics,
                default=FALSE)
            private$..goodness_of_fit <- jmvcore::OptionBool$new(
                "goodness_of_fit",
                goodness_of_fit,
                default=TRUE)
            private$..risk_groups <- jmvcore::OptionInteger$new(
                "risk_groups",
                risk_groups,
                default=3,
                min=2,
                max=10)
            private$..time_points <- jmvcore::OptionString$new(
                "time_points",
                time_points,
                default="1, 2, 5")
            private$..baseline_survival <- jmvcore::OptionBool$new(
                "baseline_survival",
                baseline_survival,
                default=TRUE)
            private$..show_coefficients <- jmvcore::OptionBool$new(
                "show_coefficients",
                show_coefficients,
                default=TRUE)
            private$..show_selection_path <- jmvcore::OptionBool$new(
                "show_selection_path",
                show_selection_path,
                default=TRUE)
            private$..show_cv_results <- jmvcore::OptionBool$new(
                "show_cv_results",
                show_cv_results,
                default=TRUE)
            private$..show_diagnostics <- jmvcore::OptionBool$new(
                "show_diagnostics",
                show_diagnostics,
                default=TRUE)
            private$..plot_selection_path <- jmvcore::OptionBool$new(
                "plot_selection_path",
                plot_selection_path,
                default=TRUE)
            private$..plot_cv_curve <- jmvcore::OptionBool$new(
                "plot_cv_curve",
                plot_cv_curve,
                default=TRUE)
            private$..plot_stability <- jmvcore::OptionBool$new(
                "plot_stability",
                plot_stability,
                default=FALSE)
            private$..plot_survival_curves <- jmvcore::OptionBool$new(
                "plot_survival_curves",
                plot_survival_curves,
                default=FALSE)
            private$..plot_baseline_hazard <- jmvcore::OptionBool$new(
                "plot_baseline_hazard",
                plot_baseline_hazard,
                default=FALSE)
            private$..plot_diagnostics <- jmvcore::OptionBool$new(
                "plot_diagnostics",
                plot_diagnostics,
                default=FALSE)
            private$..tie_method <- jmvcore::OptionList$new(
                "tie_method",
                tie_method,
                options=list(
                    "breslow",
                    "efron"),
                default="breslow")
            private$..standardize <- jmvcore::OptionBool$new(
                "standardize",
                standardize,
                default=TRUE)
            private$..intercept <- jmvcore::OptionBool$new(
                "intercept",
                intercept,
                default=FALSE)
            private$..parallel_computing <- jmvcore::OptionBool$new(
                "parallel_computing",
                parallel_computing,
                default=FALSE)
            private$..n_cores <- jmvcore::OptionInteger$new(
                "n_cores",
                n_cores,
                default=2,
                min=1,
                max=8)
            private$..convergence_threshold <- jmvcore::OptionNumber$new(
                "convergence_threshold",
                convergence_threshold,
                default=1e-7,
                min=1e-10,
                max=0.0001)
            private$..max_iterations <- jmvcore::OptionInteger$new(
                "max_iterations",
                max_iterations,
                default=10000,
                min=1000,
                max=100000)
            private$..random_seed <- jmvcore::OptionInteger$new(
                "random_seed",
                random_seed,
                default=123,
                min=1,
                max=999999)

            self$.addOption(private$..time)
            self$.addOption(private$..event)
            self$.addOption(private$..predictors)
            self$.addOption(private$..strata)
            self$.addOption(private$..weight_method)
            self$.addOption(private$..alpha)
            self$.addOption(private$..gamma)
            self$.addOption(private$..cv_folds)
            self$.addOption(private$..cv_measure)
            self$.addOption(private$..lambda_sequence)
            self$.addOption(private$..lambda_min_ratio)
            self$.addOption(private$..n_lambda)
            self$.addOption(private$..stability_selection)
            self$.addOption(private$..stability_threshold)
            self$.addOption(private$..bootstrap_samples)
            self$.addOption(private$..subsampling_ratio)
            self$.addOption(private$..proportional_hazards)
            self$.addOption(private$..influence_diagnostics)
            self$.addOption(private$..goodness_of_fit)
            self$.addOption(private$..risk_groups)
            self$.addOption(private$..time_points)
            self$.addOption(private$..baseline_survival)
            self$.addOption(private$..show_coefficients)
            self$.addOption(private$..show_selection_path)
            self$.addOption(private$..show_cv_results)
            self$.addOption(private$..show_diagnostics)
            self$.addOption(private$..plot_selection_path)
            self$.addOption(private$..plot_cv_curve)
            self$.addOption(private$..plot_stability)
            self$.addOption(private$..plot_survival_curves)
            self$.addOption(private$..plot_baseline_hazard)
            self$.addOption(private$..plot_diagnostics)
            self$.addOption(private$..tie_method)
            self$.addOption(private$..standardize)
            self$.addOption(private$..intercept)
            self$.addOption(private$..parallel_computing)
            self$.addOption(private$..n_cores)
            self$.addOption(private$..convergence_threshold)
            self$.addOption(private$..max_iterations)
            self$.addOption(private$..random_seed)
        }),
    active = list(
        time = function() private$..time$value,
        event = function() private$..event$value,
        predictors = function() private$..predictors$value,
        strata = function() private$..strata$value,
        weight_method = function() private$..weight_method$value,
        alpha = function() private$..alpha$value,
        gamma = function() private$..gamma$value,
        cv_folds = function() private$..cv_folds$value,
        cv_measure = function() private$..cv_measure$value,
        lambda_sequence = function() private$..lambda_sequence$value,
        lambda_min_ratio = function() private$..lambda_min_ratio$value,
        n_lambda = function() private$..n_lambda$value,
        stability_selection = function() private$..stability_selection$value,
        stability_threshold = function() private$..stability_threshold$value,
        bootstrap_samples = function() private$..bootstrap_samples$value,
        subsampling_ratio = function() private$..subsampling_ratio$value,
        proportional_hazards = function() private$..proportional_hazards$value,
        influence_diagnostics = function() private$..influence_diagnostics$value,
        goodness_of_fit = function() private$..goodness_of_fit$value,
        risk_groups = function() private$..risk_groups$value,
        time_points = function() private$..time_points$value,
        baseline_survival = function() private$..baseline_survival$value,
        show_coefficients = function() private$..show_coefficients$value,
        show_selection_path = function() private$..show_selection_path$value,
        show_cv_results = function() private$..show_cv_results$value,
        show_diagnostics = function() private$..show_diagnostics$value,
        plot_selection_path = function() private$..plot_selection_path$value,
        plot_cv_curve = function() private$..plot_cv_curve$value,
        plot_stability = function() private$..plot_stability$value,
        plot_survival_curves = function() private$..plot_survival_curves$value,
        plot_baseline_hazard = function() private$..plot_baseline_hazard$value,
        plot_diagnostics = function() private$..plot_diagnostics$value,
        tie_method = function() private$..tie_method$value,
        standardize = function() private$..standardize$value,
        intercept = function() private$..intercept$value,
        parallel_computing = function() private$..parallel_computing$value,
        n_cores = function() private$..n_cores$value,
        convergence_threshold = function() private$..convergence_threshold$value,
        max_iterations = function() private$..max_iterations$value,
        random_seed = function() private$..random_seed$value),
    private = list(
        ..time = NA,
        ..event = NA,
        ..predictors = NA,
        ..strata = NA,
        ..weight_method = NA,
        ..alpha = NA,
        ..gamma = NA,
        ..cv_folds = NA,
        ..cv_measure = NA,
        ..lambda_sequence = NA,
        ..lambda_min_ratio = NA,
        ..n_lambda = NA,
        ..stability_selection = NA,
        ..stability_threshold = NA,
        ..bootstrap_samples = NA,
        ..subsampling_ratio = NA,
        ..proportional_hazards = NA,
        ..influence_diagnostics = NA,
        ..goodness_of_fit = NA,
        ..risk_groups = NA,
        ..time_points = NA,
        ..baseline_survival = NA,
        ..show_coefficients = NA,
        ..show_selection_path = NA,
        ..show_cv_results = NA,
        ..show_diagnostics = NA,
        ..plot_selection_path = NA,
        ..plot_cv_curve = NA,
        ..plot_stability = NA,
        ..plot_survival_curves = NA,
        ..plot_baseline_hazard = NA,
        ..plot_diagnostics = NA,
        ..tie_method = NA,
        ..standardize = NA,
        ..intercept = NA,
        ..parallel_computing = NA,
        ..n_cores = NA,
        ..convergence_threshold = NA,
        ..max_iterations = NA,
        ..random_seed = NA)
)

adaptivelassoResults <- if (requireNamespace("jmvcore", quietly=TRUE)) R6::R6Class(
    "adaptivelassoResults",
    inherit = jmvcore::Group,
    active = list(
        instructions = function() private$.items[["instructions"]],
        todo = function() private$.items[["todo"]],
        coefficients = function() private$.items[["coefficients"]],
        selectionPath = function() private$.items[["selectionPath"]],
        cvResults = function() private$.items[["cvResults"]],
        stabilityResults = function() private$.items[["stabilityResults"]],
        modelDiagnostics = function() private$.items[["modelDiagnostics"]],
        performanceMetrics = function() private$.items[["performanceMetrics"]],
        riskGroups = function() private$.items[["riskGroups"]],
        predictions = function() private$.items[["predictions"]],
        pathPlot = function() private$.items[["pathPlot"]],
        cvPlot = function() private$.items[["cvPlot"]],
        stabilityPlot = function() private$.items[["stabilityPlot"]],
        survivalPlot = function() private$.items[["survivalPlot"]],
        baselineHazardPlot = function() private$.items[["baselineHazardPlot"]],
        diagnosticsPlot = function() private$.items[["diagnosticsPlot"]]),
    private = list(),
    public=list(
        initialize=function(options) {
            super$initialize(
                options=options,
                name="",
                title="Analysis Results",
                refs=list(
                    "ClinicoPathJamoviModule"))
            self$add(jmvcore::Html$new(
                options=options,
                name="instructions",
                title="Instructions",
                visible=FALSE))
            self$add(jmvcore::Html$new(
                options=options,
                name="todo",
                title="Analysis Todo",
                visible=FALSE))
            self$add(jmvcore::Table$new(
                options=options,
                name="coefficients",
                title="Selected Variables and Coefficients",
                visible="(show_coefficients)",
                clearWith=list(
                    "time",
                    "event",
                    "predictors",
                    "weight_method",
                    "alpha",
                    "cv_folds"),
                columns=list(
                    list(
                        `name`="variable", 
                        `title`="Variable", 
                        `type`="text"),
                    list(
                        `name`="coefficient", 
                        `title`="Coefficient", 
                        `type`="number", 
                        `format`="zto"),
                    list(
                        `name`="exp_coefficient", 
                        `title`="Hazard Ratio", 
                        `type`="number", 
                        `format`="zto"),
                    list(
                        `name`="std_error", 
                        `title`="SE", 
                        `type`="number", 
                        `format`="zto"),
                    list(
                        `name`="lower_ci", 
                        `title`="Lower CI", 
                        `type`="number", 
                        `format`="zto"),
                    list(
                        `name`="upper_ci", 
                        `title`="Upper CI", 
                        `type`="number", 
                        `format`="zto"),
                    list(
                        `name`="adaptive_weight", 
                        `title`="Adaptive Weight", 
                        `type`="number", 
                        `format`="zto"))))
            self$add(jmvcore::Table$new(
                options=options,
                name="selectionPath",
                title="Regularization Path Summary",
                visible="(show_selection_path)",
                clearWith=list(
                    "predictors",
                    "lambda_sequence",
                    "n_lambda"),
                columns=list(
                    list(
                        `name`="step", 
                        `title`="Step", 
                        `type`="integer"),
                    list(
                        `name`="lambda", 
                        `title`="Lambda", 
                        `type`="number", 
                        `format`="zto"),
                    list(
                        `name`="n_selected", 
                        `title`="Variables Selected", 
                        `type`="integer"),
                    list(
                        `name`="deviance", 
                        `title`="Deviance", 
                        `type`="number", 
                        `format`="zto"),
                    list(
                        `name`="cv_error", 
                        `title`="CV Error", 
                        `type`="number", 
                        `format`="zto"))))
            self$add(jmvcore::Table$new(
                options=options,
                name="cvResults",
                title="Cross-Validation Results",
                visible="(show_cv_results)",
                clearWith=list(
                    "cv_folds",
                    "cv_measure",
                    "lambda_sequence"),
                columns=list(
                    list(
                        `name`="criterion", 
                        `title`="Criterion", 
                        `type`="text"),
                    list(
                        `name`="lambda_min", 
                        `title`="Lambda Min", 
                        `type`="number", 
                        `format`="zto"),
                    list(
                        `name`="lambda_1se", 
                        `title`="Lambda 1SE", 
                        `type`="number", 
                        `format`="zto"),
                    list(
                        `name`="cv_error_min", 
                        `title`="Min CV Error", 
                        `type`="number", 
                        `format`="zto"),
                    list(
                        `name`="cv_error_1se", 
                        `title`="1SE CV Error", 
                        `type`="number", 
                        `format`="zto"),
                    list(
                        `name`="n_variables_min", 
                        `title`="Variables (Min)", 
                        `type`="integer"),
                    list(
                        `name`="n_variables_1se", 
                        `title`="Variables (1SE)", 
                        `type`="integer"))))
            self$add(jmvcore::Table$new(
                options=options,
                name="stabilityResults",
                title="Stability Selection Results",
                visible="(stability_selection)",
                clearWith=list(
                    "stability_threshold",
                    "bootstrap_samples",
                    "subsampling_ratio"),
                columns=list(
                    list(
                        `name`="variable", 
                        `title`="Variable", 
                        `type`="text"),
                    list(
                        `name`="selection_frequency", 
                        `title`="Selection Frequency", 
                        `type`="number", 
                        `format`="pc"),
                    list(
                        `name`="stability_score", 
                        `title`="Stability Score", 
                        `type`="number", 
                        `format`="zto"),
                    list(
                        `name`="stable_selection", 
                        `title`="Stable Selection", 
                        `type`="text"),
                    list(
                        `name`="error_bound", 
                        `title`="Error Bound", 
                        `type`="number", 
                        `format`="zto"))))
            self$add(jmvcore::Table$new(
                options=options,
                name="modelDiagnostics",
                title="Model Diagnostics",
                visible="(show_diagnostics)",
                clearWith=list(
                    "time",
                    "event",
                    "predictors",
                    "proportional_hazards"),
                columns=list(
                    list(
                        `name`="diagnostic", 
                        `title`="Diagnostic", 
                        `type`="text"),
                    list(
                        `name`="statistic", 
                        `title`="Statistic", 
                        `type`="number", 
                        `format`="zto"),
                    list(
                        `name`="p_value", 
                        `title`="p-value", 
                        `type`="number", 
                        `format`="zto"),
                    list(
                        `name`="interpretation", 
                        `title`="Interpretation", 
                        `type`="text"))))
            self$add(jmvcore::Table$new(
                options=options,
                name="performanceMetrics",
                title="Model Performance",
                visible="(goodness_of_fit)",
                clearWith=list(
                    "time",
                    "event",
                    "predictors"),
                columns=list(
                    list(
                        `name`="metric", 
                        `title`="Metric", 
                        `type`="text"),
                    list(
                        `name`="value", 
                        `title`="Value", 
                        `type`="number", 
                        `format`="zto"),
                    list(
                        `name`="confidence_interval", 
                        `title`="95% CI", 
                        `type`="text"),
                    list(
                        `name`="description", 
                        `title`="Description", 
                        `type`="text"))))
            self$add(jmvcore::Table$new(
                options=options,
                name="riskGroups",
                title="Risk Group Analysis",
                visible="(risk_groups > 2)",
                clearWith=list(
                    "risk_groups",
                    "time",
                    "event"),
                columns=list(
                    list(
                        `name`="risk_group", 
                        `title`="Risk Group", 
                        `type`="text"),
                    list(
                        `name`="n_subjects", 
                        `title`="N", 
                        `type`="integer"),
                    list(
                        `name`="n_events", 
                        `title`="Events", 
                        `type`="integer"),
                    list(
                        `name`="median_survival", 
                        `title`="Median Survival", 
                        `type`="number", 
                        `format`="zto"),
                    list(
                        `name`="survival_range", 
                        `title`="Survival Range", 
                        `type`="text"),
                    list(
                        `name`="hazard_ratio", 
                        `title`="Hazard Ratio", 
                        `type`="number", 
                        `format`="zto"))))
            self$add(jmvcore::Table$new(
                options=options,
                name="predictions",
                title="Survival Predictions",
                visible="(time_points != \"\")",
                clearWith=list(
                    "time_points",
                    "baseline_survival"),
                columns=list(
                    list(
                        `name`="time_point", 
                        `title`="Time Point", 
                        `type`="number", 
                        `format`="zto"),
                    list(
                        `name`="baseline_survival", 
                        `title`="Baseline Survival", 
                        `type`="number", 
                        `format`="zto"),
                    list(
                        `name`="survival_lower", 
                        `title`="Lower CI", 
                        `type`="number", 
                        `format`="zto"),
                    list(
                        `name`="survival_upper", 
                        `title`="Upper CI", 
                        `type`="number", 
                        `format`="zto"))))
            self$add(jmvcore::Image$new(
                options=options,
                name="pathPlot",
                title="Regularization Path",
                width=600,
                height=500,
                visible="(plot_selection_path)",
                requiresData=TRUE,
                clearWith=list(
                    "predictors",
                    "lambda_sequence")))
            self$add(jmvcore::Image$new(
                options=options,
                name="cvPlot",
                title="Cross-Validation Curve",
                width=500,
                height=400,
                visible="(plot_cv_curve)",
                requiresData=TRUE,
                clearWith=list(
                    "cv_folds",
                    "cv_measure")))
            self$add(jmvcore::Image$new(
                options=options,
                name="stabilityPlot",
                title="Stability Selection",
                width=500,
                height=400,
                visible="(plot_stability)",
                requiresData=TRUE,
                clearWith=list(
                    "stability_selection",
                    "stability_threshold")))
            self$add(jmvcore::Image$new(
                options=options,
                name="survivalPlot",
                title="Risk Group Survival Curves",
                width=500,
                height=400,
                visible="(plot_survival_curves)",
                requiresData=TRUE,
                clearWith=list(
                    "risk_groups",
                    "time",
                    "event")))
            self$add(jmvcore::Image$new(
                options=options,
                name="baselineHazardPlot",
                title="Baseline Hazard Function",
                width=500,
                height=400,
                visible="(plot_baseline_hazard)",
                requiresData=TRUE,
                clearWith=list(
                    "baseline_survival",
                    "time",
                    "event")))
            self$add(jmvcore::Image$new(
                options=options,
                name="diagnosticsPlot",
                title="Model Diagnostics",
                width=600,
                height=500,
                visible="(plot_diagnostics)",
                requiresData=TRUE,
                clearWith=list(
                    "proportional_hazards",
                    "influence_diagnostics")))}))

adaptivelassoBase <- if (requireNamespace("jmvcore", quietly=TRUE)) R6::R6Class(
    "adaptivelassoBase",
    inherit = jmvcore::Analysis,
    public = list(
        initialize = function(options, data=NULL, datasetId="", analysisId="", revision=0) {
            super$initialize(
                package = "ClinicoPath",
                name = "adaptivelasso",
                version = c(0,0,31),
                options = options,
                results = adaptivelassoResults$new(options=options),
                data = data,
                datasetId = datasetId,
                analysisId = analysisId,
                revision = revision,
                pause = NULL,
                completeWhenFilled = FALSE,
                requiresMissings = FALSE,
                weightsSupport = 'auto')
        }))

#' Adaptive LASSO for Cox Models
#'
#' Adaptive LASSO for Cox proportional hazards models with data-driven penalty 
#' selection and improved variable selection properties. Unlike standard 
#' LASSO, the adaptive LASSO uses weights based on initial parameter estimates 
#' to provide consistent variable selection (oracle property) and reduced bias 
#' for non-zero coefficients. This implementation supports multiple weight 
#' calculation methods, cross-validation for optimal penalty selection, 
#' stability selection for robust variable identification, and comprehensive 
#' model diagnostics. Particularly effective for high-dimensional survival 
#' data where traditional methods fail, genomic studies with many biomarkers, 
#' and clinical prediction models requiring sparse, interpretable solutions. 
#' The method automatically handles tied survival times, stratified analysis, 
#' and provides uncertainty quantification through bootstrap procedures.
#' 
#'
#' @examples
#' result <- adaptivelasso(
#'     data = mydata,
#'     time = "time_to_event",
#'     event = "event_indicator",
#'     predictors = c("age", "stage", "biomarker1", "biomarker2"),
#'     weight_method = "ridge",
#'     cv_folds = 10,
#'     stability_selection = TRUE,
#'     alpha = 1.0
#' )
#'
#' @param data The data as a data frame.
#' @param time Time to event variable (numeric). For right-censored data, this
#'   is the  time from study entry to event or censoring.
#' @param event Event indicator variable. For survival analysis: 0 = censored,
#'   1 = event. For competing risks: 0 = censored, 1+ = different event types.
#' @param predictors Variables to include in the adaptive LASSO Cox model. Can
#'   include continuous, ordinal, and nominal variables. Automatic
#'   standardization is applied for optimal penalty performance.
#' @param strata Optional stratification variable for stratified Cox
#'   regression. Creates separate baseline hazards for each stratum.
#' @param weight_method Method for calculating adaptive weights. Ridge
#'   provides stable weights with shrinkage, univariate uses individual Cox
#'   regressions, full Cox uses complete model (may be unstable), correlation
#'   uses marginal associations.
#' @param alpha Elastic net mixing parameter. 1.0 = pure LASSO, 0.0 = ridge
#'   regression, intermediate values combine both penalties for better
#'   performance with correlated predictors.
#' @param gamma Power parameter for adaptive weights calculation. Higher
#'   values increase penalty differences between variables, promoting stronger
#'   variable selection but potentially increasing instability.
#' @param cv_folds Number of folds for cross-validation to select optimal
#'   penalty parameter. More folds provide better estimates but increase
#'   computation time.
#' @param cv_measure Performance measure for cross-validation. Deviance is
#'   computationally efficient, C-index focuses on discrimination, Brier score
#'   accounts for calibration, AUC provides time-specific performance.
#' @param lambda_sequence How to specify the penalty parameter sequence.
#'   Automatic uses data-driven range, custom allows user specification, single
#'   tests only one value.
#' @param lambda_min_ratio Ratio of smallest to largest lambda value in
#'   automatic sequence. Smaller values explore stronger penalties but may lead
#'   to computational difficulties.
#' @param n_lambda Number of lambda values in the regularization path. More
#'   values provide finer resolution but increase computation time.
#' @param stability_selection Perform stability selection to identify robust
#'   variable selection patterns across bootstrap samples. Provides more
#'   reliable variable selection than single model fitting.
#' @param stability_threshold Minimum selection frequency for variables in
#'   stability selection. Higher thresholds provide more conservative variable
#'   selection but may miss important predictors.
#' @param bootstrap_samples Number of bootstrap samples for stability
#'   selection and confidence intervals. More samples provide more stable
#'   estimates.
#' @param subsampling_ratio Proportion of data used in each bootstrap sample
#'   for stability selection. Smaller ratios increase selection variability.
#' @param proportional_hazards Test proportional hazards assumption for
#'   selected variables using scaled Schoenfeld residuals and time-interaction
#'   tests.
#' @param influence_diagnostics Calculate influence diagnostics including
#'   dfbeta, leverage, and outlier detection for robust model assessment.
#' @param goodness_of_fit Perform goodness of fit assessment including model
#'   deviance, concordance statistics, and calibration measures.
#' @param risk_groups Number of risk groups for stratification based on linear
#'   predictor. Used for Kaplan-Meier curves and risk group analysis.
#' @param time_points Comma-separated list of time points for survival
#'   probability predictions. Empty string uses data-driven quantiles.
#' @param baseline_survival Estimate and plot baseline survival function for
#'   the adaptive LASSO Cox model using Breslow estimator.
#' @param show_coefficients Display coefficient estimates for selected
#'   variables with standard errors and confidence intervals.
#' @param show_selection_path Display complete regularization path showing how
#'   coefficients change with penalty parameter.
#' @param show_cv_results Display cross-validation results including optimal
#'   lambda selection and performance across penalty values.
#' @param show_diagnostics Display comprehensive model diagnostics including
#'   proportional hazards tests, influence measures, and residual analysis.
#' @param plot_selection_path Plot coefficient paths as function of penalty
#'   parameter showing variable selection progression.
#' @param plot_cv_curve Plot cross-validation performance curve with optimal
#'   lambda selection and confidence bands.
#' @param plot_stability Plot stability selection results showing selection
#'   frequencies across bootstrap samples.
#' @param plot_survival_curves Plot Kaplan-Meier survival curves for risk
#'   groups defined by adaptive LASSO linear predictor.
#' @param plot_baseline_hazard Plot estimated baseline hazard function and
#'   cumulative baseline hazard from the final model.
#' @param plot_diagnostics Create diagnostic plots including residuals,
#'   influential observations, and proportional hazards assessment.
#' @param tie_method Method for handling tied survival times. Efron provides
#'   better approximation but is computationally more intensive.
#' @param standardize Standardize predictors before fitting. Recommended for
#'   optimal penalty performance with mixed-scale variables.
#' @param intercept Include intercept term in Cox model. Generally not needed
#'   for survival analysis but may be useful in special cases.
#' @param parallel_computing Use parallel computing for cross-validation and
#'   bootstrap procedures to reduce computation time.
#' @param n_cores Number of CPU cores for parallel computation when enabled.
#'   More cores speed up CV and bootstrap but use more memory.
#' @param convergence_threshold Convergence threshold for coordinate descent
#'   algorithm. Smaller values provide more precise solutions but increase
#'   computation time.
#' @param max_iterations Maximum iterations for coordinate descent algorithm.
#'   Increase if convergence warnings occur.
#' @param random_seed Random seed for cross-validation folds and bootstrap
#'   sampling. Ensures reproducible results across analyses.
#' @return A results object containing:
#' \tabular{llllll}{
#'   \code{results$instructions} \tab \tab \tab \tab \tab a html \cr
#'   \code{results$todo} \tab \tab \tab \tab \tab a html \cr
#'   \code{results$coefficients} \tab \tab \tab \tab \tab a table \cr
#'   \code{results$selectionPath} \tab \tab \tab \tab \tab a table \cr
#'   \code{results$cvResults} \tab \tab \tab \tab \tab a table \cr
#'   \code{results$stabilityResults} \tab \tab \tab \tab \tab a table \cr
#'   \code{results$modelDiagnostics} \tab \tab \tab \tab \tab a table \cr
#'   \code{results$performanceMetrics} \tab \tab \tab \tab \tab a table \cr
#'   \code{results$riskGroups} \tab \tab \tab \tab \tab a table \cr
#'   \code{results$predictions} \tab \tab \tab \tab \tab a table \cr
#'   \code{results$pathPlot} \tab \tab \tab \tab \tab an image \cr
#'   \code{results$cvPlot} \tab \tab \tab \tab \tab an image \cr
#'   \code{results$stabilityPlot} \tab \tab \tab \tab \tab an image \cr
#'   \code{results$survivalPlot} \tab \tab \tab \tab \tab an image \cr
#'   \code{results$baselineHazardPlot} \tab \tab \tab \tab \tab an image \cr
#'   \code{results$diagnosticsPlot} \tab \tab \tab \tab \tab an image \cr
#' }
#'
#' Tables can be converted to data frames with \code{asDF} or \code{\link{as.data.frame}}. For example:
#'
#' \code{results$coefficients$asDF}
#'
#' \code{as.data.frame(results$coefficients)}
#'
#' @export
adaptivelasso <- function(
    data,
    time,
    event,
    predictors,
    strata,
    weight_method = "ridge",
    alpha = 1,
    gamma = 1,
    cv_folds = 10,
    cv_measure = "deviance",
    lambda_sequence = "auto",
    lambda_min_ratio = 0.001,
    n_lambda = 100,
    stability_selection = FALSE,
    stability_threshold = 0.6,
    bootstrap_samples = 100,
    subsampling_ratio = 0.8,
    proportional_hazards = TRUE,
    influence_diagnostics = FALSE,
    goodness_of_fit = TRUE,
    risk_groups = 3,
    time_points = "1, 2, 5",
    baseline_survival = TRUE,
    show_coefficients = TRUE,
    show_selection_path = TRUE,
    show_cv_results = TRUE,
    show_diagnostics = TRUE,
    plot_selection_path = TRUE,
    plot_cv_curve = TRUE,
    plot_stability = FALSE,
    plot_survival_curves = FALSE,
    plot_baseline_hazard = FALSE,
    plot_diagnostics = FALSE,
    tie_method = "breslow",
    standardize = TRUE,
    intercept = FALSE,
    parallel_computing = FALSE,
    n_cores = 2,
    convergence_threshold = 1e-7,
    max_iterations = 10000,
    random_seed = 123) {

    if ( ! requireNamespace("jmvcore", quietly=TRUE))
        stop("adaptivelasso requires jmvcore to be installed (restart may be required)")

    if ( ! missing(time)) time <- jmvcore::resolveQuo(jmvcore::enquo(time))
    if ( ! missing(event)) event <- jmvcore::resolveQuo(jmvcore::enquo(event))
    if ( ! missing(predictors)) predictors <- jmvcore::resolveQuo(jmvcore::enquo(predictors))
    if ( ! missing(strata)) strata <- jmvcore::resolveQuo(jmvcore::enquo(strata))
    if (missing(data))
        data <- jmvcore::marshalData(
            parent.frame(),
            `if`( ! missing(time), time, NULL),
            `if`( ! missing(event), event, NULL),
            `if`( ! missing(predictors), predictors, NULL),
            `if`( ! missing(strata), strata, NULL))

    for (v in strata) if (v %in% names(data)) data[[v]] <- as.factor(data[[v]])

    options <- adaptivelassoOptions$new(
        time = time,
        event = event,
        predictors = predictors,
        strata = strata,
        weight_method = weight_method,
        alpha = alpha,
        gamma = gamma,
        cv_folds = cv_folds,
        cv_measure = cv_measure,
        lambda_sequence = lambda_sequence,
        lambda_min_ratio = lambda_min_ratio,
        n_lambda = n_lambda,
        stability_selection = stability_selection,
        stability_threshold = stability_threshold,
        bootstrap_samples = bootstrap_samples,
        subsampling_ratio = subsampling_ratio,
        proportional_hazards = proportional_hazards,
        influence_diagnostics = influence_diagnostics,
        goodness_of_fit = goodness_of_fit,
        risk_groups = risk_groups,
        time_points = time_points,
        baseline_survival = baseline_survival,
        show_coefficients = show_coefficients,
        show_selection_path = show_selection_path,
        show_cv_results = show_cv_results,
        show_diagnostics = show_diagnostics,
        plot_selection_path = plot_selection_path,
        plot_cv_curve = plot_cv_curve,
        plot_stability = plot_stability,
        plot_survival_curves = plot_survival_curves,
        plot_baseline_hazard = plot_baseline_hazard,
        plot_diagnostics = plot_diagnostics,
        tie_method = tie_method,
        standardize = standardize,
        intercept = intercept,
        parallel_computing = parallel_computing,
        n_cores = n_cores,
        convergence_threshold = convergence_threshold,
        max_iterations = max_iterations,
        random_seed = random_seed)

    analysis <- adaptivelassoClass$new(
        options = options,
        data = data)

    analysis$run()

    analysis$results
}

