
# This file is automatically generated, you probably don't want to edit this

mixedmodelanovaOptions <- if (requireNamespace("jmvcore", quietly=TRUE)) R6::R6Class(
    "mixedmodelanovaOptions",
    inherit = jmvcore::Options,
    public = list(
        initialize = function(
            dependent = NULL,
            fixed_factors = NULL,
            random_factors = NULL,
            covariates = NULL,
            model_type = "random_intercept",
            interaction_terms = FALSE,
            estimation_method = "reml",
            show_fixed_effects = TRUE,
            show_random_effects = TRUE,
            show_model_fit = TRUE,
            show_assumptions = TRUE,
            show_posthoc = FALSE,
            posthoc_method = "tukey",
            confidence_level = 0.95,
            show_effect_sizes = TRUE,
            show_icc = TRUE,
            show_plots = TRUE,
            show_methodology = FALSE,
            show_references = FALSE, ...) {

            super$initialize(
                package = "ClinicoPath",
                name = "mixedmodelanova",
                requiresData = TRUE,
                ...)

            private$..dependent <- jmvcore::OptionVariable$new(
                "dependent",
                dependent)
            private$..fixed_factors <- jmvcore::OptionVariables$new(
                "fixed_factors",
                fixed_factors)
            private$..random_factors <- jmvcore::OptionVariables$new(
                "random_factors",
                random_factors)
            private$..covariates <- jmvcore::OptionVariables$new(
                "covariates",
                covariates)
            private$..model_type <- jmvcore::OptionList$new(
                "model_type",
                model_type,
                options = list("random_intercept", "random_slope", "nested"),
                default = "random_intercept")
            private$..interaction_terms <- jmvcore::OptionBool$new(
                "interaction_terms",
                interaction_terms,
                default = FALSE)
            private$..estimation_method <- jmvcore::OptionList$new(
                "estimation_method",
                estimation_method,
                options = list("reml", "ml"),
                default = "reml")
            private$..show_fixed_effects <- jmvcore::OptionBool$new(
                "show_fixed_effects",
                show_fixed_effects,
                default = TRUE)
            private$..show_random_effects <- jmvcore::OptionBool$new(
                "show_random_effects",
                show_random_effects,
                default = TRUE)
            private$..show_model_fit <- jmvcore::OptionBool$new(
                "show_model_fit",
                show_model_fit,
                default = TRUE)
            private$..show_assumptions <- jmvcore::OptionBool$new(
                "show_assumptions",
                show_assumptions,
                default = TRUE)
            private$..show_posthoc <- jmvcore::OptionBool$new(
                "show_posthoc",
                show_posthoc,
                default = FALSE)
            private$..posthoc_method <- jmvcore::OptionList$new(
                "posthoc_method",
                posthoc_method,
                options = list("tukey", "bonferroni", "holm", "none"),
                default = "tukey")
            private$..confidence_level <- jmvcore::OptionNumber$new(
                "confidence_level",
                confidence_level,
                min = 0.50,
                max = 0.99,
                default = 0.95)
            private$..show_effect_sizes <- jmvcore::OptionBool$new(
                "show_effect_sizes",
                show_effect_sizes,
                default = TRUE)
            private$..show_icc <- jmvcore::OptionBool$new(
                "show_icc",
                show_icc,
                default = TRUE)
            private$..show_plots <- jmvcore::OptionBool$new(
                "show_plots",
                show_plots,
                default = TRUE)
            private$..show_methodology <- jmvcore::OptionBool$new(
                "show_methodology",
                show_methodology,
                default = FALSE)
            private$..show_references <- jmvcore::OptionBool$new(
                "show_references",
                show_references,
                default = FALSE)

            self$.addOption(private$..dependent)
            self$.addOption(private$..fixed_factors)
            self$.addOption(private$..random_factors)
            self$.addOption(private$..covariates)
            self$.addOption(private$..model_type)
            self$.addOption(private$..interaction_terms)
            self$.addOption(private$..estimation_method)
            self$.addOption(private$..show_fixed_effects)
            self$.addOption(private$..show_random_effects)
            self$.addOption(private$..show_model_fit)
            self$.addOption(private$..show_assumptions)
            self$.addOption(private$..show_posthoc)
            self$.addOption(private$..posthoc_method)
            self$.addOption(private$..confidence_level)
            self$.addOption(private$..show_effect_sizes)
            self$.addOption(private$..show_icc)
            self$.addOption(private$..show_plots)
            self$.addOption(private$..show_methodology)
            self$.addOption(private$..show_references)
        }),
    active = list(
        dependent = function() private$..dependent$value,
        fixed_factors = function() private$..fixed_factors$value,
        random_factors = function() private$..random_factors$value,
        covariates = function() private$..covariates$value,
        model_type = function() private$..model_type$value,
        interaction_terms = function() private$..interaction_terms$value,
        estimation_method = function() private$..estimation_method$value,
        show_fixed_effects = function() private$..show_fixed_effects$value,
        show_random_effects = function() private$..show_random_effects$value,
        show_model_fit = function() private$..show_model_fit$value,
        show_assumptions = function() private$..show_assumptions$value,
        show_posthoc = function() private$..show_posthoc$value,
        posthoc_method = function() private$..posthoc_method$value,
        confidence_level = function() private$..confidence_level$value,
        show_effect_sizes = function() private$..show_effect_sizes$value,
        show_icc = function() private$..show_icc$value,
        show_plots = function() private$..show_plots$value,
        show_methodology = function() private$..show_methodology$value,
        show_references = function() private$..show_references$value),
    private = list(
        ..dependent = NA,
        ..fixed_factors = NA,
        ..random_factors = NA,
        ..covariates = NA,
        ..model_type = NA,
        ..interaction_terms = NA,
        ..estimation_method = NA,
        ..show_fixed_effects = NA,
        ..show_random_effects = NA,
        ..show_model_fit = NA,
        ..show_assumptions = NA,
        ..show_posthoc = NA,
        ..posthoc_method = NA,
        ..confidence_level = NA,
        ..show_effect_sizes = NA,
        ..show_icc = NA,
        ..show_plots = NA,
        ..show_methodology = NA,
        ..show_references = NA)
)

mixedmodelanovaResults <- if (requireNamespace("jmvcore", quietly=TRUE)) R6::R6Class(
    "mixedmodelanovaResults",
    inherit = jmvcore::Group,
    active = list(
        model_info = function() private$.items[["model_info"]],
        fixed_effects = function() private$.items[["fixed_effects"]],
        anova_table = function() private$.items[["anova_table"]],
        random_effects = function() private$.items[["random_effects"]],
        model_fit = function() private$.items[["model_fit"]],
        icc_table = function() private$.items[["icc_table"]],
        effect_sizes = function() private$.items[["effect_sizes"]],
        posthoc = function() private$.items[["posthoc"]],
        assumptions = function() private$.items[["assumptions"]],
        diagnostic_plots = function() private$.items[["diagnostic_plots"]],
        interpretation = function() private$.items[["interpretation"]],
        methodology = function() private$.items[["methodology"]],
        references = function() private$.items[["references"]]),
    private = list(),
    public=list(
        initialize=function(options) {
            super$initialize(
                options = options,
                name = "",
                title = "Mixed Model ANOVA")
            self$add(jmvcore::Table$new(
                options = options,
                name = "model_info",
                title = "Model Information",
                rows = 1,
                columns = list(
                    list(name = "formula", title = "Model Formula", type = "text"),
                    list(name = "estimation", title = "Estimation Method", type = "text"),
                    list(name = "n_obs", title = "Observations", type = "integer"),
                    list(name = "n_groups", title = "Number of Groups", type = "integer"))))
            self$add(jmvcore::Table$new(
                options = options,
                name = "fixed_effects",
                title = "Fixed Effects",
                visible = "(show_fixed_effects)",
                rows = 0,
                columns = list(
                    list(name = "term", title = "Term", type = "text"),
                    list(name = "estimate", title = "Estimate", type = "number"),
                    list(name = "se", title = "Std. Error", type = "number"),
                    list(name = "df", title = "df", type = "number"),
                    list(name = "t_value", title = "t", type = "number"),
                    list(name = "p_value", title = "p", type = "number", format = "zto,pvalue"))))
            self$add(jmvcore::Table$new(
                options = options,
                name = "anova_table",
                title = "Type III ANOVA Table",
                visible = "(show_fixed_effects)",
                rows = 0,
                columns = list(
                    list(name = "term", title = "Effect", type = "text"),
                    list(name = "sumsq", title = "Sum Sq", type = "number"),
                    list(name = "meansq", title = "Mean Sq", type = "number"),
                    list(name = "numdf", title = "NumDF", type = "number"),
                    list(name = "dendf", title = "DenDF", type = "number"),
                    list(name = "f_value", title = "F", type = "number"),
                    list(name = "p_value", title = "p", type = "number", format = "zto,pvalue"))))
            self$add(jmvcore::Table$new(
                options = options,
                name = "random_effects",
                title = "Random Effects",
                visible = "(show_random_effects)",
                rows = 0,
                columns = list(
                    list(name = "group", title = "Group", type = "text"),
                    list(name = "variance", title = "Variance", type = "number"),
                    list(name = "std_dev", title = "Std. Dev", type = "number"))))
            self$add(jmvcore::Table$new(
                options = options,
                name = "model_fit",
                title = "Model Fit Statistics",
                visible = "(show_model_fit)",
                rows = 1,
                columns = list(
                    list(name = "aic", title = "AIC", type = "number"),
                    list(name = "bic", title = "BIC", type = "number"),
                    list(name = "loglik", title = "Log-Likelihood", type = "number"),
                    list(name = "deviance", title = "Deviance", type = "number"))))
            self$add(jmvcore::Table$new(
                options = options,
                name = "icc_table",
                title = "Intraclass Correlation Coefficients",
                visible = "(show_icc)",
                rows = 0,
                columns = list(
                    list(name = "group", title = "Grouping Variable", type = "text"),
                    list(name = "icc", title = "ICC", type = "number"),
                    list(name = "interpretation", title = "Interpretation", type = "text"))))
            self$add(jmvcore::Table$new(
                options = options,
                name = "effect_sizes",
                title = "Effect Sizes (Partial η²)",
                visible = "(show_effect_sizes)",
                rows = 0,
                columns = list(
                    list(name = "term", title = "Effect", type = "text"),
                    list(name = "partial_eta_sq", title = "Partial η²", type = "number"),
                    list(name = "interpretation", title = "Interpretation", type = "text"))))
            self$add(jmvcore::Table$new(
                options = options,
                name = "posthoc",
                title = "Post Hoc Comparisons",
                visible = "(show_posthoc)",
                rows = 0,
                columns = list(
                    list(name = "contrast", title = "Contrast", type = "text"),
                    list(name = "estimate", title = "Estimate", type = "number"),
                    list(name = "se", title = "Std. Error", type = "number"),
                    list(name = "df", title = "df", type = "number"),
                    list(name = "t_ratio", title = "t ratio", type = "number"),
                    list(name = "p_value", title = "p", type = "number", format = "zto,pvalue"))))
            self$add(jmvcore::Table$new(
                options = options,
                name = "assumptions",
                title = "Assumption Checks",
                visible = "(show_assumptions)",
                rows = 0,
                columns = list(
                    list(name = "test", title = "Test", type = "text"),
                    list(name = "statistic", title = "Statistic", type = "number"),
                    list(name = "p_value", title = "p", type = "number", format = "zto,pvalue"),
                    list(name = "result", title = "Result", type = "text"))))
            self$add(jmvcore::Image$new(
                options = options,
                name = "diagnostic_plots",
                title = "Diagnostic Plots",
                visible = "(show_plots)",
                width = 600,
                height = 600,
                renderFun = ".diagnosticPlots"))
            self$add(jmvcore::Html$new(
                options = options,
                name = "interpretation",
                title = "Interpretation Guide"))
            self$add(jmvcore::Html$new(
                options = options,
                name = "methodology",
                title = "Methodology",
                visible = "(show_methodology)"))
            self$add(jmvcore::Html$new(
                options = options,
                name = "references",
                title = "References",
                visible = "(show_references)"))}))

mixedmodelanovaBase <- if (requireNamespace("jmvcore", quietly=TRUE)) R6::R6Class(
    "mixedmodelanovaBase",
    inherit = jmvcore::Analysis,
    public = list(
        initialize = function(options, data = NULL, datasetId = "", analysisId = "", revision = 0) {
            super$initialize(
                package = "ClinicoPath",
                name = "mixedmodelanova",
                version = c(1,0,0),
                options = options,
                results = mixedmodelanovaResults$new(options = options),
                data = data,
                datasetId = datasetId,
                analysisId = analysisId,
                revision = revision,
                pause = NULL,
                completeWhenFilled = FALSE,
                requiresMissings = FALSE,
                weightsSupport = 'na')
        }))

#' Mixed Model ANOVA
#'
#' Linear mixed effects models with repeated measures
#'
#' @examples
#' data('sleep', package='lme4')
#' mixedmodelanova(data = sleep, dependent = Reaction,
#'                 random_factors = Subject)
#'
#' @param data the data as a data frame
#' @param dependent the dependent variable
#' @param fixed_factors fixed factors
#' @param random_factors random factors (grouping variables)
#' @param covariates covariates
#' @param model_type model structure
#' @param interaction_terms include interaction terms
#' @param estimation_method REML or ML
#' @param ... additional arguments
#' @return A results object containing tables and plots
#' @export
mixedmodelanova <- function(
    data,
    dependent,
    fixed_factors,
    random_factors,
    covariates,
    model_type = "random_intercept",
    interaction_terms = FALSE,
    estimation_method = "reml",
    show_fixed_effects = TRUE,
    show_random_effects = TRUE,
    show_model_fit = TRUE,
    show_assumptions = TRUE,
    show_posthoc = FALSE,
    posthoc_method = "tukey",
    confidence_level = 0.95,
    show_effect_sizes = TRUE,
    show_icc = TRUE,
    show_plots = TRUE,
    show_methodology = FALSE,
    show_references = FALSE) {

    if ( ! requireNamespace("jmvcore", quietly=TRUE))
        stop("mixedmodelanova requires jmvcore to be installed (restart may be required)")

    if ( ! missing(dependent)) dependent <- jmvcore::resolveQuo(jmvcore::enquo(dependent))
    if ( ! missing(fixed_factors)) fixed_factors <- jmvcore::resolveQuo(jmvcore::enquo(fixed_factors))
    if ( ! missing(random_factors)) random_factors <- jmvcore::resolveQuo(jmvcore::enquo(random_factors))
    if ( ! missing(covariates)) covariates <- jmvcore::resolveQuo(jmvcore::enquo(covariates))
    if (missing(data))
        data <- jmvcore::marshalData(
            parent.frame(),
            `if`( ! missing(dependent), dependent, NULL),
            `if`( ! missing(fixed_factors), fixed_factors, NULL),
            `if`( ! missing(random_factors), random_factors, NULL),
            `if`( ! missing(covariates), covariates, NULL))

    options <- mixedmodelanovaOptions$new(
        dependent = dependent,
        fixed_factors = fixed_factors,
        random_factors = random_factors,
        covariates = covariates,
        model_type = model_type,
        interaction_terms = interaction_terms,
        estimation_method = estimation_method,
        show_fixed_effects = show_fixed_effects,
        show_random_effects = show_random_effects,
        show_model_fit = show_model_fit,
        show_assumptions = show_assumptions,
        show_posthoc = show_posthoc,
        posthoc_method = posthoc_method,
        confidence_level = confidence_level,
        show_effect_sizes = show_effect_sizes,
        show_icc = show_icc,
        show_plots = show_plots,
        show_methodology = show_methodology,
        show_references = show_references)

    analysis <- mixedmodelanovaClass$new(
        options = options,
        data = data)

    analysis$run()

    analysis$results
}

mixedmodelanovaClass <- if (requireNamespace("jmvcore", quietly=TRUE)) R6::R6Class(
    "mixedmodelanovaClass",
    inherit = mixedmodelanovaBase,
    private = list(
        .run = function() {

            # Check if required packages are available
            if (!requireNamespace("lme4", quietly = TRUE)) {
                stop("Package 'lme4' is required but not installed. Please install it.")
            }
            if (!requireNamespace("lmerTest", quietly = TRUE)) {
                stop("Package 'lmerTest' is required but not installed. Please install it.")
            }

            # Get variables
            dep <- self$options$dependent
            fixed_fac <- self$options$fixed_factors
            random_fac <- self$options$random_factors
            covars <- self$options$covariates

            # Check if we have the minimum required variables
            if (is.null(dep) || length(random_fac) == 0) {
                return()
            }

            # Get data
            data <- self$data

            # Prepare data
            for (var in random_fac) {
                if (!is.factor(data[[var]])) {
                    data[[var]] <- as.factor(data[[var]])
                }
            }
            for (var in fixed_fac) {
                if (!is.factor(data[[var]])) {
                    data[[var]] <- as.factor(data[[var]])
                }
            }

            # Build formula
            formula_str <- private$.buildFormula()
            if (is.null(formula_str)) {
                return()
            }

            # Fit model
            model <- tryCatch({
                reml <- self$options$estimation_method == "reml"
                lmerTest::lmer(as.formula(formula_str), data = data, REML = reml)
            }, error = function(e) {
                stop(paste("Model fitting failed:", e$message))
            })

            # Store model for use by other methods
            private$.model <- model

            # Populate results
            private$.populateModelInfo(model, formula_str)
            private$.populateFixedEffects(model)
            private$.populateAnovaTable(model)
            private$.populateRandomEffects(model)
            private$.populateModelFit(model)
            private$.populateICC(model)
            private$.populateEffectSizes(model)
            if (self$options$show_posthoc) {
                private$.populatePostHoc(model)
            }
            private$.populateAssumptions(model)
            private$.populateInterpretation()
            private$.populateMethodology()
            private$.populateReferences()
        },

        .model = NULL,

        .buildFormula = function() {
            dep <- self$options$dependent
            fixed_fac <- self$options$fixed_factors
            random_fac <- self$options$random_factors
            covars <- self$options$covariates
            model_type <- self$options$model_type
            interaction_terms <- self$options$interaction_terms

            # Build fixed effects part
            fixed_terms <- c(fixed_fac, covars)
            if (length(fixed_terms) == 0) {
                fixed_part <- "1"
            } else if (interaction_terms && length(fixed_fac) > 1) {
                fixed_part <- paste(fixed_fac, collapse = " * ")
                if (length(covars) > 0) {
                    fixed_part <- paste(c(fixed_part, covars), collapse = " + ")
                }
            } else {
                fixed_part <- paste(fixed_terms, collapse = " + ")
            }

            # Build random effects part
            if (model_type == "random_intercept") {
                random_part <- paste0("(1 | ", random_fac[1], ")")
            } else if (model_type == "random_slope") {
                if (length(fixed_fac) == 0) {
                    stop("Random slope model requires at least one fixed factor")
                }
                random_part <- paste0("(", fixed_fac[1], " | ", random_fac[1], ")")
            } else if (model_type == "nested") {
                if (length(random_fac) < 2) {
                    stop("Nested design requires at least two random factors")
                }
                random_part <- paste0("(1 | ", random_fac[1], "/", random_fac[2], ")")
            }

            # Combine
            formula_str <- paste(dep, "~", fixed_part, "+", random_part)
            return(formula_str)
        },

        .populateModelInfo = function(model, formula_str) {
            table <- self$results$model_info

            n_obs <- nrow(model@frame)
            n_groups <- length(unique(model@frame[[names(model@flist)[1]]]))
            estimation <- toupper(self$options$estimation_method)

            table$setRow(rowNo = 1, values = list(
                formula = formula_str,
                estimation = estimation,
                n_obs = n_obs,
                n_groups = n_groups
            ))
        },

        .populateFixedEffects = function(model) {
            if (!self$options$show_fixed_effects) return()

            table <- self$results$fixed_effects
            coef_summary <- summary(model)$coefficients

            for (i in 1:nrow(coef_summary)) {
                table$addRow(rowKey = i, values = list(
                    term = rownames(coef_summary)[i],
                    estimate = coef_summary[i, "Estimate"],
                    se = coef_summary[i, "Std. Error"],
                    df = coef_summary[i, "df"],
                    t_value = coef_summary[i, "t value"],
                    p_value = coef_summary[i, "Pr(>|t|)"]
                ))
            }
        },

        .populateAnovaTable = function(model) {
            if (!self$options$show_fixed_effects) return()

            table <- self$results$anova_table
            anova_result <- anova(model)

            for (i in 1:nrow(anova_result)) {
                table$addRow(rowKey = i, values = list(
                    term = rownames(anova_result)[i],
                    sumsq = anova_result[i, "Sum Sq"],
                    meansq = anova_result[i, "Mean Sq"],
                    numdf = anova_result[i, "NumDF"],
                    dendf = anova_result[i, "DenDF"],
                    f_value = anova_result[i, "F value"],
                    p_value = anova_result[i, "Pr(>F)"]
                ))
            }
        },

        .populateRandomEffects = function(model) {
            if (!self$options$show_random_effects) return()

            table <- self$results$random_effects
            vc <- as.data.frame(lme4::VarCorr(model))

            for (i in 1:nrow(vc)) {
                if (!is.na(vc$grp[i])) {
                    group_name <- paste(vc$grp[i], if (!is.na(vc$var1[i])) paste0(" (", vc$var1[i], ")") else "")
                    table$addRow(rowKey = i, values = list(
                        group = group_name,
                        variance = vc$vcov[i],
                        std_dev = vc$sdcor[i]
                    ))
                }
            }
        },

        .populateModelFit = function(model) {
            if (!self$options$show_model_fit) return()

            table <- self$results$model_fit
            table$setRow(rowNo = 1, values = list(
                aic = AIC(model),
                bic = BIC(model),
                loglik = as.numeric(logLik(model)),
                deviance = deviance(model)
            ))
        },

        .populateICC = function(model) {
            if (!self$options$show_icc) return()

            table <- self$results$icc_table

            # Calculate ICC
            vc <- as.data.frame(lme4::VarCorr(model))
            var_random <- sum(vc$vcov[!is.na(vc$grp) & vc$grp != "Residual"])
            var_residual <- vc$vcov[vc$grp == "Residual"]
            icc <- var_random / (var_random + var_residual)

            interpretation <- if (icc < 0.05) {
                "Very low clustering"
            } else if (icc < 0.10) {
                "Low clustering"
            } else if (icc < 0.15) {
                "Moderate clustering"
            } else {
                "High clustering"
            }

            table$addRow(rowKey = 1, values = list(
                group = names(model@flist)[1],
                icc = icc,
                interpretation = interpretation
            ))
        },

        .populateEffectSizes = function(model) {
            if (!self$options$show_effect_sizes) return()

            table <- self$results$effect_sizes
            anova_result <- anova(model)

            for (i in 1:nrow(anova_result)) {
                # Calculate partial eta squared
                f_val <- anova_result[i, "F value"]
                df1 <- anova_result[i, "NumDF"]
                df2 <- anova_result[i, "DenDF"]
                partial_eta_sq <- (f_val * df1) / (f_val * df1 + df2)

                interpretation <- if (partial_eta_sq < 0.01) {
                    "Negligible"
                } else if (partial_eta_sq < 0.06) {
                    "Small"
                } else if (partial_eta_sq < 0.14) {
                    "Medium"
                } else {
                    "Large"
                }

                table$addRow(rowKey = i, values = list(
                    term = rownames(anova_result)[i],
                    partial_eta_sq = partial_eta_sq,
                    interpretation = interpretation
                ))
            }
        },

        .populatePostHoc = function(model) {
            if (!requireNamespace("emmeans", quietly = TRUE)) {
                return()
            }

            table <- self$results$posthoc
            fixed_fac <- self$options$fixed_factors
            if (length(fixed_fac) == 0) return()

            tryCatch({
                emm <- emmeans::emmeans(model, specs = fixed_fac[1])
                pairs <- emmeans::pairs(emm, adjust = self$options$posthoc_method)
                pairs_summary <- summary(pairs)

                for (i in 1:nrow(pairs_summary)) {
                    table$addRow(rowKey = i, values = list(
                        contrast = as.character(pairs_summary$contrast[i]),
                        estimate = pairs_summary$estimate[i],
                        se = pairs_summary$SE[i],
                        df = pairs_summary$df[i],
                        t_ratio = pairs_summary$t.ratio[i],
                        p_value = pairs_summary$p.value[i]
                    ))
                }
            }, error = function(e) {
                # Silently fail if emmeans doesn't work
            })
        },

        .populateAssumptions = function(model) {
            if (!self$options$show_assumptions) return()

            table <- self$results$assumptions
            residuals <- residuals(model)

            # Normality test (Shapiro-Wilk on sample if > 5000 observations)
            if (length(residuals) > 5000) {
                residuals_sample <- sample(residuals, 5000)
            } else {
                residuals_sample <- residuals
            }

            shapiro <- shapiro.test(residuals_sample)
            table$addRow(rowKey = 1, values = list(
                test = "Shapiro-Wilk (Normality of Residuals)",
                statistic = shapiro$statistic,
                p_value = shapiro$p.value,
                result = if (shapiro$p.value > 0.05) "Assumption met" else "Assumption violated"
            ))
        },

        .diagnosticPlots = function(image, ggtheme, theme, ...) {
            if (!self$options$show_plots) return()
            if (is.null(private$.model)) return()

            model <- private$.model

            # Create 2x2 diagnostic plot
            par(mfrow = c(2, 2))
            plot(model)

            TRUE
        },

        .populateInterpretation = function() {
            html <- self$results$interpretation

            interpretation_text <- "
            <h3>How to Interpret Mixed Model ANOVA Results</h3>
            <p><strong>Fixed Effects:</strong> Test whether predictors have significant effects on the outcome.</p>
            <p><strong>Random Effects:</strong> Show variance at different levels (e.g., between subjects).</p>
            <p><strong>ICC (Intraclass Correlation):</strong> Proportion of variance due to grouping.
               Values > 0.10 indicate substantial clustering.</p>
            <p><strong>Effect Sizes (Partial η²):</strong> 0.01 = small, 0.06 = medium, 0.14 = large.</p>
            "

            html$setContent(interpretation_text)
        },

        .populateMethodology = function() {
            if (!self$options$show_methodology) return()

            html <- self$results$methodology

            methodology_text <- "
            <h3>Methodology</h3>
            <p>Mixed model ANOVA (also called multilevel modeling or hierarchical linear modeling) analyzes
            data with both fixed and random effects. This approach accounts for non-independence in nested
            or repeated measures data.</p>
            <p><strong>Model:</strong> Linear mixed effects model fitted using lme4 and lmerTest packages.</p>
            <p><strong>Estimation:</strong> REML (Restricted Maximum Likelihood) for unbiased variance estimates,
            or ML (Maximum Likelihood) for model comparisons.</p>
            <p><strong>Type III ANOVA:</strong> Tests each effect while controlling for all other effects.</p>
            "

            html$setContent(methodology_text)
        },

        .populateReferences = function() {
            if (!self$options$show_references) return()

            html <- self$results$references

            references_text <- "
            <h3>References</h3>
            <ul>
            <li>Bates, D., Mächler, M., Bolker, B., & Walker, S. (2015). Fitting Linear Mixed-Effects Models Using lme4.
                <em>Journal of Statistical Software</em>, 67(1), 1-48.</li>
            <li>Kuznetsova, A., Brockhoff, P. B., & Christensen, R. H. B. (2017). lmerTest Package: Tests in Linear Mixed Effects Models.
                <em>Journal of Statistical Software</em>, 82(13), 1-26.</li>
            <li>Snijders, T. A. B., & Bosker, R. J. (2012). <em>Multilevel Analysis: An Introduction to Basic and Advanced Multilevel Modeling</em> (2nd ed.).
                Sage Publications.</li>
            </ul>
            "

            html$setContent(references_text)
        }
    )
)
