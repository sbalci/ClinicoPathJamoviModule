# Ensure internationalization function is available
if (!exists(".")) {
  . <- function(x) x  # Fallback identity function for testing
}

# Helper function to escape variable names with special characters for formulas
.escapeVariableNames <- function(var_names) {
    # Check if variable names contain special characters that need escaping
    need_escaping <- grepl("[^a-zA-Z0-9._]", var_names)
    var_names[need_escaping] <- paste0("`", var_names[need_escaping], "`")
    return(var_names)
}

# Helper function to restore original variable names in output tables
.restoreOriginalNamesInMultiSurvivalTable <- function(table_data, name_mapping) {
    if (is.null(table_data) || nrow(table_data) == 0 || is.null(name_mapping)) {
        return(table_data)
    }

    # Restore names in the first column (which typically contains variable names)
    if (ncol(table_data) > 0) {
        first_col <- table_data[, 1]

        # For each entry in the first column, check if it needs name restoration
        for (i in seq_along(first_col)) {
            original_name <- first_col[i]

            # Handle factor levels (like "variablename1" vs "variablename0")
            for (clean_name in names(name_mapping)) {
                if (grepl(paste0("^", clean_name), original_name)) {
                    # Replace the clean name part with the original name
                    table_data[i, 1] <- sub(clean_name, name_mapping[[clean_name]], original_name)
                    break
                }
            }
        }
    }

    return(table_data)
}



# Helper function for package dependency checking with graceful fallbacks
.checkPackageDependency <- function(package_name, method_name, alternative_method = "Cox regression") {
  if (!requireNamespace(package_name, quietly = TRUE)) {
    fallback_info <- list(
      available = FALSE,
      message = paste0("
        <div style='background-color: #fff3cd; border: 1px solid #ffeaa7; padding: 15px; border-radius: 5px; margin: 10px 0;'>
          <h4 style='color: #856404; margin-top: 0;'>‚ö†Ô∏è ", method_name, " ", .("Package Not Available"), "</h4>
          <p><strong>", .("Issue:"), "</strong> ", .("The"), " '", package_name, "' ", .("package is required but not installed."), "</p>
          <p><strong>", .("Solution:"), "</strong> ", .("Install the package using:"), " <code>install.packages('", package_name, "')</code></p>
          <p><strong>", .("Alternative:"), "</strong> ", .("Automatically switching to"), " ", alternative_method, " ", .("analysis."), "</p>
        </div>
      ")
    )
  } else {
    fallback_info <- list(available = TRUE, message = "")
  }
  return(fallback_info)
}

# Helper function for comprehensive data validation
.validateSurvivalData <- function(data, time_var = "mytime", outcome_var = "myoutcome") {
  issues <- list()
  warnings <- list()

  # Check for negative survival times
  if (time_var %in% names(data)) {
    negative_times <- sum(data[[time_var]] < 0, na.rm = TRUE)
    if (negative_times > 0) {
      issues <- append(issues, paste(.("Negative survival times detected:"), negative_times, .("observations")))
    }

    # Check for zero survival times
    zero_times <- sum(data[[time_var]] == 0, na.rm = TRUE)
    if (zero_times > 0) {
      warnings <- append(warnings, paste(.("Zero survival times detected:"), zero_times, .("observations. Consider adding small constant (0.5 days).")))
    }
  }

  # Check outcome coding
  if (outcome_var %in% names(data)) {
    unique_outcomes <- unique(data[[outcome_var]][!is.na(data[[outcome_var]])])
    if (!all(unique_outcomes %in% c(0, 1, TRUE, FALSE))) {
      issues <- append(issues, .("Outcome should be binary (0/1 or TRUE/FALSE)"))
    }

    # Check event rate
    event_rate <- mean(data[[outcome_var]], na.rm = TRUE)
    if (event_rate < 0.05) {
      warnings <- append(warnings, paste(.("Low event rate:"), round(event_rate * 100, 1), "%. ", .("Consider longer follow-up or different endpoint.")))
    }
  }

  # Check sample size adequacy
  n_complete <- sum(complete.cases(data))
  n_events <- sum(data[[outcome_var]], na.rm = TRUE)
  if (n_events < 10) {
    issues <- append(issues, paste(.("Insufficient events for analysis:"), n_events, "events. ", .("Minimum 10 events recommended.")))
  }

  return(list(issues = issues, warnings = warnings))
}

# Helper function for generating clinical interpretation summaries
.generateClinicalSummary <- function(results, analysis_type = "cox", n_vars = 0, n_events = 0) {

  # Extract key statistics based on analysis type
  if (analysis_type == "cox" && !is.null(results)) {

    # Count significant variables if results is a table/data.frame
    sig_count <- 0
    strongest_var <- NULL
    strongest_hr <- 1
    strongest_effect <- NULL

    tryCatch({
      if (is.data.frame(results) && "p" %in% names(results)) {
        p_values <- as.numeric(results$p)
        sig_indices <- which(p_values < 0.05 & !is.na(p_values))
        sig_count <- length(sig_indices)

        if (sig_count > 0) {
          # Find strongest effect (furthest from HR = 1)
          if ("HR (95% CI, p-value)" %in% names(results)) {
            hr_column <- results[["HR (95% CI, p-value)"]]
            for (i in sig_indices) {
              hr_text <- hr_column[i]
              hr_match <- regmatches(hr_text, regexpr("[0-9]+\\.?[0-9]*", hr_text))
              if (length(hr_match) > 0) {
                hr_val <- as.numeric(hr_match[1])
                if (!is.na(hr_val) && abs(log(hr_val)) > abs(log(strongest_hr))) {
                  strongest_hr <- hr_val
                  strongest_var <- results[i, 1]  # First column usually contains variable names
                  strongest_effect <- if (hr_val > 1) .("increased risk") else .("decreased risk")
                }
              }
            }
          }
        }
      }
    }, error = function(e) {
      # Silent error handling for robust operation
    })

    # Generate clinical summary
    summary_parts <- list()

    # Analysis overview
    summary_parts$overview <- paste0(
      .("This multivariable Cox regression analysis examined"), " ", n_vars, " ",
      .("potential risk factors in"), " ", .("patients with"), " ", n_events, " ",
      .("events observed during follow-up.")
    )

    # Key findings
    if (sig_count > 0) {
      summary_parts$findings <- paste0(
        .("Key Finding:"), " ", sig_count, " ", .("out of"), " ", n_vars, " ",
        .("factors showed statistically significant associations with the outcome"), " (p < 0.05)."
      )

      if (!is.null(strongest_var) && !is.null(strongest_effect)) {
        summary_parts$strongest <- paste0(
          .("Strongest predictor:"), " ", strongest_var, " ", .("was associated with"), " ",
          strongest_effect, " (", .("hazard ratio"), " = ", round(strongest_hr, 2), ")."
        )
      }
    } else {
      summary_parts$findings <- paste0(
        .("No statistically significant associations were identified among the"), " ",
        n_vars, " ", .("factors examined"), " (", .("all p-values ‚â• 0.05"), ")."
      )
    }

    # Clinical interpretation
    if (sig_count > 0 && !is.null(strongest_hr)) {
      risk_interpretation <- ""
      if (strongest_hr > 2) {
        risk_interpretation <- .("This represents a substantial clinical effect.")
      } else if (strongest_hr > 1.5 || strongest_hr < 0.67) {
        risk_interpretation <- .("This represents a moderate clinical effect.")
      } else if (strongest_hr != 1) {
        risk_interpretation <- .("This represents a mild clinical effect.")
      }

      summary_parts$interpretation <- paste0(
        .("Clinical Significance:"), " ", risk_interpretation, " ",
        .("Consider this factor in clinical decision-making and patient counseling.")
      )
    }

    # Combine all parts
    full_summary <- paste(summary_parts, collapse = " ")

    return(list(
      summary = full_summary,
      sig_count = sig_count,
      strongest_var = strongest_var,
      strongest_hr = strongest_hr
    ))
  }

  # Default return for other analysis types
  return(list(
    summary = .("Analysis completed. Review detailed results below."),
    sig_count = 0,
    strongest_var = NULL,
    strongest_hr = 1
  ))
}

# Helper function to assess clinical significance of hazard ratios
.assessClinicalSignificance <- function(hr) {
  if (is.null(hr) || !is.numeric(hr) || hr <= 0) {
    return(.("Unable to assess clinical significance."))
  }

  if (hr > 3 || hr < 0.33) {
    return(.("Large clinical effect - high priority for clinical consideration."))
  } else if (hr > 2 || hr < 0.5) {
    return(.("Moderate clinical effect - clinically meaningful."))
  } else if (hr > 1.5 || hr < 0.67) {
    return(.("Small to moderate clinical effect - may be clinically relevant."))
  } else if (hr != 1) {
    return(.("Small clinical effect - limited clinical impact."))
  } else {
    return(.("No clinical effect detected."))
  }
}

# Consolidated function for building survival formulas
.buildSurvivalFormula <- function(time_var, outcome_var, predictors, survival_type = "standard", start_var = NULL, stop_var = NULL, strata_vars = NULL) {
  # Escape all variable names for safe formula construction
  escaped_time <- .escapeVariableNames(time_var)
  escaped_outcome <- .escapeVariableNames(outcome_var)
  escaped_predictors <- .escapeVariableNames(predictors)

  # Build left-hand side based on survival type
  lhs <- switch(survival_type,
    "standard" = paste0("survival::Surv(", escaped_time, ", ", escaped_outcome, ")"),
    "counting" = {
      if (is.null(start_var) || is.null(stop_var)) {
        stop("Start and stop variables required for counting process format")
      }
      escaped_start <- .escapeVariableNames(start_var)
      escaped_stop <- .escapeVariableNames(stop_var)
      paste0("survival::Surv(", escaped_start, ", ", escaped_stop, ", ", escaped_outcome, ")")
    },
    "interval" = {
      if (is.null(stop_var)) {
        stop("Stop time variable required for interval censoring")
      }
      escaped_stop <- .escapeVariableNames(stop_var)
      paste0("survival::Surv(", escaped_time, ", ", escaped_stop, ", ", escaped_outcome, ")")
    },
    stop("Unknown survival type: ", survival_type)
  )

  # Build right-hand side
  if (length(escaped_predictors) == 0) {
    rhs <- "1"  # Null model
  } else {
    rhs <- paste(escaped_predictors, collapse = " + ")

    # Add stratification if specified
    if (!is.null(strata_vars) && length(strata_vars) > 0) {
      escaped_strata <- .escapeVariableNames(strata_vars)
      strata_term <- paste0("strata(", paste(escaped_strata, collapse = ", "), ")")
      rhs <- paste(rhs, strata_term, sep = " + ")
    }
  }

  # Combine and return formula
  formula_string <- paste0(lhs, " ~ ", rhs)
  return(as.formula(formula_string))
}

#' @title Multivariable Survival Analysis Implementation
#' @description
#' Backend implementation class for comprehensive multivariable survival analysis.
#' This R6 class provides the core functionality for the multisurvival jamovi module,
#' handling Cox proportional hazards regression, risk stratification, machine learning
#' survival methods, and advanced survival modeling techniques.
#'
#' @details
#' The multisurvivalClass implements a modular architecture with the following components:
#'
#' \strong{Core Analysis Engine:}
#' - Input validation and data preparation
#' - Cox proportional hazards modeling
#' - Competing risks and cause-specific survival
#' - Time-dependent covariate handling
#'
#' \strong{Advanced Methods:}
#' - Stratified analysis for non-proportional hazards
#' - Frailty models for clustered data
#' - Spline-based time-varying effects
#' - Machine learning survival algorithms
#'
#' \strong{Risk Assessment:}
#' - Prognostic risk score calculation
#' - Risk group stratification
#' - Nomogram generation
#' - Decision tree analysis
#'
#' \strong{Visualization & Output:}
#' - Forest plots and survival curves
#' - Person-time analysis
#' - Natural language summaries
#' - Educational explanations
#'
#' @seealso \code{\link{multisurvival}} for the main user interface function
#' @importFrom R6 R6Class
#' @import jmvcore
#' @keywords internal

multisurvivalClass <- if (requireNamespace('jmvcore'))
  R6::R6Class(
    "multisurvivalClass",
    inherit = multisurvivalBase,
    private = list(

      # Constants for plot sizing
      PLOT_WIDTH_FACTOR = 400,
      PLOT_HEIGHT_FACTOR = 300,
      DEFAULT_PLOT_WIDTH = 600,
      DEFAULT_PLOT_HEIGHT = 450,

      # Constants for analysis parameters
      DEFAULT_MIN_NODE = 20,
      DEFAULT_COMPLEXITY = 0.01,
      DEFAULT_MAX_DEPTH = 5,
      DEFAULT_SPLINE_DF = 3,

      # Constants for time intervals
      DEFAULT_TIME_INTERVALS = "12, 36, 60",
      DEFAULT_RATE_MULTIPLIER = 100,
      DEFAULT_CHANGE_TIMES = "6, 12, 18",
      DEFAULT_TD_SUFFIX = "_t{time}",

      .nom_object = NULL,
      .perf_timers = NULL,

      # Validation Helper Functions ----

      # Comprehensive Survival Analysis Input Validation
      #
      # Validates all required inputs for survival analysis including outcome variables,
      # time variables, and predictor variables. This is the main validation function
      # that orchestrates all validation checks.
      #
      # Returns a list containing:
      #   - valid: Boolean indicating if all inputs are valid
      #   - has_outcome: Boolean indicating if outcome variable is specified
      #   - has_time: Boolean indicating if time variables are properly specified
      #   - has_predictors: Boolean indicating if predictor variables are specified
      #
      # This function performs comprehensive validation by checking:
      # - Outcome variable presence
      # - Time variable configuration (either direct elapsed time or date-based calculation)
      # - Predictor variable specification (categorical or continuous explanatory variables)
      .validateSurvivalInputs = function() {
        has_outcome <- !is.null(self$options$outcome)
        has_time <- private$.validateTimeInputs()
        has_predictors <- private$.validatePredictorInputs()

        return(list(
          valid = has_outcome && has_time && has_predictors,
          has_outcome = has_outcome,
          has_time = has_time,
          has_predictors = has_predictors
        ))
      },

      # Time Variable Validation
      #
      # Validates time variable configuration for survival analysis. Supports both
      # direct elapsed time input and automatic calculation from diagnosis/follow-up dates.
      #
      # Returns: Boolean indicating if time variables are properly configured
      #
      # Checks two possible time configuration scenarios:
      # 1. Calculated time (tint = TRUE): Requires both dxdate and fudate
      # 2. Direct time (tint = FALSE): Requires elapsedtime variable
      .validateTimeInputs = function() {
        has_time_calc <- self$options$tint && !is.null(self$options$dxdate) && !is.null(self$options$fudate)
        has_time_direct <- !self$options$tint && !is.null(self$options$elapsedtime)
        return(has_time_calc || has_time_direct)
      },

      # Predictor Variable Validation
      #
      # Validates that at least one predictor variable is specified for the Cox model.
      # Accepts either categorical explanatory variables or continuous explanatory variables.
      #
      # Returns: Boolean indicating if predictor variables are specified
      #
      # Checks for the presence of either:
      # - Categorical explanatory variables (explanatory option)
      # - Continuous explanatory variables (contexpl option)
      # At least one type must be specified for multivariable analysis.
      .validatePredictorInputs = function() {
        return(length(self$options$explanatory) > 0 || length(self$options$contexpl) > 0)
      },

      # Standardized Error Message Formatting
      #
      # Creates standardized, user-friendly HTML error messages with consistent styling
      # and optional suggestions for troubleshooting.
      #
      # Parameters:
      #   title - Character string for the error message title
      #   message - Character string for the main error message
      #   suggestions - Optional character string with HTML list items for suggestions
      #
      # Returns: Formatted HTML string for display in the jamovi interface
      #
      # Generates styled HTML error messages with:
      # - Consistent warning color scheme (yellow background, brown text)
      # - Professional typography and spacing
      # - Optional suggestions section for user guidance
      # - Bootstrap-compatible styling for jamovi integration
      .formatErrorMessage = function(title, message, suggestions = NULL) {
        error_html <- paste0(
          "<div style='background-color: #fff3cd; border: 1px solid #ffeaa7; border-radius: 5px; padding: 15px; margin: 10px;'>",
          "<h4 style='color: #856404; margin-top: 0;'>‚ö†Ô∏è ", title, "</h4>",
          "<p style='color: #856404; margin: 10px 0;'>", message, "</p>"
        )

        if (!is.null(suggestions)) {
          error_html <- paste0(error_html,
            "<div style='margin-top: 10px;'>",
            "<strong style='color: #856404;'>Suggestions:</strong>",
            "<ul style='margin: 5px 0; padding-left: 20px; color: #856404;'>",
            suggestions,
            "</ul>",
            "</div>"
          )
        }

        error_html <- paste0(error_html, "</div>")
        return(error_html)
      },

      # Input Sanitization for String Parameters
      #
      # Sanitizes string inputs to prevent XSS attacks and validate format compliance.
      # Removes potentially harmful characters and applies pattern validation.
      #
      # Parameters:
      #   input - Character string to sanitize
      #   default_value - Default value to return if input is invalid/empty
      #   pattern - Optional regex pattern for validation
      #
      # Returns: Sanitized character string or default value if input is invalid
      #
      # Security measures applied:
      # - Removes HTML/XML characters: < > " ' &
      # - Validates against optional regex patterns
      # - Returns safe defaults for empty/null inputs
      # - Prevents code injection in user-provided strings
      #
      # Examples:
      # # Sanitize time intervals input
      # clean_intervals <- private$.sanitizeStringInput("12, 24, 36", "12, 36, 60")
      #
      # # Validate numeric pattern
      # clean_number <- private$.sanitizeStringInput("123", "100", "^[0-9]+$")
      .sanitizeStringInput = function(input, default_value, pattern = NULL) {
        if (is.null(input) || input == "" || is.na(input)) {
          return(default_value)
        }

        # Remove potentially harmful characters
        cleaned <- gsub("[<>\"'&]", "", input)

        # Apply pattern validation if provided
        if (!is.null(pattern) && !grepl(pattern, cleaned)) {
          return(default_value)
        }

        return(cleaned)
      },

      # Performance Monitoring - Start Timer
      #
      # Starts a performance timer for a specific operation to measure execution time.
      # Used for monitoring long-running operations and optimizing performance bottlenecks.
      #
      # Parameters:
      #   operation_name - String identifier for the operation being timed
      #
      # Note: Stores the start time in private$.perf_timers list for later retrieval
      .startPerformanceTimer = function(operation_name) {
        private$.perf_timers <- list()
        private$.perf_timers[[operation_name]] <- Sys.time()
      },

      # Performance Monitoring - Stop Timer
      #
      # Stops a performance timer and calculates elapsed time for the operation.
      # Returns the execution time in seconds for performance analysis.
      #
      # Parameters:
      #   operation_name - String identifier for the operation being timed
      #
      # Returns: Numeric value representing elapsed time in seconds, or NULL if timer not found
      .stopPerformanceTimer = function(operation_name) {
        if (is.null(private$.perf_timers) || is.null(private$.perf_timers[[operation_name]])) {
          return(NULL)
        }

        elapsed <- difftime(Sys.time(), private$.perf_timers[[operation_name]], units = "secs")
        private$.perf_timers[[operation_name]] <- NULL

        return(as.numeric(elapsed))
      },

      # Memory-Efficient Data Processing
      #
      # Processes large datasets in manageable chunks to prevent memory overflow.
      # Automatically handles datasets larger than the specified chunk size by
      # splitting into smaller portions and combining results.
      #
      # Parameters:
      #   data - Data frame to process
      #   chunk_function - Function to apply to each chunk
      #   chunk_size - Maximum number of rows per chunk (default: 1000)
      #
      # Returns: Combined results from all chunks (typically rbind of chunk results)
      .processDataInChunks = function(data, chunk_function, chunk_size = 1000) {
        if (nrow(data) <= chunk_size) {
          return(chunk_function(data))
        }

        # Process data in chunks to manage memory
        n_chunks <- ceiling(nrow(data) / chunk_size)
        results <- list()

        for (i in 1:n_chunks) {
          start_row <- (i - 1) * chunk_size + 1
          end_row <- min(i * chunk_size, nrow(data))
          chunk_data <- data[start_row:end_row, , drop = FALSE]

          results[[i]] <- chunk_function(chunk_data)
        }

        # Combine results (implementation depends on chunk_function output)
        return(do.call(rbind, results))
      },

      # init ----
      .init = function() {
        # Validate inputs using helper functions
        validation <- private$.validateSurvivalInputs()

        # Early exit if essential variables are missing - show welcome message
        if (!validation$valid) {
          # Initialize all outputs to FALSE first
          self$results$text$setVisible(FALSE)
          self$results$text2$setVisible(FALSE)
          self$results$plot$setVisible(FALSE)
          self$results$plot3$setVisible(FALSE)
          self$results$plotKM$setVisible(FALSE)
          self$results$plot_adj$setVisible(FALSE)
          self$results$plot_nomogram$setVisible(FALSE)
          self$results$plot8$setVisible(FALSE)

          # Hide all summary and explanation outputs
          self$results$multivariableCoxSummaryHeading$setVisible(FALSE)
          self$results$multivariableCoxSummary$setVisible(FALSE)
          self$results$personTimeSummaryHeading$setVisible(FALSE)
          self$results$personTimeSummary$setVisible(FALSE)
          self$results$adjustedSurvivalSummaryHeading$setVisible(FALSE)
          self$results$adjustedSurvivalSummary$setVisible(FALSE)
          self$results$nomogramSummaryHeading$setVisible(FALSE)
          self$results$nomogramSummary$setVisible(FALSE)
          self$results$riskScoreSummaryHeading$setVisible(FALSE)
          self$results$riskScoreTable$setVisible(FALSE)
          self$results$riskScoreSummary$setVisible(FALSE)

          # Show welcome/todo message
          self$results$todo$setVisible(TRUE)
          return()
        }

        # Hide todo if we have sufficient variables
        self$results$todo$setVisible(FALSE)

        # Initialize all main outputs to FALSE first
        self$results$text$setVisible(FALSE)
        self$results$text2$setVisible(FALSE)
        self$results$plot$setVisible(FALSE)
        self$results$plot3$setVisible(FALSE)
        self$results$plotKM$setVisible(FALSE)
        self$results$plot_adj$setVisible(FALSE)
        self$results$plot_nomogram$setVisible(FALSE)

        # Initialize all summary outputs and headings to FALSE first
        self$results$multivariableCoxSummaryHeading$setVisible(FALSE)
        self$results$multivariableCoxSummary$setVisible(FALSE)
        self$results$personTimeSummaryHeading$setVisible(FALSE)
        self$results$personTimeSummary$setVisible(FALSE)
        self$results$adjustedSurvivalSummaryHeading$setVisible(FALSE)
        self$results$adjustedSurvivalSummary$setVisible(FALSE)
        self$results$nomogramSummaryHeading$setVisible(FALSE)
        self$results$nomogramSummary$setVisible(FALSE)
        self$results$riskScoreSummaryHeading$setVisible(FALSE)
        self$results$riskScoreTable$setVisible(FALSE)
        self$results$riskScoreSummary$setVisible(FALSE)
        self$results$treeSummaryHeading$setVisible(FALSE)
        self$results$tree_summary$setVisible(FALSE)
        self$results$ml_ensemble_summary$setVisible(FALSE)

        # Initialize all explanation outputs and headings to FALSE first
        self$results$multivariableCoxHeading3$setVisible(FALSE)
        self$results$multivariableCoxExplanation$setVisible(FALSE)
        self$results$adjustedSurvivalExplanation$setVisible(FALSE)
        self$results$riskScoreExplanation$setVisible(FALSE)
        self$results$nomogramExplanation$setVisible(FALSE)
        self$results$personTimeExplanation$setVisible(FALSE)
        self$results$stratifiedAnalysisExplanation$setVisible(FALSE)
        self$results$survivalPlotsHeading3$setVisible(FALSE)
        self$results$survivalPlotsExplanation$setVisible(FALSE)

        # Handle showSummaries visibility
        if (self$options$showSummaries) {
            # Main multivariable cox summary
            self$results$multivariableCoxSummaryHeading$setVisible(TRUE)
            self$results$multivariableCoxSummary$setVisible(TRUE)

            # Conditional summaries - require both showSummaries AND their specific option
            if (self$options$person_time) {
                self$results$personTimeSummaryHeading$setVisible(TRUE)
                self$results$personTimeSummary$setVisible(TRUE)
            }
            if (self$options$ac) {
                self$results$adjustedSurvivalSummaryHeading$setVisible(TRUE)
                self$results$adjustedSurvivalSummary$setVisible(TRUE)
            }
            if (self$options$showNomogram) {
                self$results$nomogramSummaryHeading$setVisible(TRUE)
                self$results$nomogramSummary$setVisible(TRUE)
            }
            if (self$options$calculateRiskScore) {
                self$results$riskScoreSummaryHeading$setVisible(TRUE)
                self$results$riskScoreTable$setVisible(TRUE)
                self$results$riskScoreSummary$setVisible(TRUE)
            }
            if (self$options$use_tree) {
                self$results$treeSummaryHeading$setVisible(TRUE)
                self$results$tree_summary$setVisible(TRUE)
            }
            if (self$options$ml_method == 'ensemble') {
                self$results$ml_ensemble_summary$setVisible(TRUE)
            }
        }

        # Handle showExplanations visibility
        if (self$options$showExplanations) {
            # Main explanation section
            self$results$multivariableCoxHeading3$setVisible(TRUE)
            self$results$multivariableCoxExplanation$setVisible(TRUE)

            # Conditional explanations - require both showExplanations AND their specific option
            if (self$options$ac) {
                self$results$adjustedSurvivalExplanation$setVisible(TRUE)
            }
            if (self$options$calculateRiskScore) {
                self$results$riskScoreExplanation$setVisible(TRUE)
            }
            if (self$options$showNomogram) {
                self$results$nomogramExplanation$setVisible(TRUE)
            }
            if (self$options$person_time) {
                self$results$personTimeExplanation$setVisible(TRUE)
            }
            if (self$options$use_stratify) {
                self$results$stratifiedAnalysisExplanation$setVisible(TRUE)
            }

            # Survival plots explanation requires showExplanations AND at least one plot
            if (self$options$ac || self$options$hr || self$options$km) {
                self$results$survivalPlotsHeading3$setVisible(TRUE)
                self$results$survivalPlotsExplanation$setVisible(TRUE)
            }
        }

        # Handle plot sizing (existing logic preserved)
        explanatory_len <- length(self$options$explanatory)
        contexpl_len <- length(self$options$contexpl)

        if (explanatory_len > 0 || contexpl_len > 0) {
          self$results$plot8$setSize((explanatory_len + contexpl_len) * private$PLOT_WIDTH_FACTOR,
                                     (explanatory_len + contexpl_len) * private$PLOT_HEIGHT_FACTOR)
        } else {
          self$results$plot8$setVisible(FALSE)
        }

        # Note: Main analysis outputs (text, text2, plots) will be set visible in .run() after validation
      }

      # getData ----
      ,
      .getData = function() {
        # Check if data exists and has content
        if (is.null(self$data) || nrow(self$data) == 0) {
          stop('Data contains no (complete) rows')
        }

        # Get the data
        mydata <- self$data


        # Check if data has names
        if (is.null(names(mydata))) {
          stop('Data must have column names')
        }

        # Add row names if missing
        if (is.null(rownames(mydata))) {
          mydata$row_names <- seq_len(nrow(mydata))
        } else {
          mydata$row_names <- rownames(mydata)
        }

        # Get original names
        original_names <- names(mydata)

        # Check if original names exist
        if (length(original_names) == 0) {
          stop(paste0(
            .("Data must have column names."), "\n\n",
            .("Possible solutions:"), "\n",
            "‚Ä¢ ", .("Ensure your dataset has proper column headers"), "\n",
            "‚Ä¢ ", .("Check that the data was imported correctly"), "\n",
            "‚Ä¢ ", .("Verify the data is not empty"), "\n",
            "‚Ä¢ ", .("Column names should describe your variables (e.g., 'Age', 'Survival_Time', 'Event_Status')")
          ))
        }

        # Create labels vector
        labels <- stats::setNames(original_names, original_names)

        # Clean names safely
        mydata_cleaned <- try({
          janitor::clean_names(mydata)
        }, silent = TRUE)

        # mydata <- mydata %>% janitor::clean_names()


        if (inherits(mydata_cleaned, "try-error")) {
          stop(paste0(
            .("Error cleaning variable names."), "\n\n",
            .("Possible solutions:"), "\n",
            "‚Ä¢ ", .("Check for special characters or spaces in column names"), "\n",
            "‚Ä¢ ", .("Ensure column names don't start with numbers"), "\n",
            "‚Ä¢ ", .("Remove any duplicate column names"), "\n",
            "‚Ä¢ ", .("Avoid reserved R keywords as column names (e.g., 'if', 'else', 'for')")
          ))
        }


        # Create corrected labels
        corrected_labels <- stats::setNames(original_names, names(mydata_cleaned))

        # Apply labels
        mydata_labelled <- try({
          labelled::set_variable_labels(.data = mydata_cleaned, .labels = corrected_labels)
        }, silent = TRUE)

        # mydata <- labelled::set_variable_labels(
        #     .data = mydata,
        #     .labels = corrected_labels
        # )


        if (inherits(mydata_labelled, "try-error")) {
          stop(paste0(
            .("Error setting variable labels."), "\n\n",
            .("Possible solutions:"), "\n",
            "‚Ä¢ ", .("Check that all variables have valid names after cleaning"), "\n",
            "‚Ä¢ ", .("Ensure no variables have completely missing data"), "\n",
            "‚Ä¢ ", .("Verify the dataset is not corrupted"), "\n",
            "‚Ä¢ ", .("Try reloading your data file")
          ))
        }


        # Get all labels
        all_labels <- labelled::var_label(mydata_labelled)

        # all_labels <- labelled::var_label(mydata)


        # Get variable names from labels
        mytime <- try({
          names(all_labels)[all_labels == self$options$elapsedtime]
        }, silent = TRUE)

        # mytime <-
        #     names(all_labels)[all_labels == self$options$elapsedtime]

        myoutcome <- try({
          names(all_labels)[all_labels == self$options$outcome]
        }, silent = TRUE)

        # myoutcome <-
        #     names(all_labels)[all_labels == self$options$outcome]


        mydxdate <- try({
          names(all_labels)[all_labels == self$options$dxdate]
        }, silent = TRUE)

        # mydxdate <-
        #     names(all_labels)[all_labels == self$options$dxdate]


        myfudate <- try({
          names(all_labels)[all_labels == self$options$fudate]
        }, silent = TRUE)

        # myfudate <-
        #     names(all_labels)[all_labels == self$options$fudate]



        labels_explanatory <- self$options$explanatory

        myexplanatory <-
          names(all_labels)[match(labels_explanatory, all_labels)]

        labels_contexpl <- self$options$contexpl

        mycontexpl <-
          names(all_labels)[match(labels_contexpl, all_labels)]


        # Get adjexplanatory only if it exists and ac option is TRUE
        adjexplanatory <- NULL
        if (!is.null(self$options$adjexplanatory) &&
            self$options$ac) {
          adjexplanatory <- names(all_labels)[all_labels == self$options$adjexplanatory]
        }


        mystratvar_labelled <- NULL


        if (self$options$use_stratify && !is.null(self$options$stratvar)) {
        # Add this to get stratification variables
        labels_stratvar <- self$options$stratvar
        mystratvar_labelled <- names(all_labels)[match(labels_stratvar, all_labels)]
        }


        # Check if required variables were found with helpful error messages
        if (length(mytime) == 0 && !is.null(self$options$elapsedtime)) {
          stop(paste0(
            .("Could not find the elapsed time variable."), "\n\n",
            .("Possible solutions:"), "\n",
            "‚Ä¢ ", .("Check that the variable name is correct in your dataset"), "\n",
            "‚Ä¢ ", .("Ensure the variable contains numeric time values (days, months, years)"), "\n",
            "‚Ä¢ ", .("Verify there are no special characters in the variable name"), "\n",
            "‚Ä¢ ", .("The time variable should represent time from study entry to event or last follow-up")
          ))
        }
        if (length(myoutcome) == 0 && !is.null(self$options$outcome)) {
          stop(paste0(
            .("Could not find the outcome variable."), "\n\n",
            .("Possible solutions:"), "\n",
            "‚Ä¢ ", .("Check that the variable name is correct in your dataset"), "\n",
            "‚Ä¢ ", .("Ensure the variable is coded as 0/1 or FALSE/TRUE (0=censored, 1=event)"), "\n",
            "‚Ä¢ ", .("Verify there are no missing values in the outcome variable"), "\n",
            "‚Ä¢ ", .("The outcome should indicate whether the event of interest occurred")
          ))
        }

        # Perform comprehensive data validation
        validation_results <- .validateSurvivalData(mydata_labelled, mytime, myoutcome)

        # Handle validation issues and warnings
        if (length(validation_results$issues) > 0) {
          issue_message <- paste0(
            "<div style='background-color: #f8d7da; border: 1px solid #f5c6cb; padding: 15px; border-radius: 5px; margin: 10px 0;'>",
            "<h4 style='color: #721c24; margin-top: 0;'>üö® ", .("Data Validation Issues"), "</h4>",
            "<ul style='margin: 5px 0; padding-left: 20px;'>",
            paste(lapply(validation_results$issues, function(x) paste0("<li>", x, "</li>")), collapse = ""),
            "</ul>",
            "<p><strong>", .("Action Required:"), "</strong> ", .("Please correct these issues before proceeding with analysis."), "</p>",
            "</div>"
          )
          stop(issue_message)
        }

        # Display warnings if any
        if (length(validation_results$warnings) > 0) {
          warning_message <- paste0(
            "<div style='background-color: #fff3cd; border: 1px solid #ffeaa7; padding: 15px; border-radius: 5px; margin: 10px 0;'>",
            "<h4 style='color: #856404; margin-top: 0;'>‚ö†Ô∏è ", .("Data Validation Warnings"), "</h4>",
            "<ul style='margin: 5px 0; padding-left: 20px;'>",
            paste(lapply(validation_results$warnings, function(x) paste0("<li>", x, "</li>")), collapse = ""),
            "</ul>",
            "<p><strong>", .("Note:"), "</strong> ", .("Analysis will proceed, but consider these recommendations for optimal results."), "</p>",
            "</div>"
          )
          # Store warning to display later
          private$.validation_warnings <- warning_message
        }

        # Return results
        return(
          list(
            "mydata_labelled" = mydata_labelled,
            "mytime_labelled" = mytime,
            "myoutcome_labelled" = myoutcome,
            "mydxdate_labelled" = mydxdate,
            "myfudate_labelled" = myfudate,
            "mycontexpl_labelled" = mycontexpl,
            "myexplanatory_labelled" = myexplanatory,
            "adjexplanatory_labelled" = adjexplanatory,
            "mystratvar_labelled" = mystratvar_labelled,
            "validation_warnings" = private$.validation_warnings

          )
        )



      }

      # todo ----
      ,
      .todo = function() {
        # todo ----

        todo <- glue::glue(
          "
                    <br>Welcome to ClinicoPath
                    <br><br>
                        This tool will help you perform a multivariable survival analysis.
                    <br><br>
                        Explanatory variables can be categorical (ordinal or nominal) or continuous.
                    <br><br>
                    Select outcome level from Outcome variable.
                    <br><br>
                    Outcome Level: if patient is dead or event (recurrence) occured. You may also use advanced outcome options depending on your analysis type.
                    <br><br>
                        Survival time should be numeric, continuous, and in months. You may also use dates to calculate survival time in advanced elapsed time options.
                    <br><br>


        Stratification Variables: Use these when the proportional hazards assumption
        is violated for certain variables. The model will create separate baseline
        hazard functions for each level of the stratification variables, but won't
        estimate their direct effects.
        <br><br>
        Consider using stratification when:
        <br>- A variable fails the proportional hazards test
        <br>- You need to control for a variable's effect but don't need to
        estimate its hazard ratio
        <br>- There are natural differences in baseline risk across groups

<br><br>
                        This function uses finalfit, survival, survminer and ggstatsplot packages. Please cite jamovi and the packages as given below.
                    <br><br>
                    "
        )
        # https://finalfit.org/articles/all_tables_examples.html#cox-proportional-hazards-model-survival-time-to-event


        html <- self$results$todo
        html$setContent(todo)
        return()

      }





      # Define Survival Time ----
      ,
      .definemytime = function() {
        ## Read Labelled Data ----

        labelled_data <- private$.getData()

        mydata <- labelled_data$mydata_labelled
        mytime_labelled <- labelled_data$mytime_labelled
        mydxdate_labelled <- labelled_data$mydxdate_labelled
        myfudate_labelled <- labelled_data$myfudate_labelled

        tint <- self$options$tint


        if (!tint) {
          ### Precalculated Time ----

          # Check if time variable is selected
          if (is.null(mytime_labelled) || length(mytime_labelled) == 0) {
            # Return empty data frame with proper structure
            return(data.frame(row_names = character(0), mytime = numeric(0)))
          }

          mydata[["mytime"]] <-
            jmvcore::toNumeric(mydata[[mytime_labelled]])


        } else if (tint) {
          ### Time Interval ----

          dxdate <- mydxdate_labelled
          fudate <- myfudate_labelled
          timetypedata <- self$options$timetypedata


          # Check if input is numeric (Unix epoch) or text (requires parsing)
          is_numeric_dx <- is.numeric(mydata[[dxdate]])
          is_numeric_fu <- is.numeric(mydata[[fudate]])

          if (is_numeric_dx && is_numeric_fu) {
              # Handle numeric Unix epoch input (from DateTime Converter)
              mydata[["start"]] <- as.POSIXct(mydata[[dxdate]], origin="1970-01-01", tz="UTC")
              mydata[["end"]] <- as.POSIXct(mydata[[fudate]], origin="1970-01-01", tz="UTC")
          } else if (!is_numeric_dx && !is_numeric_fu) {
              # Handle text datetime input via lubridate
              lubridate_functions <- list(
                  ymdhms = lubridate::ymd_hms,
                  ymd = lubridate::ymd,
                  ydm = lubridate::ydm,
                  mdy = lubridate::mdy,
                  myd = lubridate::myd,
                  dmy = lubridate::dmy,
                  dym = lubridate::dym
              )

              if (timetypedata %in% names(lubridate_functions)) {
                  func <- lubridate_functions[[timetypedata]]
                  mydata[["start"]] <- func(mydata[[dxdate]])
                  mydata[["end"]] <- func(mydata[[fudate]])
              } else {
                  stop(paste0("Unsupported time type format: ", timetypedata,
                             ". Supported formats are: ", paste(names(lubridate_functions), collapse = ", ")))
              }
          } else {
              # Mixed types error
              stop("Diagnosis date and follow-up date must be in the same format (both numeric or both text)")
          }


          if (sum(!is.na(mydata[["start"]])) == 0 ||
              sum(!is.na(mydata[["end"]])) == 0)  {
            stop(
              paste0(
                "Time difference cannot be calculated. Make sure that time type in variables are correct. Currently it is: ",
                self$options$timetypedata
              )
            )
          }

          timetypeoutput <-
            jmvcore::constructFormula(terms = self$options$timetypeoutput)


          mydata <- mydata %>%
            dplyr::mutate(interval = lubridate::interval(start, end))



          mydata <- mydata %>%
            dplyr::mutate(mytime = lubridate::time_length(interval, timetypeoutput))

        }


        df_time <- mydata %>% jmvcore::select(c("row_names", "mytime"))

        return(df_time)


      }

      # Define Outcome ----
      ,
      .definemyoutcome = function() {
        labelled_data <- private$.getData()

        mydata <- labelled_data$mydata_labelled
        myoutcome_labelled <- labelled_data$myoutcome_labelled


        contin <- c("integer", "numeric", "double")

        outcomeLevel <- self$options$outcomeLevel
        multievent <- self$options$multievent

        # Check if outcome variable is selected
        if (is.null(myoutcome_labelled) || length(myoutcome_labelled) == 0) {
          # Return empty data frame with proper structure
          return(data.frame(row_names = character(0), myoutcome = numeric(0)))
        }

        outcome1 <- mydata[[myoutcome_labelled]]

        if (!multievent) {
          if (inherits(outcome1, contin)) {
            if (!((length(unique(outcome1[!is.na(outcome1)])) == 2) &&
                  (sum(unique(outcome1[!is.na(outcome1)])) == 1))) {
              stop(
                'When using continuous variable as an outcome, it must only contain 1s and 0s. If patient is dead or event (recurrence) occured it is 1. If censored (patient is alive or free of disease) at the last visit it is 0.'
              )

            }

            mydata[["myoutcome"]] <- mydata[[myoutcome_labelled]]
            # mydata[[self$options$outcome]]

          } else if (inherits(outcome1, "factor")) {
            mydata[["myoutcome"]] <-
              ifelse(test = outcome1 == outcomeLevel,
                     yes = 1,
                     no = 0)

          } else {
            stop(
              'When using continuous variable as an outcome, it must only contain 1s and 0s. If patient is dead or event (recurrence) occured it is 1. If censored (patient is alive or free of disease) at the last visit it is 0. If you are using a factor as an outcome, please check the levels and content.'
            )

          }

        } else if (multievent) {
          analysistype <- self$options$analysistype

          dod <- self$options$dod
          dooc <- self$options$dooc
          awd <- self$options$awd
          awod <- self$options$awod

          if (analysistype == 'overall') {
            # Overall ----
            # (Alive) <=> (Dead of Disease & Dead of Other Causes)


            mydata[["myoutcome"]] <- NA_integer_

            mydata[["myoutcome"]][outcome1 == awd] <- 0
            mydata[["myoutcome"]][outcome1 == awod] <- 0
            mydata[["myoutcome"]][outcome1 == dod] <- 1
            mydata[["myoutcome"]][outcome1 == dooc] <- 1



          } else if (analysistype == 'cause') {
            # Cause Specific ----
            # (Alive & Dead of Other Causes) <=> (Dead of Disease)


            mydata[["myoutcome"]] <- NA_integer_

            mydata[["myoutcome"]][outcome1 == awd] <- 0
            mydata[["myoutcome"]][outcome1 == awod] <- 0
            mydata[["myoutcome"]][outcome1 == dod] <- 1
            mydata[["myoutcome"]][outcome1 == dooc] <- 0

          } else if (analysistype == 'compete') {
            # Competing Risks ----
            # Alive <=> Dead of Disease accounting for Dead of Other Causes

            # https://www.emilyzabor.com/tutorials/survival_analysis_in_r_tutorial.html#part_3:_competing_risks


            mydata[["myoutcome"]] <- NA_integer_

            mydata[["myoutcome"]][outcome1 == awd] <- 0
            mydata[["myoutcome"]][outcome1 == awod] <- 0
            mydata[["myoutcome"]][outcome1 == dod] <- 1
            mydata[["myoutcome"]][outcome1 == dooc] <- 2

          }

        }

        df_outcome <- mydata %>% jmvcore::select(c("row_names", "myoutcome"))

        return(df_outcome)

      }


      # Define Factor ----
      ,

      .definemyfactor = function() {
        labelled_data <- private$.getData()

        mydata_labelled <- labelled_data$mydata_labelled
        myexplanatory_labelled <- labelled_data$myexplanatory_labelled
        mycontexpl_labelled <- labelled_data$mycontexpl_labelled
        adjexplanatory_labelled <- labelled_data$adjexplanatory_labelled

        mydata <- mydata_labelled

        df_factor <- mydata %>%
          jmvcore::select(unique(
            c(
              "row_names",
              myexplanatory_labelled,
              adjexplanatory_labelled,
              mycontexpl_labelled
            )
          ))

        return(df_factor)

      }

      # Clean Data ----
      ,
      .cleandata = function() {
        ## Common Definitions ----

        contin <- c("integer", "numeric", "double")

        ## Read Data ----

        labelled_data <- private$.getData()

        mydata_labelled        <- labelled_data$mydata_labelled
        mytime_labelled        <- labelled_data$mytime_labelled
        myoutcome_labelled     <- labelled_data$myoutcome_labelled
        mydxdate_labelled      <- labelled_data$mydxdate_labelled
        myfudate_labelled      <- labelled_data$myfudate_labelled
        myexplanatory_labelled <- labelled_data$myexplanatory_labelled
        mycontexpl_labelled    <- labelled_data$mycontexpl_labelled
        adjexplanatory_labelled <- labelled_data$adjexplanatory_labelled
        mystratvar_labelled <- labelled_data$mystratvar_labelled

        time <- private$.definemytime()
        outcome <- private$.definemyoutcome()
        factor <- private$.definemyfactor()

        ## Clean Data ----
        cleanData <- dplyr::left_join(time, outcome, by = "row_names") %>%
          dplyr::left_join(factor, by = "row_names")

        ## Landmark ----

        # https://www.emilyzabor.com/tutorials/survival_analysis_in_r_tutorial.html#landmark_method

        if (self$options$uselandmark) {
          landmark <- jmvcore::toNumeric(self$options$landmark)

          cleanData <- cleanData %>%
            dplyr::filter(mytime >= landmark) %>%
            dplyr::mutate(mytime = mytime - landmark)
        }

        ## Names cleanData ----

        if (self$options$tint) {
          name1time <- "CalculatedTime"
        }

        if (!self$options$tint &&
            !is.null(self$options$elapsedtime)) {
          name1time <- mytime_labelled
        }

        name2outcome <- myoutcome_labelled

        if (self$options$multievent) {
          name2outcome <- "CalculatedOutcome"
        }

        name3expl <- NULL

        if (!is.null(self$options$explanatory)) {
          name3expl <- myexplanatory_labelled
        }


        name3contexpl <- NULL

        if (!is.null(self$options$contexpl)) {
          name3contexpl <- mycontexpl_labelled
        }

        # Add adjexplanatory name if present
        adjexplanatory_name <- NULL
        if (!is.null(adjexplanatory_labelled)) {
          adjexplanatory_name <- adjexplanatory_labelled
        }


        # naOmit ----

        cleanData <- jmvcore::naOmit(cleanData)




        ## Add Calculated Time to Data ----

        if (self$options$tint &&
            self$options$calculatedtime &&
            self$results$calculatedtime$isNotFilled()) {
          self$results$calculatedtime$setRowNums(cleanData$row_names)
          self$results$calculatedtime$setValues(cleanData$mytime)
        }




        ## Add Redefined Outcome to Data ----

        if (self$options$multievent  &&
            self$options$outcomeredefined &&
            self$results$outcomeredefined$isNotFilled()) {
          self$results$outcomeredefined$setRowNums(cleanData$row_names)
          self$results$outcomeredefined$setValues(cleanData$myoutcome)
        }


        # self$results$mydataview$setContent(
        #   list(
        #     "name1time" = name1time,
        #     "name2outcome" = name2outcome,
        #     "name3contexpl" = name3contexpl,
        #     "name3expl" = name3expl,
        #     "adjexplanatory_name" = adjexplanatory_name,
        #
        #     "cleanData" = cleanData,
        #     "mytime_labelled" = mytime_labelled,
        #     "myoutcome_labelled" = myoutcome_labelled,
        #     "mydxdate_labelled" = mydxdate_labelled,
        #     "myfudate_labelled" = myfudate_labelled,
        #     "myexplanatory_labelled" = myexplanatory_labelled,
        #     "mycontexpl_labelled" = mycontexpl_labelled,
        #     "adjexplanatory_labelled" = adjexplanatory_labelled
        #
        #   )
        # )



        # Return Data ----

        return(
          list(
            "name1time" = name1time,
            "name2outcome" = name2outcome,
            "name3contexpl" = name3contexpl,
            "name3expl" = name3expl,
            "adjexplanatory_name" = adjexplanatory_name,

            "cleanData" = cleanData,
            "mydata_labelled" = mydata_labelled,
            "mytime_labelled" = mytime_labelled,
            "myoutcome_labelled" = myoutcome_labelled,
            "mydxdate_labelled" = mydxdate_labelled,
            "myfudate_labelled" = myfudate_labelled,
            "myexplanatory_labelled" = myexplanatory_labelled,
            "mycontexpl_labelled" = mycontexpl_labelled,
            "adjexplanatory_labelled" = adjexplanatory_labelled,
            "mystratvar_labelled" = mystratvar_labelled

          )
        )

      }



      # run  ----
      ,
      # Modular Run Function Components ----

      # Input Validation and UI Preparation
      #
      # Validates all user inputs and prepares the jamovi interface for analysis.
      # Displays appropriate error messages or welcome content based on validation results.
      #
      # Returns: TRUE if all inputs are valid and analysis can proceed, FALSE otherwise
      #
      # Validation Steps:
      # - Check for required outcome, time, and predictor variables
      # - Validate multievent configuration if selected
      # - Display helpful error messages with suggestions
      # - Show/hide appropriate UI elements
      # - Performance monitoring for validation time
      .validateAndPrepare = function() {
        # Start performance timer
        private$.startPerformanceTimer("validation")

        # Validate inputs using our helper functions
        validation <- private$.validateSurvivalInputs()

        if (!validation$valid) {
          private$.todo()
          self$results$text$setVisible(FALSE)
          self$results$text2$setVisible(FALSE)
          self$results$plot$setVisible(FALSE)
          self$results$plot3$setVisible(FALSE)
          self$results$plot8$setVisible(FALSE)
          self$results$todo$setVisible(TRUE)
          return(FALSE)
        }

        # Additional specific validations for multievent scenarios
        if (self$options$multievent) {
          if (is.null(self$options$dod) && is.null(self$options$dooc)) {
            error_msg <- private$.formatErrorMessage(
              "Multiple Events Configuration Error",
              "When using multiple event levels, you must specify at least one event type (Dead of Disease or Dead of Other Causes).",
              "<li>Select at least one event level from the outcome variable</li><li>Ensure your outcome variable has the appropriate levels</li>"
            )
            self$results$text$setContent(error_msg)
            return(FALSE)
          }
        }

        self$results$todo$setVisible(FALSE)
        self$results$text$setVisible(TRUE)
        self$results$text2$setVisible(TRUE)

        validation_time <- private$.stopPerformanceTimer("validation")
        private$.validation_time <- validation_time

        return(TRUE)
      }

      # Main Analysis Execution
      #
      # Executes the complete survival analysis with performance monitoring.
      # Orchestrates data preparation, survival modeling, and timing collection.
      #
      # Returns: TRUE if analysis completes successfully, NULL on error
      #
      # Features:
      # - Performance monitoring for each analysis phase
      # - Error handling with detailed logging
      # - Data preparation and validation
      # - Main survival analysis execution
      # - Timing collection for optimization
      ,.executeAnalysis = function() {
        # Start performance timer for main analysis
        private$.startPerformanceTimer("analysis")

        tryCatch({
          # Data preparation
          private$.startPerformanceTimer("data_prep")
          cleaneddata <- private$.cleandata()
          data_prep_time <- private$.stopPerformanceTimer("data_prep")

          # Main survival analysis
          private$.startPerformanceTimer("survival_analysis")
          analysis_results <- private$.performSurvivalAnalysis(cleaneddata)
          survival_time <- private$.stopPerformanceTimer("survival_analysis")

          # Machine learning analysis (if requested)
          if (self$options$ml_method != "none") {
            private$.startPerformanceTimer("ml_analysis")
            private$.runMLAnalysis()
            ml_time <- private$.stopPerformanceTimer("ml_analysis")
          } else {
            ml_time <- 0
          }

          # Generate clinical interpretation summary
          private$.generateAndDisplayClinicalSummary(cleaneddata)

          # Store timing information
          private$.analysis_times <- list(
            data_prep = data_prep_time,
            survival_analysis = survival_time,
            ml_analysis = ml_time,
            validation = private$.validation_time
          )

          return(analysis_results)

        }, error = function(e) {
          error_msg <- private$.formatErrorMessage(
            .("Survival Analysis Error"),
            paste(.("An error occurred during the survival analysis:"), e$message),
            paste0(
              "<li>", .("Check your data for missing or invalid values in time and outcome variables"), "</li>",
              "<li>", .("Ensure the time variable contains positive numeric values"), "</li>",
              "<li>", .("Verify the outcome variable is binary (0/1 or FALSE/TRUE)"), "</li>",
              "<li>", .("Check that you have sufficient events (at least 10 recommended)"), "</li>",
              "<li>", .("Ensure explanatory variables have appropriate data types"), "</li>",
              "<li>", .("Try running the analysis with fewer variables"), "</li>",
              "<li>", .("Consider checking for outliers or extreme values"), "</li>"
            )
          )
          self$results$text$setContent(error_msg)
          return(NULL)
        })
      },

      # Core Survival Analysis Implementation
      #
      # Performs the main survival analysis including Cox regression and all
      # optional analysis modules based on user selections.
      #
      # Parameters:
      #   cleaneddata - Processed and validated dataset
      #
      # Returns: TRUE if analysis completes successfully
      #
      # Analysis Components:
      # - Core Cox proportional hazards modeling
      # - Person-time analysis (if requested)
      # - Risk score calculation and stratification (if requested)
      # - Adjusted survival curves (if requested)
      # - Nomogram generation (if requested)
      # - Decision tree analysis (if requested)
      #
      # Each component is conditionally executed based on user options
      .performSurvivalAnalysis = function(cleaneddata) {

        # Stop if Empty Data
        if (nrow(self$data) == 0) {
          stop('Data contains no (complete) rows')
        }

        # Execute the main analysis components
        private$.checkpoint()
        private$.final_fit()

        # Additional analysis modules
        if (self$options$person_time) {
          private$.calculate_persontime()
        }

        if (self$options$calculateRiskScore) {
          private$.calculate_riskscore()
        }

        if (self$options$ac) {
          private$.calculate_adjustedstats()
        }

        if (self$options$showNomogram) {
          private$.calculate_nomogram()
        }

        # AFT Model Analysis
        if (self$options$use_aft) {
          private$.calculate_aft()
        }

        # EXPERIMENTAL:         if (self$options$use_tree) {
        # EXPERIMENTAL:           private$.calculate_survivaldecisiontree()
        # EXPERIMENTAL:         }

        # Return success indicator
        return(TRUE)
      },

      .run = function() {
        # Modular execution using helper functions
        if (!private$.validateAndPrepare()) {
          return()
        }

        # Execute main analysis
        analysis_results <- private$.executeAnalysis()
        if (is.null(analysis_results)) {
          return()
        }

        # Analysis completed successfully
        return(TRUE)
      }

      # cox model  ----
      ,
      .cox_model = function() {
        cleaneddata <- private$.cleandata()

        name1time <- cleaneddata$name1time
        name2outcome <- cleaneddata$name2outcome
        name3contexpl <- cleaneddata$name3contexpl
        name3expl <- cleaneddata$name3expl
        adjexplanatory_name <- cleaneddata$adjexplanatory_name

        mydata <- cleanData <- cleaneddata$cleanData

        mytime_labelled <- cleaneddata$mytime_labelled
        myoutcome_labelled <- cleaneddata$myoutcome_labelled
        mydxdate_labelled <- cleaneddata$mydxdate_labelled
        myfudate_labelled <- cleaneddata$myfudate_labelled
        myexplanatory_labelled <- cleaneddata$myexplanatory_labelled
        mycontexpl_labelled <- cleaneddata$mycontexpl_labelled
        adjexplanatory_labelled <- cleaneddata$adjexplanatory_labelled
        mystratvar_labelled <- cleaneddata$mystratvar_labelled



        # Add stratification variables
        mystratvar <- NULL

        if (self$options$use_stratify && !is.null(self$options$stratvar)) {
          mystratvar <- as.vector(cleaneddata$mystratvar_labelled)
          if (length(mystratvar) > 0) {
            # FIXED: Each strata variable should be in its own strata() function
            mystratvar <- paste(sprintf("survival::strata(%s)", mystratvar), collapse = " + ")

            # # Only create strata terms if we have variables
            # mystratvar <- paste0("survival::strata(", paste(mystratvar, collapse = "+"), ")")
          }

        }



        myexplanatory <- NULL
        if (!is.null(self$options$explanatory)) {
          myexplanatory <- as.vector(myexplanatory_labelled)
        }

        mycontexpl <- NULL
        if (!is.null(self$options$contexpl)) {
          mycontexpl <- as.vector(mycontexpl_labelled)
        }

        # Build formula parts
        formula_parts <- c(myexplanatory, mycontexpl)

        # Add strata term only if it exists
        if (!is.null(mystratvar) && mystratvar != "") {
          formula_parts <- c(formula_parts, mystratvar)
        }
        # formula2 <- c(myexplanatory, mycontexpl, mystratvar)



        # Build Cox regression formula using consolidated function
        coxformula <- .buildSurvivalFormula(
          time_var = mytime,
          outcome_var = myoutcome,
          predictors = formula_parts,
          survival_type = "standard",
          strata_vars = if (!is.null(mystratvar) && mystratvar != "") mystratvar else NULL
        )


        # Remove any rows with NA in stratification variables
        # if (self$options$use_stratify && !is.null(self$options$stratvar)) {
        #   complete_cases <- complete.cases(mydata[, mystratvar])
        #   mydata <- mydata[complete_cases, ]
        # }



        # self$results$mydataview_cox$setContent(
        #   list(
        #     mydata = head(mydata, n = 30),
        #     coxformula = coxformula
        #   )
        # )

        # Add checkpoint before the expensive Cox model fitting
        private$.checkpoint()

        # Get all labels for variable name mapping
        mydata_labelled <- cleaneddata$mydata_labelled
        all_labels <- labelled::var_label(mydata_labelled)

        # Handle Time-Dependent Covariates
        # EXPERIMENTAL:         if (self$options$use_time_dependent && !is.null(self$options$time_dep_vars)) {
        # EXPERIMENTAL: 
        # EXPERIMENTAL:           # Get time-dependent variable names
        # EXPERIMENTAL:           time_dep_vars <- names(all_labels)[match(self$options$time_dep_vars, all_labels)]
        # EXPERIMENTAL: 
        # EXPERIMENTAL:           if (self$options$td_format == "wide") {
        # EXPERIMENTAL:             # Handle wide format data - convert to long format
        # EXPERIMENTAL:             mydata <- private$.convertWideToLong(mydata, time_dep_vars, all_labels)
        # EXPERIMENTAL: 
        # EXPERIMENTAL:             # Update formula for time-dependent covariates (long format)
        # EXPERIMENTAL:             td_predictors <- c(formula_parts, time_dep_vars)
        # EXPERIMENTAL:             coxformula <- .buildSurvivalFormula(
        # EXPERIMENTAL:               time_var = "tstart",
        # EXPERIMENTAL:               outcome_var = myoutcome,
        # EXPERIMENTAL:               predictors = td_predictors,
        # EXPERIMENTAL:               survival_type = "counting",
        # EXPERIMENTAL:               start_var = "tstart",
        # EXPERIMENTAL:               stop_var = "tstop"
        # EXPERIMENTAL:             )
        # EXPERIMENTAL: 
        # EXPERIMENTAL:           } else if (self$options$td_format == "long") {
        # EXPERIMENTAL:             # Handle long format data
        # EXPERIMENTAL:             if (!is.null(self$options$start_time_var) && !is.null(self$options$stop_time_var)) {
        # EXPERIMENTAL:               start_time_var <- names(all_labels)[all_labels == self$options$start_time_var]
        # EXPERIMENTAL:               stop_time_var <- names(all_labels)[all_labels == self$options$stop_time_var]
        # EXPERIMENTAL: 
        # EXPERIMENTAL:               # Update formula for time-dependent covariates
        # EXPERIMENTAL:               long_predictors <- c(formula_parts, time_dep_vars)
        # EXPERIMENTAL:               coxformula <- .buildSurvivalFormula(
        # EXPERIMENTAL:                 time_var = start_time_var,
        # EXPERIMENTAL:                 outcome_var = myoutcome,
        # EXPERIMENTAL:                 predictors = long_predictors,
        # EXPERIMENTAL:                 survival_type = "counting",
        # EXPERIMENTAL:                 start_var = start_time_var,
        # EXPERIMENTAL:                 stop_var = stop_time_var
        # EXPERIMENTAL:               )
        # EXPERIMENTAL:             }
        # EXPERIMENTAL:           }
        # EXPERIMENTAL:         }
        # EXPERIMENTAL: 
        # EXPERIMENTAL:         # Handle Frailty Models
        # EXPERIMENTAL:         if (self$options$use_frailty && !is.null(self$options$frailty_var)) {
        # EXPERIMENTAL:           frailty_var <- names(all_labels)[all_labels == self$options$frailty_var]
        # EXPERIMENTAL: 
        # EXPERIMENTAL:           # Add frailty term based on distribution
        # EXPERIMENTAL:           frailty_term <- switch(self$options$frailty_distribution,
        # EXPERIMENTAL:             "gamma" = paste0("frailty(", frailty_var, ", distribution='gamma')"),
        # EXPERIMENTAL:             "gaussian" = paste0("frailty(", frailty_var, ", distribution='gaussian')"),
        # EXPERIMENTAL:             "logt" = paste0("frailty(", frailty_var, ", distribution='logt')")
        # EXPERIMENTAL:           )
        # EXPERIMENTAL: 
        # EXPERIMENTAL:           formula_parts <- c(formula_parts, frailty_term)
        # EXPERIMENTAL:           RHT <- paste(formula_parts, collapse = " + ")
        # EXPERIMENTAL:           coxformula <- as.formula(paste0(LHT, " ~ ", RHT))
        # EXPERIMENTAL:         }
        # EXPERIMENTAL: 
        # EXPERIMENTAL:         # Handle Splines for Non-Proportional Hazards
        # EXPERIMENTAL:         if (self$options$use_splines && !is.null(self$options$spline_vars)) {
        # EXPERIMENTAL:           spline_vars <- names(all_labels)[match(self$options$spline_vars, all_labels)]
        # EXPERIMENTAL: 
        # EXPERIMENTAL:           # Create spline terms
        # EXPERIMENTAL:           for (var in spline_vars) {
        # EXPERIMENTAL:             spline_term <- switch(self$options$spline_type,
        # EXPERIMENTAL:               "pspline" = paste0("pspline(", var, ", df=", self$options$spline_df, ")"),
        # EXPERIMENTAL:               "ns" = paste0("ns(", var, ", df=", self$options$spline_df, ")"),
        # EXPERIMENTAL:               "bs" = paste0("bs(", var, ", df=", self$options$spline_df, ")")
        # EXPERIMENTAL:             )
        # EXPERIMENTAL: 
        # EXPERIMENTAL:             # Replace the linear term with spline term
        # EXPERIMENTAL:             formula_parts <- formula_parts[formula_parts != var]
        # EXPERIMENTAL:             formula_parts <- c(formula_parts, spline_term)
        # EXPERIMENTAL:           }
        # EXPERIMENTAL: 
        # EXPERIMENTAL:           RHT <- paste(formula_parts, collapse = " + ")
        # EXPERIMENTAL:           coxformula <- as.formula(paste0(LHT, " ~ ", RHT))
        # EXPERIMENTAL: 
        # EXPERIMENTAL:           # Load splines package if needed
        # EXPERIMENTAL:           if (self$options$spline_type %in% c("ns", "bs")) {
        # EXPERIMENTAL:             requireNamespace("splines", quietly = TRUE)
        # EXPERIMENTAL:           }
        # EXPERIMENTAL:         }

        cox_model <- survival::coxph(coxformula, data = mydata)


        return(cox_model)

      }



      ,
      # Person-Time Analysis Function ----
      .personTimeAnalysis = function() {
        # Check if person_time option is enabled
        if (!self$options$person_time) {
          return()
        }

        cleaneddata <- private$.cleandata()


        # Extract data
        # mytime <- cleaneddata$mytime_labelled
        # myoutcome <- cleaneddata$myoutcome_labelled
        mydata <- cleaneddata$cleanData


        # Ensure time is numeric
        mydata[["mytime"]] <- jmvcore::toNumeric(mydata[["mytime"]])

        # Get total observed time
        total_time <- sum(mydata[["mytime"]])

        # Get total events
        total_events <- sum(mydata[["myoutcome"]])

        # Get time unit
        time_unit <- self$options$timetypeoutput

        # Get rate multiplier
        rate_multiplier <- self$options$rate_multiplier

        # Calculate overall incidence rate
        overall_rate <- (total_events / total_time) * rate_multiplier

        # Calculate confidence intervals using Poisson exact method
        ci_lower <- (stats::qchisq(0.025, 2*total_events) / 2) / total_time * rate_multiplier
        ci_upper <- (stats::qchisq(0.975, 2*(total_events + 1)) / 2) / total_time * rate_multiplier



        # self$results$mydataview_personTimeAnalysis$setContent(
        #   list(
        #     mydata = head(mydata, n = 10),
        #     # mytime = mytime,
        #     # myoutcome = myoutcome,
        #     total_time = total_time,
        #     total_events = total_events,
        #     overall_rate = overall_rate,
        #     ci_lower = ci_lower,
        #     ci_upper = ci_upper
        #   )
        # )




        # Add to personTimeTable - first the overall row
        self$results$personTimeTable$addRow(rowKey=1, values=list(
          interval=paste0("Overall (0-max)"),
          events=total_events,
          person_time=round(total_time, 2),
          rate=round(overall_rate, 2),
          rate_ci_lower=round(ci_lower, 2),
          rate_ci_upper=round(ci_upper, 2)
        ))

        # Parse time intervals for stratified analysis
        time_intervals <- as.numeric(unlist(strsplit(self$options$time_intervals, ",")))
        time_intervals <- sort(unique(time_intervals))

        if (length(time_intervals) > 0) {
          # Create time intervals
          breaks <- c(0, time_intervals, max(mydata[["mytime"]]) * 1.1)

          # Loop through intervals
          for (i in 1:(length(breaks)-1)) {
            start_time <- breaks[i]
            end_time <- breaks[i+1]

            # Add checkpoint for responsiveness
            if (i %% 5 == 0) {
              private$.checkpoint()
            }

            # Filter data for this interval
            if (i == 1) {
              # For first interval, include patients from the beginning
              interval_data <- mydata
              # But truncate follow-up time to the interval end
              follow_up_times <- pmin(mydata[["mytime"]], end_time)
              # Count only events that occurred within this interval
              events_in_interval <- sum(mydata[["myoutcome"]] == 1 & mydata[["mytime"]] <= end_time)
            } else {
              # For later intervals, include only patients who survived past the previous cutpoint
              survivors <- mydata[["mytime"]] > start_time
              interval_data <- mydata[survivors, ]

              if (nrow(interval_data) == 0) {
                # Skip if no patients in this interval
                next
              }

              # Adjust entry time and follow-up time
              adjusted_entry_time <- rep(start_time, nrow(interval_data))
              adjusted_exit_time <- pmin(interval_data[["mytime"]], end_time)
              follow_up_times <- adjusted_exit_time - adjusted_entry_time

              # Count only events that occurred within this interval
              events_in_interval <- sum(interval_data[["myoutcome"]] == 1 &
                                          interval_data[["mytime"]] <= end_time &
                                          interval_data[["mytime"]] > start_time)
            }

            # Sum person-time in this interval
            person_time_in_interval <- sum(follow_up_times)

            # Calculate interval incidence rate
            if (person_time_in_interval > 0) {
              interval_rate <- (events_in_interval / person_time_in_interval) * rate_multiplier

              # Calculate confidence intervals
              if (events_in_interval > 0) {
                interval_ci_lower <- (stats::qchisq(0.025, 2*events_in_interval) / 2) / person_time_in_interval * rate_multiplier
                interval_ci_upper <- (stats::qchisq(0.975, 2*(events_in_interval + 1)) / 2) / person_time_in_interval * rate_multiplier
              } else {
                interval_ci_lower <- 0
                interval_ci_upper <- (stats::qchisq(0.975, 2) / 2) / person_time_in_interval * rate_multiplier
              }

              # Add to personTimeTable
              self$results$personTimeTable$addRow(rowKey=i+1, values=list(
                interval=paste0(start_time, "-", end_time),
                events=events_in_interval,
                person_time=round(person_time_in_interval, 2),
                rate=round(interval_rate, 2),
                rate_ci_lower=round(interval_ci_lower, 2),
                rate_ci_upper=round(interval_ci_upper, 2)
              ))
            }
          }
        }

        # Create summary text with interpretation
        summary_html <- glue::glue("
<h4>Person-Time Analysis Summary</h4>
<p>Total follow-up time: <b>{round(total_time, 1)} {time_unit}</b></p>
<p>Number of events: <b>{total_events}</b></p>
<p>Overall incidence rate: <b>{round(overall_rate, 2)}</b> per {rate_multiplier} {time_unit} [95% CI: {round(ci_lower, 2)}-{round(ci_upper, 2)}]</p>
<p>This represents the rate at which events occurred in your study population. The incidence rate is calculated as the number of events divided by the total person-time at risk.</p>
")

        self$results$personTimeSummary$setContent(summary_html)
      }







      ,
      # Nomogram ----

      .nomogram = function(cox_model) {

        if (!self$options$showNomogram) {
          return()
        }

        private$.checkpoint()

        # Get cleaned data
        cleaneddata <- private$.cleandata()
        mydata <- cleaneddata$cleanData
        myexplanatory_labelled <- cleaneddata$myexplanatory_labelled
        mycontexpl_labelled <- cleaneddata$mycontexpl_labelled
        mystratvar_labelled <- cleaneddata$mystratvar_labelled

        # Combine variables
        var_names <- c(myexplanatory_labelled, mycontexpl_labelled)

        # Remove stratification variables if needed
        if (self$options$use_stratify && !is.null(self$options$stratvar)) {
          var_names <- var_names[!var_names %in% mystratvar_labelled]
        }

        # First create datadist object
        dd <- rms::datadist(mydata[, var_names])

        # Handle limits for continuous variables properly
        for(var in var_names) {
          if(is.numeric(mydata[[var]])) {
            # Get required dimensions
            needed_cols <- ncol(dd$limits)

            # Calculate basic limits
            basic_limits <- c(
              quantile(mydata[[var]], 0.1, na.rm=TRUE),  # Low
              median(mydata[[var]], na.rm=TRUE),         # Median
              quantile(mydata[[var]], 0.9, na.rm=TRUE)   # High
            )

            # Create full limits vector of correct length
            full_limits <- numeric(needed_cols)
            full_limits[1:3] <- basic_limits  # First 3 are our calculated limits

            if(needed_cols > 3) {
              # Fill remaining positions with median value
              full_limits[4:needed_cols] <- basic_limits[2]
            }

            # Assign to datadist object
            dd$limits[var,] <- full_limits
          }
        }

        # Set datadist globally
        options(datadist = dd)

        # Create formula and fit model using consolidated function
        coxformula <- .buildSurvivalFormula(
          time_var = "mytime",
          outcome_var = "myoutcome",
          predictors = var_names,
          survival_type = "standard"
        )

        # Fit the model
        f <- rms::cph(formula = coxformula,
                      data = mydata,
                      x = TRUE,
                      y = TRUE,
                      surv = TRUE)

        # Get prediction timepoints
        pred_times <- as.numeric(unlist(strsplit(self$options$cutp, ",")))
        if(length(pred_times) == 0) pred_times <- c(12, 36, 60)

        # Add checkpoint before creating nomogram
        private$.checkpoint()

        # Create nomogram
        nom <- try({
          base_surv <- survival::survfit(cox_model)
          surv_at_time <- summary(base_surv, times = pred_times[1])$surv[1]

          rms::nomogram(f,
                        fun = function(lp) {
                          1 - surv_at_time^exp(lp - mean(cox_model$linear.predictors))
                        },
                        funlabel = paste("Predicted", pred_times[1], "month risk"),
                        fun.at = seq(0.1, 0.9, by = 0.1))
        })


        # private$.nom_object <- nom

        # Store results
        if (!inherits(nom, "try-error")) {
          private$.nom_object <- nom

          # Create the nomogram points table
          html_display <- private$.create_nomogram_display(nom)

          # mydataview_nomogram
          cox_summary <- cox_model$coefficient
          modelSummary <- summary(cox_model)

          # self$results$mydataview_nomogram$setContent(
          #   list(
          #     cox_model = cox_model,
          #     modelSummary = modelSummary,
          #     coef_table = modelSummary$coefficients,
          #     conf_table = modelSummary$conf.int,
          #     cox_summary = cox_summary,
          #     dd = dd,
          #     f = f,
          #     pred_times = pred_times,
          #     nomogram = if(!inherits(nom, "try-error")) nom else NULL,
          #     error = if(inherits(nom, "try-error")) attr(nom, "condition") else NULL,
          #     html_display = if(exists(html_display)) html_display else NULL
          #
          #   )
          # )

          self$results$nomogram_display$setContent(html_display)

          }





        }






      ,
      # Plotting function
      .plot_nomogram = function(image, ggtheme, theme, ...) {
        if(is.null(private$.nom_object)) {
          return(FALSE)
        }

        par(mar = c(4, 4, 2, 2))
        plot(private$.nom_object)
        return(TRUE)
      }


      ,

      .create_nomogram_display = function(nom) {
        if(is.null(private$.nom_object)) {
          return(FALSE)
        }

        # Capture the nomogram output
        nom_output <- capture.output(print(nom))

        # Extract technical details
        tech_details <- c()
        i <- 1
        while(i <= length(nom_output) && !grepl("Points$", nom_output[i])) {
          if(nzchar(nom_output[i])) {
            tech_details <- c(tech_details, nom_output[i])
          }
          i <- i + 1
        }

        # Initialize data structures
        sections <- list()
        current_section <- NULL
        current_lines <- character(0)
        risk_table <- NULL

        # Process each line
        while(i <= length(nom_output)) {
          line <- nom_output[i]

          # Check for new section or risk table
          if(grepl("Total Points Predicted", line)) {
            # We've hit the risk table - save current section and start collecting risk data
            if(!is.null(current_section)) {
              sections[[current_section]] <- current_lines
            }
            risk_table <- c(line)  # Start risk table with header
            while(i < length(nom_output) && nzchar(trimws(nom_output[i + 1]))) {
              i <- i + 1
              risk_table <- c(risk_table, nom_output[i])
            }
            current_section <- NULL
            current_lines <- character(0)
          } else if(grepl("Points$", line) && !grepl("Total Points", line)) {
            # New variable section
            if(!is.null(current_section)) {
              sections[[current_section]] <- current_lines
            }
            current_section <- trimws(sub("Points$", "", line))
            current_lines <- character(0)
          } else if(nzchar(trimws(line))) {
            current_lines <- c(current_lines, line)
          }
          i <- i + 1
        }

        # Add final section if exists
        if(!is.null(current_section) && length(current_lines) > 0) {
          sections[[current_section]] <- current_lines
        }

        # Create HTML content
        html_content <- paste0('
    <style>
        .nomogram-container {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            max-width: 800px;
            margin: 20px auto;
            padding: 20px;
            background-color: #fff;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            border-radius: 8px;
        }
        .tech-details {
            font-family: "Roboto Mono", monospace;
            background-color: #f8f9fa;
            padding: 15px;
            border-radius: 4px;
            margin: 15px 0;
            color: #666;
        }
        .instructions {
            background-color: #e8f5e9;
            padding: 20px;
            margin: 20px 0;
            border-radius: 8px;
        }
        .inputs-section {
            margin-top: 30px;
            border: 1px solid #e9ecef;
            border-radius: 8px;
            padding: 20px;
        }
        .variable-section {
            margin: 15px 0;
            padding: 15px;
            background-color: #f8f9fa;
            border-left: 4px solid #2196f3;
            border-radius: 4px;
        }
        .section-title {
            font-size: 1.2em;
            font-weight: 600;
            color: #2c3e50;
            margin-bottom: 10px;
        }
        .values {
            font-family: "Roboto Mono", monospace;
            white-space: pre-wrap;
            line-height: 1.5;
            color: #34495e;
            padding-left: 20px;
        }
        .outputs-section {
            margin-top: 30px;
            background-color: #fff3e0;
            border: 1px solid #ffe0b2;
            border-radius: 8px;
            padding: 20px;
        }
        .prediction-table {
            width: 100%;
            margin-top: 15px;
            border-collapse: separate;
            border-spacing: 0;
            font-family: "Roboto Mono", monospace;
        }
        .prediction-table th, .prediction-table td {
            padding: 8px 12px;
            text-align: center;
            border-bottom: 1px solid #ffe0b2;
        }
        .prediction-table th {
            background-color: #fff3e0;
            font-weight: 600;
        }
        .notes {
            background-color: #fffde7;
            padding: 15px;
            margin-top: 20px;
            border-radius: 4px;
        }
    </style>
    <div class="nomogram-container">
        <h2>Nomogram Scoring Guide</h2>

        <div class="tech-details">
            ', paste(tech_details, collapse="<br>"), '
        </div>

        <div class="instructions">
            <h3>How to Use This Nomogram:</h3>
            <ol>
                <li>For each variable below, find your patient\'s value</li>
                <li>Read across to the Points scale to determine points for that variable</li>
                <li>Add up total points from all variables</li>
                <li>Use total points to find predicted risk in the Risk Prediction section</li>
            </ol>
        </div>

        <div class="inputs-section">
            <h3>Input Variables</h3>')

        # Add variable sections
        for(section_name in names(sections)) {
          html_content <- paste0(html_content, '
            <div class="variable-section">
                <div class="section-title">', section_name, '</div>
                <div class="values">',
                                 paste(sections[[section_name]], collapse="<br>"),
                                 '</div>
            </div>')
        }

        # Add risk prediction section with formatted table
        html_content <- paste0(html_content, '
        </div>

        <div class="outputs-section">
            <h3>Risk Prediction</h3>
            <div class="section-title">Points to Risk Conversion</div>
            <table class="prediction-table">
                <tr>
                    <th>Total Points</th>
                    <th>Predicted 12-month Risk</th>
                </tr>')

        # Format risk table into two columns
        if(!is.null(risk_table)) {
          # Skip the header line
          risk_lines <- risk_table[-1]
          for(line in risk_lines) {
            values <- strsplit(trimws(line), "\\s+")[[1]]
            if(length(values) == 2) {
              html_content <- paste0(html_content, '
                <tr>
                    <td>', values[1], '</td>
                    <td>', values[2], '</td>
                </tr>')
            }
          }
        }

        html_content <- paste0(html_content, '
            </table>
        </div>

        <div class="notes">
            <h3>Important Notes:</h3>
            <ul>
                <li>For continuous variables, interpolate between given values</li>
                <li>For categorical variables, use exact points shown</li>
                <li>The predicted risk is based on total points from all variables</li>
                <li>Risk predictions are estimates and should be used in conjunction with clinical judgment</li>
            </ul>
        </div>
    </div>')

        return(html_content)
      }


      # coxph Proportional Hazards Assumption  ----
      ,
      .cox_ph = function(cox_model) {
        # cleaneddata <- private$.cleandata()
        #
        # name1time <- cleaneddata$name1time
        # name2outcome <- cleaneddata$name2outcome
        # name3contexpl <- cleaneddata$name3contexpl
        # name3expl <- cleaneddata$name3expl
        # adjexplanatory_name <- cleaneddata$adjexplanatory_name
        #
        # mydata <- cleanData <- cleaneddata$cleanData
        #
        # mytime_labelled <- cleaneddata$mytime_labelled
        # myoutcome_labelled <- cleaneddata$myoutcome_labelled
        # mydxdate_labelled <- cleaneddata$mydxdate_labelled
        # myfudate_labelled <- cleaneddata$myfudate_labelled
        # myexplanatory_labelled <- cleaneddata$myexplanatory_labelled
        # mycontexpl_labelled <- cleaneddata$mycontexpl_labelled
        # adjexplanatory_labelled <- cleaneddata$adjexplanatory_labelled
        #
        #
        # cox_model <- private$.cox_model()

        private$.checkpoint()

        zph <- survival::cox.zph(cox_model)




        # Add suggestions for stratification
        significant_violations <- which(zph$table[,"p"] < 0.05)
        if (length(significant_violations) > 0) {
          violation_vars <- rownames(zph$table)[significant_violations]
          suggestion <- glue::glue(
            "<br><br>Note: The proportional hazards assumption appears to be
            violated for: {paste(violation_vars, collapse=', ')}.
            Consider using these as stratification variables instead of
            covariates."
          )

          self$results$cox_ph$setContent(
            paste(print(zph), suggestion)
          )
        }



        # Display test results
        self$results$cox_ph$setContent(print(zph))






        # Only create plots if there are variables to plot
        if (!is.null(zph$y)) {
          # Pass zph object to plot function
          image8 <- self$results$plot8
          image8$setState(zph)
        } else {
          # If no variables to plot, hide the plot
          self$results$plot8$setVisible(FALSE)
        }

      }




      # hr_plot ----
      ,
      .plot = function(image, ggtheme, theme, ...) {
        if (!self$options$hr) {
          return()
        }

        if (!(self$options$sty == "t1")) {
          return()
        }

        plotData <- image$state

        if (is.null(plotData)) {
          return()
        }

        name1time <- plotData$name1time
        name2outcome <- plotData$name2outcome
        name3contexpl <- plotData$name3contexpl
        name3expl <- plotData$name3expl

        mydata <- cleanData <- plotData$cleanData

        mytime_labelled <- plotData$mytime_labelled
        myoutcome_labelled <- plotData$myoutcome_labelled
        mydxdate_labelled <- plotData$mydxdate_labelled
        myfudate_labelled <- plotData$myfudate_labelled
        myexplanatory_labelled <- plotData$myexplanatory_labelled
        mycontexpl_labelled <- plotData$mycontexpl_labelled
        mystratvar_labelled <- plotData$mystratvar_labelled


        ### prepare formula ----

        myexplanatory <- NULL
        if (!is.null(self$options$explanatory)) {
          myexplanatory <- as.vector(myexplanatory_labelled)
        }

        mycontexpl <- NULL
        if (!is.null(self$options$contexpl)) {
          mycontexpl <- as.vector(mycontexpl_labelled)
        }

        formula2 <- c(myexplanatory, mycontexpl)


        # Remove stratification variables from the finalfit output
        if (self$options$use_stratify && !is.null(self$options$stratvar)) {
          # Remove stratified variables from the display
          formula2 <- formula2[!formula2 %in% mystratvar_labelled]
        }




        myformula <-
          paste0('Surv( ', .escapeVariableNames("mytime"), ', ', .escapeVariableNames("myoutcome"), ' )')


        # hr_plot ----
        # https://finalfit.org/reference/hr_plot.html

        plot <-
          finalfit::hr_plot(
            .data = mydata,
            dependent = myformula,
            explanatory = formula2,
            dependent_label = "Survival",
            table_text_size = 4,
            title_text_size = 14,
            plot_opts = list(
              ggplot2::xlab("HR, 95% CI"),
              ggplot2::theme(axis.title =
                               ggplot2::element_text(size = 12))
            )
          )


        # print plot ----

        print(plot)
        TRUE

      }






      # Forest plot ----
      ,
      .plot3 = function(image3, ggtheme, theme, ...) {
        if (!self$options$hr) {
          return()
        }

        if (!(self$options$sty == "t3")) {
          return()
        }

        plotData <- image3$state

        if (is.null(plotData)) {
          return()
        }

        name1time <- plotData$name1time
        name2outcome <- plotData$name2outcome
        name3contexpl <- plotData$name3contexpl
        name3expl <- plotData$name3expl

        mydata <- cleanData <- plotData$cleanData

        mytime_labelled <- plotData$mytime_labelled
        myoutcome_labelled <- plotData$myoutcome_labelled
        mydxdate_labelled <- plotData$mydxdate_labelled
        myfudate_labelled <- plotData$myfudate_labelled
        myexplanatory_labelled <- plotData$myexplanatory_labelled
        mycontexpl_labelled <- plotData$mycontexpl_labelled
        mystratvar_labelled <- plotData$mystratvar_labelled


        ### prepare formula ----

        myexplanatory <- NULL
        if (!is.null(self$options$explanatory)) {
          myexplanatory <- as.vector(myexplanatory_labelled)
        }

        mycontexpl <- NULL
        if (!is.null(self$options$contexpl)) {
          mycontexpl <- as.vector(mycontexpl_labelled)
        }

        formula2 <- c(myexplanatory, mycontexpl)


        # Remove stratification variables from the finalfit output
        if (self$options$use_stratify && !is.null(self$options$stratvar)) {
          # Remove stratified variables from the display
          formula2 <- formula2[!formula2 %in% mystratvar_labelled]
        }


        myformula <- .buildSurvivalFormula(
          time_var = "mytime",
          outcome_var = "myoutcome",
          predictors = formula2,
          survival_type = "standard"
        )

        mod <-
          survival::coxph(formula = myformula, data = mydata)


        # ggforest ----

        plot3 <- survminer::ggforest(model = mod, data = mydata)


        # print plot ----

        print(plot3)
        TRUE

      }


      # cox.zph plot8 ----
      ,
      .plot8 = function(image8, ggtheme, theme, ...) {
        if (!self$options$ph_cox)
          return()

        zph <- image8$state

        if (is.null(zph)) {
          return()
        }

        # Check if there are variables to plot
        if (is.null(zph$y)) {
          return()
        }

        # Create plot using survminer
        plot8 <- survminer::ggcoxzph(zph)

        print(plot8)
        TRUE

      }


      # Kaplan-Meier ----
      ,


      .plotKM = function(imageKM, ggtheme, theme, ...) {
        # Check conditions and show message if not met
        if (length(self$options$explanatory) > 2) {
          text_warning <- "Kaplan-Meier plot requires 2 categorical explanatory variables.\nYou have selected more than 2 variables."
          # grid::grid.newpage()
          # grid::grid.text(text_warning, 0.5, 0.5)


        # Create a new page
        grid::grid.newpage()

        # Create a viewport with margins for better readability
        vp <- grid::viewport(
          width = 0.9,    # Wider viewport for left-aligned text
          height = 0.9,   # Keep reasonable margins
          x = 0.5,        # Center the viewport
          y = 0.5         # Center the viewport
        )
        grid::pushViewport(vp)

        # Add the text with left alignment
        grid::grid.text(
          text_warning,
          x = 0.05,           # Move text to the left (5% margin)
          y = 0.95,           # Start from top (5% margin)
          just = c("left", "top"),  # Left align and top justify
          gp = grid::gpar(
            fontsize = 11,        # Maintain readable size
            fontface = "plain",   # Regular font
            lineheight = 1.3      # Slightly increased line spacing for readability
          )
        )

        # Reset viewport
        grid::popViewport()

          return(TRUE)
        }






        if (!is.null(self$options$contexpl)) {
          text_warning <- "Kaplan-Meier plot cannot be created with continuous explanatory variables. Please select only categorical variables."
          grid::grid.newpage()
          grid::grid.text(text_warning, 0.5, 0.5)
          return(TRUE)
        }

        if (length(self$options$explanatory) < 2) {
          text_warning <- "Please select 2 categorical explanatory variables to create the Kaplan-Meier plot."
          grid::grid.newpage()
          grid::grid.text(text_warning, 0.5, 0.5)
          return(TRUE)
        }


        # if (length(self$options$explanatory) > 2)
        #     stop("Kaplan-Meier function allows maximum of 2 explanatory variables")
        #
        # if (!is.null(self$options$contexpl))
        #     stop("Kaplan-Meier function does not use continuous explanatory variables.")





        plotData <- imageKM$state

        if (is.null(plotData)) {
          return()
        }

        name1time <- plotData$name1time
        name2outcome <- plotData$name2outcome
        name3contexpl <- plotData$name3contexpl
        name3expl <- plotData$name3expl

        mydata <- cleanData <- plotData$cleanData

        mytime_labelled <- plotData$mytime_labelled
        myoutcome_labelled <- plotData$myoutcome_labelled
        mydxdate_labelled <- plotData$mydxdate_labelled
        myfudate_labelled <- plotData$myfudate_labelled
        myexplanatory_labelled <- plotData$myexplanatory_labelled
        mycontexpl_labelled <- plotData$mycontexpl_labelled


        ### prepare formula ----

        myexplanatory <- NULL
        if (!is.null(self$options$explanatory)) {
          myexplanatory <- as.vector(myexplanatory_labelled)
        }


        # myformula <-
        #     paste("survival::Surv(mytime, myoutcome) ~ ",
        #           paste(myexplanatory, collapse = " + "))
        #
        #
        # myformula <- as.formula(myformula)
        #


        thefactor <- jmvcore::constructFormula(terms = myexplanatory)


        title2 <- as.character(thefactor)

        plotKM <- mydata %>%
          finalfit::surv_plot(
            .data = .,
            dependent = paste0('survival::Surv(', .escapeVariableNames("mytime"), ', ', .escapeVariableNames("myoutcome"), ')'),
            explanatory = thefactor,
            xlab = paste0('Time (', self$options$timetypeoutput, ')'),
            pval = self$options$pplot,
            pval.method	= self$options$pplot,
            legend = 'none',
            break.time.by = self$options$byplot,
            xlim = c(0, self$options$endplot),
            title = paste0("Survival curves for ", title2),
            subtitle = "Based on Kaplan-Meier estimates",
            risk.table = self$options$risktable,
            conf.int = self$options$ci95,
            censor = self$options$censored,
            surv.median.line = self$options$medianline

          )

        # plot <- plot + ggtheme

        print(plotKM)
        TRUE



      }












      ,
      # Risk Score Methods ----

      ## Calculate Risk Score ----

      .calculateRiskScore = function(cox_model, mydata) {

        ### Calculate risk scores ----
        risk_scores <- predict(cox_model, type = "risk")

        ### Add risk scores to data ----
        mydata$risk_score <- risk_scores


        ### Add risk scores to output if requested ----
        if (self$options$addRiskScore &&
            self$results$addRiskScore$isNotFilled()) {
          self$results$addRiskScore$setRowNums(mydata$row_names)
          self$results$addRiskScore$setValues(mydata$risk_score)
        }


        # # Create risk groups using quantiles
        # mydata$risk_group <- cut(
        #   mydata$risk_score,
        #   breaks = quantile(mydata$risk_score, probs = seq(0, 1, by = 0.25)),
        #   labels = c(
        #     "Low Risk",
        #     "Intermediate-Low Risk",
        #     "Intermediate-High Risk",
        #     "High Risk"
        #   ),
        #   include.lowest = TRUE
        # )


        ### Function to try creating risk groups ----
        createRiskGroups <- function(n_groups) {
          tryCatch({
            if(n_groups == 2) {
              probs <- c(0, 0.5, 1)
              labels <- c("Low Risk", "High Risk")
            } else if(n_groups == 3) {
              probs <- c(0, 1/3, 2/3, 1)
              labels <- c("Low Risk", "Intermediate Risk", "High Risk")
            } else {
              probs <- c(0, 0.25, 0.5, 0.75, 1)
              labels <- c("Low Risk", "Intermediate-Low Risk",
                          "Intermediate-High Risk", "High Risk")
            }

            groups <- cut(mydata$risk_score,
                          breaks = quantile(mydata$risk_score, probs = probs),
                          labels = labels,
                          include.lowest = TRUE)

            #### Verify we have at least one observation per group ----
            if(any(table(groups) == 0)) {
              stop(.("Some groups have zero observations"))
            }

            return(list(success = TRUE, groups = groups))
          }, error = function(e) {
            return(list(success = FALSE, error = e$message))
          })
        }

        #### Try to create requested number of groups with fallback ----
        desired_groups <- switch(self$options$numRiskGroups,
                                 "four" = 4,
                                 "three" = 3,
                                 "two" = 2)

        result <- NULL
        warning_message <- NULL

        while(desired_groups >= 2 && is.null(result)) {
          attempt <- createRiskGroups(desired_groups)
          if(attempt$success) {
            result <- attempt$groups
            if(desired_groups < switch(self$options$numRiskGroups,
                                       "four" = 4,
                                       "three" = 3,
                                       "two" = 2)) {
              warning_message <- paste("Could not create", self$options$numRiskGroups,
                               "groups. Fell back to", desired_groups, "groups.")
            }
          } else {
            desired_groups <- desired_groups - 1
          }
        }


        mydata$risk_group <- result

        ### Add risk group to output if requested ----
        if (self$options$addRiskGroup &&
            self$results$addRiskGroup$isNotFilled()) {
          self$results$addRiskGroup$setRowNums(mydata$row_names)
          self$results$addRiskGroup$setValues(mydata$risk_group)
        }

        ### Calculate summary statistics ----
        risk_summary <- data.frame(
          group = levels(mydata$risk_group),
          n_patients = as.numeric(table(mydata$risk_group)),
          events = tapply(mydata$myoutcome, mydata$risk_group, sum),
          median_score = tapply(mydata$risk_score, mydata$risk_group, median)
        )

        risk_summary$percent <- (risk_summary$n_patients / sum(risk_summary$n_patients)) * 100

        ### Fill risk score table ----
        riskScoreTable <- self$results$riskScoreTable

        for (i in seq_len(nrow(risk_summary))) {
          riskScoreTable$addRow(
            rowKey = i,
            values = list(
              group = risk_summary$group[i],
              n_patients = risk_summary$n_patients[i],
              # percent = risk_summary$percent[i],
              percent = round(risk_summary$percent[i], 1),  # Round to 1 decimal
              # median_score = risk_summary$median_score[i],
              median_score = round(risk_summary$median_score[i], 3),  # Round to 3 decimals
              events = risk_summary$events[i]
            )
          )
        }

        ### Create metrics summary ----
        c_index <- survival::concordance(cox_model)$concordance

        c_index_formatted <- sprintf("%.3f", c_index)

        # Create dynamic group summary text
        group_summary <- character()
        for(i in seq_len(nrow(risk_summary))) {
          group_summary[i] <- glue::glue("{risk_summary$group[i]}: {risk_summary$n_patients[i]} ({format(risk_summary$percent[i], digits=1, nsmall=1)}%)")

        }
        group_text <- paste(group_summary, collapse = "<br>")

        metrics_html <- glue::glue(
          "
<br>
<b>Risk Score Model Performance:</b><br>
Harrell's C-index: {sprintf('%.3f', c_index)}<br>
<br>"
# Number of patients in risk groups:<br>
# {group_text}<br>
# "
        )

        self$results$riskScoreMetrics$setContent(metrics_html)


        percentile_text <- switch(
          as.character(length(levels(mydata$risk_group))),
          "2" = "50th percentile are classified as Low Risk, above as High Risk",
          "3" = "33rd percentile are Low Risk, between 33rd-67th percentiles are Intermediate Risk, and above 67th percentile are High Risk",
          "4" = "25th percentile are Low Risk, 25th-50th are Intermediate-Low Risk, 50th-75th are Intermediate-High Risk, and above 75th percentile are High Risk"
        )

        message_risk_score_analysis <- glue::glue(
"<b>Risk Scores Were Calculated As Follows:</b><br>
The risk scores were calculated using the coefficients from the Cox proportional hazards model.
These scores represent the predicted risk of the event occurring based on the combined effect of all variables in the model.
A higher score indicates a greater predicted risk.<br>
<br>
Patients were then divided into {as.character(length(levels(mydata$risk_group)))} equal-sized groups based on these risk scores:
 <br>
- Scores below the {percentile_text}.<br>
<br>
The Harrell's C-index of {c_index_formatted} indicates the model's discriminative ability,
where 0.5 suggests no discriminative ability and 1.0 indicates perfect discrimination between risk groups.
<br><br>
"
        )

        if(is.null(result)) {
          message_risk_score_analysis <- "Unable to create risk groups. Check if risk scores have enough variation."
        }


        self$results$risk_score_analysis$setContent(""
          # list(
          #   desired_groups,
          #   percentile_text,
          #   message_risk_score_analysis,
          #   warning_message,
          #   length(levels(mydata$risk_group)),
          #   levels(mydata$risk_group),
          #   c_index,
          #   c_index_formatted
          #   )
        )

        self$results$risk_score_analysis2$setContent(message_risk_score_analysis)


        return(mydata)
      }

      ## Plot Risk Groups ----
      ,
      .plotRiskGroups = function(image_riskGroupPlot, ggtheme, theme, ...) {
        # Check if risk score calculation is enabled
        if (!self$options$calculateRiskScore ||
            !self$options$plotRiskGroups) {
          return()
        }

        # Get data from image state
        riskData <- image_riskGroupPlot$state
        if (is.null(riskData)) {
          return()
        }

        # Keep only needed columns
        plotData <- data.frame(
          time = riskData$mytime,
          status = riskData$myoutcome,
          group = riskData$risk_group
        )

        # Create survival object and fit
        fit <- survival::survfit(survival::Surv(time, status) ~ group, data = plotData)

        # Create plot
        plot <- survminer::ggsurvplot(
          fit = fit,
          data = plotData,
          risk.table.height = 0.3,
          risk.table.y.text.col = TRUE,
          risk.table.y.text = FALSE,
          ncensor.plot = TRUE,
          ncensor.plot.height = 0.25,
          xlab = paste0("Time (", self$options$timetypeoutput, ")"),
          ylab = "Survival probability",

          pval = self$options$pplot,
          pval.method	= self$options$pplot,
          break.time.by = self$options$byplot,
          xlim = c(0, self$options$endplot),
          risk.table = self$options$risktable,
          conf.int = self$options$ci95,
          censor = self$options$censored,




          title = "Survival by Risk Group",
          subtitle = "Based on Cox model risk score quartiles",
          legend.title = "Risk Group",
          palette = "Set2",
          ggtheme = ggplot2::theme_bw() +
            ggplot2::theme(
              plot.title = ggplot2::element_text(size = 14, face = "bold"),
              plot.subtitle = ggplot2::element_text(size = 12),
              axis.title = ggplot2::element_text(size = 12),
              axis.text = ggplot2::element_text(size = 10),
              legend.text = ggplot2::element_text(size = 10)
            )
        )

        print(plot)
        TRUE
      }






      # ,
      # Compare Models ----
    #   .compare_models = function() {
    #     # Get clean data
    #     cleaneddata <- private$.cleandata()
    #     mydata <- cleaneddata$cleanData
    #
    #     # Get full model variables
    #     full_explanatory <- NULL
    #     if (!is.null(self$options$explanatory)) {
    #       full_explanatory <- as.vector(cleaneddata$myexplanatory_labelled)
    #     }
    #
    #     full_contexpl <- NULL
    #     if (!is.null(self$options$contexpl)) {
    #       full_contexpl <- as.vector(cleaneddata$mycontexpl_labelled)
    #     }
    #
    #     # Get reduced model variables
    #     reduced_explanatory <- NULL
    #     if (!is.null(self$options$reduced_explanatory)) {
    #       reduced_explanatory <- names(labelled::var_label(mydata))[match(self$options$reduced_explanatory,
    #                                                                       labelled::var_label(mydata))]
    #     }
    #
    #     # Create formulas
    #     full_formula <- c(full_explanatory, full_contexpl)
    #
    #     # Run finalfit with model comparison
    #     comparison <- finalfit::finalfit(
    #       .data = mydata,
    #       dependent = 'survival::Surv(mytime, myoutcome)',
    #       explanatory = full_formula,
    #       explanatory_multi = reduced_explanatory,
    #       keep_models = TRUE
    #     )
    #
    #     # Create comparison table
    #     html_comparison <- knitr::kable(comparison[[1]], format = 'html', caption = "Full vs Reduced Model Comparison")
    #
    #     # Add metrics
    #     metrics_html <- glue::glue(
    #       "
    #     <br>
    #     <b>Model Comparison Metrics:</b><br>
    #     Full model AIC: {comparison[[2]]$AIC.full}<br>
    #     Reduced model AIC: {comparison[[2]]$AIC.reduced}<br>
    #     Likelihood ratio test p-value: {comparison[[2]]$lrtest.pvalue}
    # "
    #     )
    #
    #     # Set results
    #     self$results$model_comparison$setContent(html_comparison)
    #     self$results$reduced_model_metrics$setContent(metrics_html)
    #   }



      # Adjusted ----


      ,
    ## calculate Adjusted Stats ----
    .calculateAdjustedStats = function() {
      # Skip if adjusted curves not requested
      if (!self$options$ac) return(NULL)

      # Get cleaned data and check requirements
      cleaneddata <- private$.cleandata()
      if (is.null(cleaneddata)) return(NULL)

      data <- cleaneddata$cleanData
      adj_var <- cleaneddata$adjexplanatory_name

      # if (is.null(adj_var)) {
      #   stop('Please select a variable for adjusted curves')
      # }

      todo <- 'Please select a variable for adjusted curves'

      html <- self$results$todo
      html$setContent(todo)
      return()

      # Add checkpoint before calculations
      private$.checkpoint()

      # Get baseline Cox model
      cox_model <- private$.cox_model()

      # Get unique levels and validate
      levels <- sort(unique(data[[adj_var]]))
      # if (length(levels) < 2) {
      #   stop("Adjustment variable must have at least 2 levels")
      # }
      todo <- 'Adjustment variable must have at least 2 levels'

      html <- self$results$todo
      html$setContent(todo)
      return()

      # Get timepoints for summaries
      timepoints <- if (self$options$ac_summary) {
        tryCatch({
          pts <- as.numeric(trimws(unlist(strsplit(self$options$ac_timepoints, ","))))
          pts <- sort(unique(pts[!is.na(pts)]))
          if (length(pts) == 0) c(12, 36, 60) else pts
        }, error = function(e) c(12, 36, 60))
      } else {
        NULL
      }

      # Calculate adjusted curves for each level
      results <- list()
      summary_rows <- list()

      for (level in levels) {
        tryCatch({
          # Create prediction data with mean/mode values for covariates
          pred_df <- data.frame(
            mytime = sort(unique(c(timepoints, data$mytime)))
          )

          # Add averaged covariates
          for (var in names(data)) {
            if (var != "mytime" && var != adj_var && var != "row_names") {
              if (is.numeric(data[[var]])) {
                pred_df[[var]] <- mean(data[[var]], na.rm = TRUE)
              } else if (is.factor(data[[var]])) {
                pred_df[[var]] <- names(which.max(table(data[[var]])))
              }
            }
          }
          pred_df[[adj_var]] <- level

          # Calculate adjusted survival
          pred_surv <- survival::survfit(cox_model, newdata = pred_df)

          # Store curve data
          if (!is.null(pred_surv)) {
            level_stats <- data.frame(
              time = pred_surv$time,
              survival = pred_surv$surv,
              std.err = pred_surv$std.err,
              lower = pred_surv$lower,
              upper = pred_surv$upper,
              n.risk = pred_surv$n.risk
            )

            results[[as.character(level)]] <- list(
              full_curve = level_stats
            )

            # Calculate summary statistics at specified timepoints
            if (!is.null(timepoints)) {
              for (t in timepoints) {
                idx <- which.min(abs(level_stats$time - t))
                if (length(idx) > 0) {
                  summary_row <- list(
                    Level = as.character(level),
                    Timepoint = t,
                    Survival = level_stats$survival[idx],
                    SE = level_stats$std.err[idx],
                    CI_Lower = level_stats$lower[idx],
                    CI_Upper = level_stats$upper[idx],
                    N_at_Risk = level_stats$n.risk[idx]
                  )
                  if (!any(sapply(summary_row, is.null)) &&
                      !any(sapply(summary_row, is.na))) {
                    summary_rows[[length(summary_rows) + 1]] <- summary_row
                  }
                }
              }
            }
          }
        }, error = function(e) {
          warning(paste("Error processing level", level, ":", e$message))
        })
      }

      # Add metadata
      attr(results, "timepoints") <- timepoints
      attr(results, "levels") <- levels
      attr(results, "variable") <- adj_var
      attr(results, "method") <- self$options$ac_method

      # Generate summary table
      if (length(summary_rows) > 0) {
        # Sort by level and timepoint
        sorted_indices <- order(
          sapply(summary_rows, function(x) x$Level),
          sapply(summary_rows, function(x) x$Timepoint)
        )
        summary_rows <- summary_rows[sorted_indices]

        # Add rows to table
        for (i in seq_along(summary_rows)) {
          row <- summary_rows[[i]]
          self$results$adjustedSummaryTable$addRow(
            rowKey = i,
            values = list(
              Level = row$Level,
              Timepoint = row$Timepoint,
              Survival = round(row$Survival, 3),
              SE = round(row$SE, 3),
              CI_Lower = round(row$CI_Lower, 3),
              CI_Upper = round(row$CI_Upper, 3)
            )
          )
        }
      }

      # Run additional analyses
      if (self$options$ac_summary) {
        private$.adjustedSurvTable(results, cox_model)
        private$.adjustedMedianSurv(results, cox_model)
        private$.adjustedCox(results, cox_model)
      }

      if (self$options$ac_compare) {
        private$.adjustedPairwise(results, cox_model)
      }

      return(results)
    }



      ,
    ## Adjusted Survival Table ----
    .adjustedSurvTable = function(results, cox_model) {
      # Get data components
      mytime <- results$name1time
      myoutcome <- results$name2outcome
      adj_var <- results$adjexplanatory_name
      mydata <- results$cleanData

      # Input validation
      if (is.null(mydata) || is.null(cox_model)) {
        return(NULL)
      }

      # Get timepoints
      timepoints <- tryCatch({
        pts <- as.numeric(trimws(unlist(strsplit(self$options$cutp, ","))))
        pts <- sort(unique(pts[!is.na(pts)]))
        if (length(pts) == 0) c(12, 36, 60) else pts
      }, error = function(e) c(12, 36, 60))

      # Get levels
      levels <- sort(unique(mydata[[adj_var]]))

      # Create base prediction data
      pred_base <- list()
      for (var in names(mydata)) {
        if (var != "mytime" && var != adj_var && var != "row_names" && var != myoutcome) {
          if (is.numeric(mydata[[var]])) {
            pred_base[[var]] <- mean(mydata[[var]], na.rm = TRUE)
          } else if (is.factor(mydata[[var]])) {
            pred_base[[var]] <- names(which.max(table(mydata[[var]])))
          }
        }
      }

      # Calculate survival for each level
      all_results <- list()

      for (level in levels) {
        # Create prediction data
        n_times <- length(timepoints)
        pred_data <- data.frame(
          mytime = timepoints
        )

        # Add mean covariates
        for (var in names(pred_base)) {
          pred_data[[var]] <- rep(pred_base[[var]], n_times)
        }

        # Add level
        pred_data[[adj_var]] <- rep(level, n_times)

        # Calculate survival
        surv_fit <- survival::survfit(cox_model, newdata = pred_data)
        surv_summ <- summary(surv_fit, times = timepoints)

        # Store results
        for (i in seq_along(timepoints)) {
          if (i <= length(surv_summ$time)) {
            all_results[[length(all_results) + 1]] <- list(
              Level = level,
              Time = timepoints[i],
              "Number at Risk" = surv_summ$n.risk[i],
              Events = surv_summ$n.event[i],
              "Adjusted Survival" = scales::percent(surv_summ$surv[i], accuracy = 0.1),
              "95% CI Lower" = scales::percent(surv_summ$lower[i], accuracy = 0.1),
              "95% CI Upper" = scales::percent(surv_summ$upper[i], accuracy = 0.1)
            )
          }
        }
      }

      # Add results to table
      if (length(all_results) > 0) {
        # Clear existing rows
        self$results$adjustedSurvTable$setRows(NULL)

        # Add new rows
        for (i in seq_along(all_results)) {
          row <- all_results[[i]]
          self$results$adjustedSurvTable$addRow(
            rowKey = i,
            values = row
          )
        }

        # Generate natural language interpretations
        summaries <- sapply(all_results, function(row) {
          glue::glue(
            "For {row$Level} at {row$Time} months, adjusted survival is {row$`Adjusted Survival`} ",
            "[{row$`95% CI Lower`}-{row$`95% CI Upper`}, 95% CI]. ",
            "At this timepoint, {row$`Number at Risk`} subjects were at risk ",
            "and {row$Events} events had occurred. ",
            "These estimates account for the average values of covariates."
          )
        })

        self$results$adjustedSurvTableSummary$setContent(summaries)
      }

      return(all_results)
    }



      #
      # .calculateAdjustedStats = function() {
      #   if (!self$options$ac) return(NULL)
      #
      #   # Get data and fit model
      #   cleaneddata <- private$.cleandata()
      #   if (is.null(cleaneddata)) return(NULL)
      #
      #   adj_var <- cleaneddata$adjexplanatory_name
      #   if (is.null(adj_var)) {
      #     stop('Please select a variable for adjusted curves')
      #   }
      #
      #   # Fit Cox model
      #   cox_model <- private$.fitCoxModel(cleaneddata)
      #
      #   # Calculate survival tables and summaries
      #   surv_results <- private$.adjustedSurvTable(cleaneddata, cox_model)
      #   median_results <- private$.adjustedMedianSurv(cleaneddata, cox_model)
      #   cox_results <- private$.adjustedCox(cleaneddata, cox_model)
      #
      #   if (self$options$ac_compare) {
      #     pairwise_results <- private$.adjustedPairwise(cleaneddata, cox_model)
      #   }
      #
      #   return(list(
      #     surv = surv_results,
      #     median = median_results,
      #     cox = cox_results
      #   ))
      # }
      #






      # mydataview_calculateAdjustedStats <- self$results$mydataview_calculateAdjustedStats
      # mydataview_calculateAdjustedStats$setContent(
      #   list(
      #     results = results,
      #     summary_rows = summary_rows
      #   )
      # )

      ,
    ## Adjusted Survival Plot ----
      .plot_adj = function(image_plot_adj, ggtheme, theme, ...) {

        if (!self$options$ac) return()

        plotData <- image_plot_adj$state

        if (is.null(plotData)) {
          return()
        }

        name1time <- plotData$name1time
        name2outcome <- plotData$name2outcome
        name3contexpl <- plotData$name3contexpl
        name3expl <- plotData$name3expl
        adjexplanatory_name <- plotData$adjexplanatory_name

        mydata <- cleanData <- plotData$cleanData

        mytime_labelled <- plotData$mytime_labelled
        myoutcome_labelled <- plotData$myoutcome_labelled
        mydxdate_labelled <- plotData$mydxdate_labelled
        myfudate_labelled <- plotData$myfudate_labelled
        myexplanatory_labelled <- plotData$myexplanatory_labelled
        mycontexpl_labelled <- plotData$mycontexpl_labelled
        adjexplanatory_labelled <- plotData$adjexplanatory_labelled


        if (is.null(plotData$adjexplanatory_name)) {
          text_warning <- "Please select a variable for adjusted curves."
          grid::grid.newpage()
          grid::grid.text(text_warning, 0.5, 0.5)
          return(TRUE)
        }








        ### prepare formula ----

        myexplanatory <- NULL
        if (!is.null(self$options$explanatory)) {
          myexplanatory <- as.vector(myexplanatory_labelled)
        }

        mycontexpl <- NULL
        if (!is.null(self$options$contexpl)) {
          mycontexpl <- as.vector(mycontexpl_labelled)
        }

        formula2 <- c(myexplanatory, mycontexpl)

        myformula <-
          paste("survival::Surv(mytime, myoutcome) ~ ",
                paste(formula2, collapse = " + "))

        myformula <- as.formula(myformula)

        # Fit model
        cox_model <- survival::coxph(myformula, data = mydata)

        # Validate method and try fallback if needed
        method <- self$options$ac_method

        # Try to create plot with specified method
        plot <- tryCatch({
          survminer::ggadjustedcurves(
            fit = cox_model,
            data = mydata,
            variable = adjexplanatory_name,
            method = method,
            conf.int = self$options$ci95,
            risk.table = self$options$risktable,
            xlab = paste0('Time (', self$options$timetypeoutput, ')'),
            title = paste0("Adjusted Survival Curves for ", self$options$adjexplanatory,
                           " (", method, " adjustment)"),
            pval = self$options$pplot,
            pval.method = self$options$pplot,
            legend = "none",
            break.time.by = self$options$byplot,
            xlim = c(0, self$options$endplot),
            censor = self$options$censored,
            surv.median.line = self$options$medianline



          )
        }, error = function(e) {
          # If marginal method fails, try average method instead
          if (method == "marginal") {
            warning(.("Marginal method failed, falling back to average method"))
            survminer::ggadjustedcurves(
              fit = cox_model,
              data = mydata,
              variable = adjexplanatory_name,
              method = "average",  # Fallback to average method
              conf.int = self$options$ci95,
              risk.table = self$options$risktable,
              xlab = paste0('Time (', self$options$timetypeoutput, ')'),
              title = paste0("Adjusted Survival Curves for ",
                             self$options$adjexplanatory,
                             " (average adjustment - marginal failed)"),
              pval = self$options$pplot,
              pval.method = self$options$pplot,
              legend = "none",
              break.time.by = self$options$byplot,
              xlim = c(0, self$options$endplot),
              censor = self$options$censored,
              surv.median.line = self$options$medianline
            )
          } else {
            stop(paste("Error creating adjusted curves:", e$message))
          }
        })




        # # Prepare plot parameters
        # plot_params <- list(
        #   fit = cox_model,
        #   data = mydata,
        #   variable = adjexplanatory_name,
        #   method = self$options$ac_method,
        #   conf.int = self$options$ci95,
        #   risk.table = self$options$risktable,
        #   xlab = paste0('Time (', self$options$timetypeoutput, ')'),
        #   title = paste0("Adjusted Survival Curves for ",
        #                  self$options$adjexplanatory,
        #                  " (", self$options$ac_method, " adjustment)"),
        #   pval = self$options$pplot,
        #   pval.method = self$options$pplot,
        #   legend = "none",
        #   break.time.by = self$options$byplot,
        #   xlim = c(0, self$options$endplot),
        #   censor = self$options$censored,
        #   surv.median.line = self$options$medianline,
        #   risk.table.height = 0.25,  # Added for better risk table sizing
        #   risk.table.y.text.col = TRUE,  # Color code risk table text
        #   ncensor.plot = FALSE,  # Turn off censor plot by default
        #   fontsize = 3.5  # Adjust font size
        # )
        # # Try to create plot with specified method
        # plot <- tryCatch({
        #   do.call(survminer::ggadjustedcurves, plot_params)
        # }, error = function(e) {
        #   # If marginal method fails, try average method instead
        #   if (self$options$ac_method == "marginal") {
        #     warning("Marginal method failed, falling back to average method")
        #     plot_params$method <- "average"
        #     plot_params$title <- paste0("Adjusted Survival Curves for ",
        #                                 self$options$adjexplanatory,
        #                                 " (average adjustment - marginal failed)")
        #     do.call(survminer::ggadjustedcurves, plot_params)
        #   } else {
        #     stop(paste("Error creating adjusted curves:", e$message))
        #   }
        # })
        # # Add additional theme elements if needed
        # plot <- plot +
        #   ggplot2::theme(
        #     plot.title = ggplot2::element_text(size = 14, face = "bold"),
        #     plot.subtitle = ggplot2::element_text(size = 12),
        #     axis.title = ggplot2::element_text(size = 12),
        #     axis.text = ggplot2::element_text(size = 10),
        #     legend.text = ggplot2::element_text(size = 10)
        #   )












        print(plot)
        TRUE
      }



      # ,
      # .adjustedSurvTable = function(results, cox_model) {
      #   # Get data components
      #   mytime <- results$name1time
      #   myoutcome <- results$name2outcome
      #   adj_var <- results$adjexplanatory_name
      #   mydata <- results$cleanData
      #
      #   # Verify we have valid data and model
      #   if (is.null(mydata) || is.null(cox_model)) {
      #     return(NULL)
      #   }
      #
      #   # Get timepoints
      #   timepoints <- tryCatch({
      #     pts <- as.numeric(trimws(unlist(strsplit(self$options$ac_timepoints, ","))))
      #     pts <- sort(unique(pts[!is.na(pts)]))
      #     if (length(pts) == 0) c(12, 36, 60) else pts
      #   }, error = function(e) c(12, 36, 60))
      #
      #   # Get levels of adjustment variable
      #   levels <- sort(unique(mydata[[adj_var]]))
      #   if (length(levels) < 1) {
      #     warning("No levels found in adjustment variable")
      #     return(NULL)
      #   }
      #
      #   # Create base prediction dataset
      #   pred_base <- list()
      #   for (var in names(mydata)) {
      #     if (var != "mytime" && var != adj_var && var != "row_names") {
      #       if (is.numeric(mydata[[var]])) {
      #         pred_base[[var]] <- mean(mydata[[var]], na.rm = TRUE)
      #       } else if (is.factor(mydata[[var]])) {
      #         pred_base[[var]] <- levels(mydata[[var]])[which.max(table(mydata[[var]]))]
      #       }
      #     }
      #   }
      #
      #   # Initialize storage for results
      #   all_results <- list()
      #   row_counter <- 1
      #
      #   # Calculate survival for each level and timepoint
      #   for (level in levels) {
      #     # Create prediction data for this level
      #     pred_data <- data.frame(
      #       mytime = timepoints
      #     )
      #
      #     # Add averaged covariates
      #     for (var in names(pred_base)) {
      #       pred_data[[var]] <- pred_base[[var]]
      #     }
      #     pred_data[[adj_var]] <- level
      #
      #     tryCatch({
      #       # Get predicted survival
      #       surv_fit <- survival::survfit(cox_model, newdata = pred_data)
      #       surv_summary <- summary(surv_fit, times = timepoints)
      #
      #       # Extract results for each timepoint
      #       for (i in seq_along(timepoints)) {
      #         if (i <= length(surv_summary$time)) {
      #           all_results[[row_counter]] <- list(
      #             strata = level,
      #             time = timepoints[i],
      #             n.risk = surv_summary$n.risk[i],
      #             n.event = surv_summary$n.event[i],
      #             surv = surv_summary$surv[i],
      #             lower = surv_summary$lower[i],
      #             upper = surv_summary$upper[i]
      #           )
      #           row_counter <- row_counter + 1
      #         }
      #       }
      #     }, error = function(e) {
      #       warning(paste("Error processing level", level, ":", e$message))
      #     })
      #   }
      #
      #   # Convert results to data frame if we have any
      #   if (length(all_results) > 0) {
      #     results_df <- do.call(rbind, lapply(all_results, as.data.frame))
      #
      #     # Add to results table
      #     survTable <- self$results$adjustedSurvTable
      #     survTable$setRows(NULL) # Clear existing rows
      #
      #     for (i in seq_len(nrow(results_df))) {
      #       survTable$addRow(
      #         rowKey = i,
      #         values = list(
      #           strata = results_df$strata[i],
      #           time = results_df$time[i],
      #           n.risk = results_df$n.risk[i],
      #           n.event = results_df$n.event[i],
      #           surv = scales::percent(results_df$surv[i], accuracy = 0.1),
      #           lower = scales::percent(results_df$lower[i], accuracy = 0.1),
      #           upper = scales::percent(results_df$upper[i], accuracy = 0.1)
      #         )
      #       )
      #     }
      #
      #     # Generate summary text
      #     survTableSummary <- sapply(seq_len(nrow(results_df)), function(i) {
      #       glue::glue(
      #         "For {results_df$strata[i]} at {results_df$time[i]} months, ",
      #         "the adjusted survival probability is {scales::percent(results_df$surv[i], accuracy=0.1)} ",
      #         "[{scales::percent(results_df$lower[i], accuracy=0.1)}-",
      #         "{scales::percent(results_df$upper[i], accuracy=0.1)}, 95% CI]. ",
      #         "These estimates account for the average values of all covariates in the model."
      #       )
      #     })
      #
      #     self$results$adjustedSurvTableSummary$setContent(survTableSummary)
      #
      #     return(results_df)
      #   }
      #
      #   return(NULL)
      # }





      ,
    ## Adjusted Pariwise ----
    .adjustedPairwise = function(results, cox_model) {
      # Get components
      mytime <- results$name1time
      myoutcome <- results$name2outcome
      adj_var <- results$adjexplanatory_name
      mydata <- results$cleanData

      # Error checking
      if (is.null(mydata) || is.null(cox_model)) {
        warning(.("Missing data or model for pairwise comparisons"))
        return(NULL)
      }

      # Get levels
      levels <- sort(unique(mydata[[adj_var]]))
      if (length(levels) < 2) {
        warning(.("Need at least 2 levels for pairwise comparisons"))
        return(NULL)
      }

      # Create prediction dataset with average values
      pred_base <- data.frame(mytime = max(mydata[[mytime]]))
      for (var in names(mydata)) {
        if (var != "mytime" && var != adj_var && var != "row_names") {
          if (is.numeric(mydata[[var]])) {
            pred_base[[var]] <- mean(mydata[[var]], na.rm = TRUE)
          } else if (is.factor(mydata[[var]])) {
            pred_base[[var]] <- names(which.max(table(mydata[[var]])))
          }
        }
      }

      # Initialize p-value matrix
      n_levels <- length(levels)
      p_values <- matrix(NA, n_levels, n_levels)
      rownames(p_values) <- levels
      colnames(p_values) <- levels

      # Calculate pairwise comparisons
      for (i in 1:(n_levels-1)) {
        for (j in (i+1):n_levels) {
          tryCatch({
            # Create test dataset
            test_data <- rbind(pred_base, pred_base)
            test_data[[adj_var]] <- factor(c(levels[i], levels[j]))

            # Calculate survival difference
            test_fit <- survival::survfit(cox_model, newdata = test_data)
            surv_diff <- survival::survdiff(Surv(mytime, myoutcome) ~ factor(test_data[[adj_var]]))
            p_val <- 1 - pchisq(surv_diff$chisq, df = 1)

            p_values[i,j] <- p_val
            p_values[j,i] <- p_val
          }, error = function(e) {
            warning(paste("Error comparing levels", levels[i], "and", levels[j], ":", e$message))
          })
        }
      }

      # Adjust p-values
      padjustmethod <- self$options$padjustmethod
      adj_p <- p.adjust(p_values[upper.tri(p_values)], method = padjustmethod)
      p_values[upper.tri(p_values)] <- adj_p
      p_values[lower.tri(p_values)] <- t(p_values)[lower.tri(p_values)]

      # Convert to long format
      comparisons <- list()
      counter <- 1
      for (i in 1:(n_levels-1)) {
        for (j in (i+1):n_levels) {
          if (!is.na(p_values[i,j])) {
            comparisons[[counter]] <- list(
              rowname = levels[i],
              name = levels[j],
              value = p_values[i,j]
            )
            counter <- counter + 1
          }
        }
      }

      # Add results to table
      if (length(comparisons) > 0) {
        # Clear existing rows
        self$results$adjustedPairwiseTable$setRows(NULL)

        # Add new rows
        for (i in seq_along(comparisons)) {
          comp <- comparisons[[i]]
          self$results$adjustedPairwiseTable$addRow(
            rowKey = i,
            values = list(
              rowname = comp$rowname,
              name = comp$name,
              value = format.pval(comp$value, digits = 3)
            )
          )
        }

        # Create natural language summaries
        summaries <- lapply(comparisons, function(comp) {
          glue::glue(
            "The adjusted survival difference between {comp$rowname} and {comp$name} groups ",
            "has a p-value of {format.pval(comp$value, digits=3, eps=0.001)}. ",
            "This comparison accounts for covariates set at their average values. ",
            "{if(comp$value < 0.05) 'This difference is statistically significant' else 'This difference is not statistically significant'} ",
            "after {padjustmethod} adjustment for multiple comparisons."
          )
        })

        self$results$adjustedPairwiseSummary$setContent(unlist(summaries))
      }

      return(comparisons)
    }




      ,
    ## Adjusted Median Survival ----
    .adjustedMedianSurv = function(results, cox_model) {
      # Get required data
      mytime <- results$name1time
      myoutcome <- results$name2outcome
      adj_var <- results$adjexplanatory_name
      mydata <- results$cleanData

      # Get levels of adjustment variable
      levels <- sort(unique(mydata[[adj_var]]))

      # Create prediction data with average covariate values
      pred_data <- data.frame(
        mytime = sort(unique(mydata[[mytime]]))
      )

      # Add mean/mode values for covariates
      for (var in names(mydata)) {
        if (var != "mytime" && var != adj_var && var != "row_names") {
          if (is.numeric(mydata[[var]])) {
            pred_data[[var]] <- mean(mydata[[var]], na.rm = TRUE)
          } else if (is.factor(mydata[[var]])) {
            pred_data[[var]] <- names(which.max(table(mydata[[var]])))
          }
        }
      }

      # Calculate adjusted survival for each level
      results_list <- list()

      for (level in levels) {
        level_data <- pred_data
        level_data[[adj_var]] <- level

        # Calculate adjusted survival
        adj_surv <- survival::survfit(cox_model, newdata = level_data)

        # Get summary stats
        surv_summary <- summary(adj_surv)

        # Extract median and CI
        median_time <- surv_summary$table["median"]
        lcl <- surv_summary$table["0.95LCL"]
        ucl <- surv_summary$table["0.95UCL"]

        results_list[[level]] <- list(
          factor = level,
          median = median_time,
          x0_95lcl = lcl,
          x0_95ucl = ucl,
          records = sum(!is.na(mydata[[mytime]][mydata[[adj_var]] == level])),
          events = sum(mydata[[myoutcome]][mydata[[adj_var]] == level] == 1, na.rm = TRUE)
        )
      }

      # Convert to data frame
      results_df <- do.call(rbind, lapply(results_list, as.data.frame))
      results_df <- as.data.frame(results_df)

      # Add to results table
      medianTable <- self$results$adjustedMedianTable
      for (i in seq_len(nrow(results_df))) {
        medianTable$addRow(
          rowKey = i,
          values = list(
            factor = results_df$factor[i],
            records = results_df$records[i],
            events = results_df$events[i],
            median = round(results_df$median[i], 1),
            x0_95lcl = round(results_df$x0_95lcl[i], 1),
            x0_95ucl = round(results_df$x0_95ucl[i], 1)
          )
        )
      }

      # Create natural language summaries
      summaries <- lapply(levels, function(level) {
        result <- results_df[results_df$factor == level,]

        description <- glue::glue(
          "For {adj_var} = {level}, adjusted median survival is {round(result$median, 1)} ",
          "[{round(result$x0_95lcl, 1)} - {round(result$x0_95ucl, 1)}, 95% CI] ",
          self$options$timetypeoutput, "."
        )

        if (is.na(result$median)) {
          description <- paste0(
            description,
            "\nNote: The adjusted survival curve for this group does not drop below 1/2 during ",
            "the observation period, thus the median survival is undefined."
          )
        }

        return(description)
      })

      # Add general interpretation
      medianSummary <- c(
        unlist(summaries),
        "The median survival time is when 50% of subjects have experienced the event.",
        "These estimates account for the average values of all other covariates in the model."
      )

      self$results$adjustedMedianSummary$setContent(medianSummary)
    }


      ,
    ## Adjusted Cox ----
    .adjustedCox = function(results, cox_model) {
      mydata <- results$cleanData
      adj_var <- results$adjexplanatory_name

      # Get Cox model summary
      cox_summary <- summary(cox_model)

      # Create metrics summary
      tCoxtext2 <- glue::glue("
        <br>
        <b>Model Metrics:</b><br>
        Concordance: {round(cox_summary$concordance[1], 3)} (SE = {round(cox_summary$concordance[2], 3)})<br>
        Likelihood ratio test = {round(cox_summary$logtest[1], 2)}, df = {cox_summary$logtest[2]}, p = {format.pval(cox_summary$logtest[3], digits=3)}<br>
        Wald test = {round(cox_summary$waldtest[1], 2)}, df = {cox_summary$waldtest[2]}, p = {format.pval(cox_summary$waldtest[3], digits=3)}<br>
        Score test = {round(cox_summary$sctest[1], 2)}, df = {cox_summary$sctest[2]}, p = {format.pval(cox_summary$sctest[3], digits=3)}<br>
    ")

      if (self$options$uselandmark) {
        landmark <- jmvcore::toNumeric(self$options$landmark)
        tCoxtext2 <- glue::glue(
          tCoxtext2,
          "Landmark time used as: ", landmark, " ", self$options$timetypeoutput, "."
        )
      }

      self$results$adjustedCoxText$setContent(tCoxtext2)

      # Extract hazard ratios and CIs
      coef_matrix <- cbind(
        exp(cox_summary$coefficients[, 1]),  # HR
        exp(cox_summary$coefficients[, 1] - 1.96 * cox_summary$coefficients[, 3]),  # Lower CI
        exp(cox_summary$coefficients[, 1] + 1.96 * cox_summary$coefficients[, 3]),  # Upper CI
        cox_summary$coefficients[, 5]  # p-value
      )

      # Create Cox table
      coxTable <- self$results$adjustedCoxTable
      rownames <- row.names(cox_summary$coefficients)

      for (i in seq_len(nrow(coef_matrix))) {
        coxTable$addRow(
          rowKey = i,
          values = list(
            Variable = rownames[i],
            HR = sprintf("%.2f (%.2f-%.2f)",
                         coef_matrix[i,1], coef_matrix[i,2], coef_matrix[i,3]),
            Pvalue = format.pval(coef_matrix[i,4], digits=3)
          )
        )
      }

      # Create interpretive summary
      coxSummary <- sapply(seq_len(nrow(coef_matrix)), function(i) {
        hr <- coef_matrix[i,1]
        var_name <- rownames[i]

        glue::glue(
          "For {var_name}, the adjusted hazard ratio is {round(hr,2)} ",
          "({round(coef_matrix[i,2],2)}-{round(coef_matrix[i,3],2)}, 95% CI). ",
          "This means that, after adjusting for other covariates, ",
          "{ifelse(hr > 1,
                paste('there is a', round((hr-1)*100,1), '% increase in hazard'),
                paste('there is a', round((1-hr)*100,1), '% decrease in hazard'))} ",
          "for each unit increase in {var_name}."
        )
      })

      coxSummary <- c(
        unlist(coxSummary),
        "A hazard ratio greater than 1 indicates increased risk, while less than 1 indicates decreased risk.",
        "All estimates are adjusted for other variables in the model."
      )

      self$results$adjustedCoxSummary$setContent(coxSummary)

      # Proportional hazards check if requested
      if (self$options$ph_cox) {
        zph <- survival::cox.zph(cox_model)
        self$results$adjustedCoxPH$setContent(print(zph))

        # Set state for plot
        image8 <- self$results$adjustedCoxPHPlot
        image8$setState(zph)
      }
    }




      # ,
      # .calculateAdjustedCurves = function(cox_model, mydata, adjexplanatory_name, fallback = TRUE) {
      #
      #   method <- self$options$ac_method
      #
      #   # Try to calculate adjusted curves with specified method
      #   adj_curves <-  tryCatch({
      #       survminer::ggadjustedcurves(
      #         fit = cox_model,
      #         data = mydata,
      #         variable = adjexplanatory_name,
      #         method = method,
      #         conf.int = self$options$ci95,
      #         risk.table = self$options$risktable,
      #         xlab = paste0('Time (', self$options$timetypeoutput, ')'),
      #         title = paste0(
      #           "Adjusted Survival Curves for ",
      #           self$options$adjexplanatory,
      #           " (", method, " adjustment)"
      #         ),
      #         pval = self$options$pplot,
      #         pval.method = self$options$pplot,
      #         legend = "none",
      #         break.time.by = self$options$byplot,
      #         xlim = c(0, self$options$endplot),
      #         censored = self$options$censored
      #       )
      #     }, error = function(e) {
      #       # If marginal method fails, try average method instead
      #       if (method == "marginal") {
      #         warning("Marginal method failed, falling back to average method")
      #         survminer::ggadjustedcurves(
      #           fit = cox_model,
      #           data = mydata,
      #           variable = adjexplanatory_name,
      #           method = "average",  # Fallback to average method
      #           conf.int = self$options$ci95,
      #           risk.table = self$options$risktable,
      #           xlab = paste0('Time (', self$options$timetypeoutput, ')'),
      #           title = paste0(
      #             "Adjusted Survival Curves for ",
      #             self$options$adjexplanatory,
      #             " (average adjustment - marginal failed)"
      #           ),
      #           pval = self$options$pplot,
      #           pval.method = self$options$pplot,
      #           legend = "none",
      #           break.time.by = self$options$byplot,
      #           xlim = c(0, self$options$endplot),
      #           censored = self$options$censored
      #         )
      #       } else {
      #         stop(paste("Error creating adjusted curves:", e$message))
      #       }
      #     }
      #       )
      #
      #
      #   # image_plot_adj <- self$results$plot_adj
      #   # image_plot_adj$setState(adj_curves)
      #
      #
      #   # Extract and structure the data
      #   # curve_data <- list(
      #   #   curves = adj_curves,
      #   #   model = cox_model,
      #   #   data = mydata,
      #   #   variable = adjexplanatory_name,
      #   #   method = method
      #   # )
      #
      #   # class(curve_data) <- "adjusted_curves"
      #
      #
      #   # View curve_data
      #   self$results$mydataview_curve_data$setContent(
      #     list(
      #       # curves = adj_curves,
      #       model = cox_model,
      #       data = mydata,
      #       variable = adjexplanatory_name,
      #       method = method
      #     )
      #   )
      #
      #
      #   # return(curve_data)
      # }



      # ,
      # .plot_adj = function(image_plot_adj, ggtheme, theme, ...) {
      #   if (!self$options$ac) {
      #     return()
      #   }
      #   if (is.null(curve_data)) {
      #     return()
      #   }
      #
      #   plot <- image_plot_adj$state
      #
      #
      #   # plot <- survminer::ggadjustedcurves(plot)
      #
      #
      #   print(plot)
      #   TRUE
      #
      #
      # }




      # ,
      # .plot_adj = function(image_plot_adj, ggtheme, theme, ...) {
      #   if (!self$options$ac) {
      #     return()
      #   }
      #
      #   if (!self$options$ac_curve) {
      #     return()
      #   }
      #
      #
      #   # mydata <- image_plot_adj$state$mydata
      #   # cox_model <- image_plot_adj$state$cox_model
      #   # adjexplanatory_name <- image_plot_adj$state$adjexplanatory_name
      #
      #
      #
      #   cleaneddata <- private$.cleandata()
      #
      #   name1time <- cleaneddata$name1time
      #   name2outcome <- cleaneddata$name2outcome
      #   name3contexpl <- cleaneddata$name3contexpl
      #   name3expl <- cleaneddata$name3expl
      #   adjexplanatory_name <- cleaneddata$adjexplanatory_name
      #
      #   mydata <- cleanData <- cleaneddata$cleanData
      #
      #   mytime_labelled <- cleaneddata$mytime_labelled
      #   myoutcome_labelled <- cleaneddata$myoutcome_labelled
      #   mydxdate_labelled <- cleaneddata$mydxdate_labelled
      #   myfudate_labelled <- cleaneddata$myfudate_labelled
      #   myexplanatory_labelled <- cleaneddata$myexplanatory_labelled
      #   mycontexpl_labelled <- cleaneddata$mycontexpl_labelled
      #   adjexplanatory_labelled <- cleaneddata$adjexplanatory_labelled
      #
      #
      #
      #   # Add stratification variables
      #   mystratvar <- NULL
      #   if (self$options$use_stratify && !is.null(self$options$stratvar)) {
      #     mystratvar <- as.vector(cleaneddata$mystratvar_labelled)
      #     # Create strata terms
      #     mystratvar <- paste0("strata(", mystratvar, ")")
      #   }
      #
      #
      #
      #   myexplanatory <- NULL
      #   if (!is.null(self$options$explanatory)) {
      #     myexplanatory <- as.vector(myexplanatory_labelled)
      #   }
      #
      #   mycontexpl <- NULL
      #   if (!is.null(self$options$contexpl)) {
      #     mycontexpl <- as.vector(mycontexpl_labelled)
      #   }
      #
      #
      #   formula2 <- c(myexplanatory, mycontexpl, mystratvar)
      #
      #
      #
      #   LHT <- "survival::Surv(mytime, myoutcome)"
      #
      #   RHT <- formula2
      #
      #   RHT <- paste(RHT, collapse = " + ")
      #
      #   coxformula <- paste0(LHT, " ~ ", RHT)
      #
      #   coxformula <- as.formula(coxformula)
      #
      #   cox_model <- survival::coxph(coxformula, data = mydata)
      #
      #
      #
      #   fallback <- TRUE
      #   method <- self$options$ac_method
      #
      #   # Try to calculate adjusted curves with specified method
      #   adj_curves <-  tryCatch({
      #     survminer::ggadjustedcurves(
      #       fit = cox_model,
      #       data = mydata,
      #       variable = adjexplanatory_name,
      #       method = method,
      #       conf.int = self$options$ci95,
      #       risk.table = self$options$risktable,
      #       xlab = paste0('Time (', self$options$timetypeoutput, ')'),
      #       title = paste0(
      #         "Adjusted Survival Curves for ",
      #         self$options$adjexplanatory,
      #         " (", method, " adjustment)"
      #       ),
      #       pval = self$options$pplot,
      #       pval.method = self$options$pplot,
      #       legend = "none",
      #       break.time.by = self$options$byplot,
      #       xlim = c(0, self$options$endplot),
      #       censored = self$options$censored
      #     )
      #   }, error = function(e) {
      #     # If marginal method fails, try average method instead
      #     if (method == "marginal") {
      #       warning("Marginal method failed, falling back to average method")
      #       survminer::ggadjustedcurves(
      #         fit = cox_model,
      #         data = mydata,
      #         variable = adjexplanatory_name,
      #         method = "average",  # Fallback to average method
      #         conf.int = self$options$ci95,
      #         risk.table = self$options$risktable,
      #         xlab = paste0('Time (', self$options$timetypeoutput, ')'),
      #         title = paste0(
      #           "Adjusted Survival Curves for ",
      #           self$options$adjexplanatory,
      #           " (average adjustment - marginal failed)"
      #         ),
      #         pval = self$options$pplot,
      #         pval.method = self$options$pplot,
      #         legend = "none",
      #         break.time.by = self$options$byplot,
      #         xlim = c(0, self$options$endplot),
      #         censored = self$options$censored
      #       )
      #     } else {
      #       stop(paste("Error creating adjusted curves:", e$message))
      #     }
      #   }
      #   )
      #
      #
      #
      #
      #   print(adj_curves)
      #   TRUE
      #
      #
      # }



      ,
    ## Fit Cox Model with Selection ----
.fitModelWithSelection = function(formula, data) {
  tryCatch({
    # Get the selection method and criteria from options
    modelSelection <- self$options$modelSelection
    selectionCriteria <- self$options$selectionCriteria
    pEntry <- self$options$pEntry
    pRemoval <- self$options$pRemoval

    # Validation checks
    if (self$options$pEntry >= self$options$pRemoval) {
      stop(.("Entry significance must be less than removal significance"))
    }

    if (self$options$modelSelection != "enter" &&
        length(c(self$options$explanatory, self$options$contexpl)) < 2) {
      stop(.("Variable selection requires at least 2 predictor variables"))
    }

    private$.checkpoint()

    # If no selection requested, return full model
    if (modelSelection == "enter") {
      # Just fit and return the full model with all variables
      full_model <- survival::coxph(formula, data = data)
      return(full_model)
    }

    # For Cox models we need to preserve the exact Surv() object on the left side
    surv_part <- formula[[2]]  # Gets the Surv() expression itself
    pred_part <- attr(terms(formula), "term.labels")  # All predictor variables

    # Create full and null models
    full_model <- survival::coxph(formula, data = data)
    null_formula <- as.formula(paste(deparse(surv_part), "~ 1"))
    null_model <- survival::coxph(null_formula, data = data)

    # For backward selection
    if (modelSelection == "backward") {
      # Start with all variables
      current_vars <- pred_part
      current_model <- full_model

      # Set status to indicate backward selection is starting
      self$results$text_model_selection$setStatus('running')
      self$results$text2_model_selection$setStatus('running')

      # Initial checkpoint to push status to UI
      private$.checkpoint()

      # Track variables removed for reporting
      removed_vars <- character(0)

      # Remove variables one-by-one if they don't contribute significantly
      changed <- TRUE
      iteration <- 0
      while(changed && length(current_vars) > 0) {
        iteration <- iteration + 1
        changed <- FALSE

        # Add checkpoint at beginning of each iteration
        private$.checkpoint(flush=FALSE)

        # Only try to examine p-values if we have variables
        if (length(current_vars) > 0) {
          # Get model summary
          model_summary <- summary(current_model)

          # Check if we have coefficients
          if (!is.null(model_summary$coefficients)) {
            # Store p-values for each variable
            coef_summary <- model_summary$coefficients
            var_p_values <- coef_summary[, "Pr(>|z|)"]

            # Find least significant variable
            max_p <- max(var_p_values)
            if (max_p > pRemoval) {
              # Which variable has highest p-value
              drop_var_idx <- which.max(var_p_values)
              drop_var <- names(var_p_values)[drop_var_idx]

              # Remove this variable
              current_vars <- setdiff(current_vars, drop_var)
              removed_vars <- c(removed_vars, drop_var)

              # Update status with progress information
              status_msg <- paste0("Removing variable: ", drop_var,
                                   " (p=", format.pval(max_p, digits=3), ")")
              self$results$text2_model_selection$setContent(status_msg)

              # Critical checkpoint before expensive operation - always flush here
              private$.checkpoint()

              if (length(current_vars) > 0) {
                # Create new formula without this variable
                new_formula <- as.formula(paste(deparse(surv_part), "~",
                                                paste(current_vars, collapse = " + ")))

                # This is the most computationally expensive step
                current_model <- survival::coxph(new_formula, data = data)
              } else {
                # If no variables left, use null model
                current_model <- null_model
              }

              changed <- TRUE
            }
          }
        }

        # Add checkpoint after expensive operation to show progress
        # Only flush every 2nd iteration to balance responsiveness with performance
        if (iteration %% 2 == 0) {
          private$.checkpoint()
        }
      }

      # Final model is ready - set status to complete
      self$results$text_model_selection$setStatus('complete')
      self$results$text2_model_selection$setStatus('complete')

      # Final checkpoint to push complete results
      private$.checkpoint()

      # Store selection steps for reporting
      attr(current_model, "selection_steps") <- list(
        removed = removed_vars,
        remaining = current_vars
      )

      return(current_model)
    }

    # For forward selection
    else if (modelSelection == "forward") {
      # Start with no variables
      selected_vars <- character(0)
      current_model <- null_model
      added_vars <- character(0)

      # Set status to indicate forward selection is starting
      self$results$text_model_selection$setStatus('running')
      self$results$text2_model_selection$setStatus('running')

      private$.checkpoint()

      # Add variables one by one
      while (length(selected_vars) < length(pred_part)) {
        private$.checkpoint(flush=FALSE)

        best_var <- NULL
        best_p <- Inf
        best_model <- NULL

        # Try adding each remaining variable
        remaining_vars <- setdiff(pred_part, selected_vars)

        for (var in remaining_vars) {
          test_vars <- c(selected_vars, var)
          test_formula <- as.formula(paste(deparse(surv_part), "~",
                                           paste(test_vars, collapse = " + ")))

          tryCatch({
            test_model <- survival::coxph(test_formula, data = data)
            test_summary <- summary(test_model)

            if (!is.null(test_summary$coefficients)) {
              # Get p-value for the new variable
              var_p <- test_summary$coefficients[var, "Pr(>|z|)"]

              if (var_p < best_p) {
                best_p <- var_p
                best_var <- var
                best_model <- test_model
              }
            }
          }, error = function(e) {
            # Skip this variable if model fails
            NULL
          })
        }

        # Add the best variable if it meets criteria
        if (!is.null(best_var) && best_p < pEntry) {
          selected_vars <- c(selected_vars, best_var)
          added_vars <- c(added_vars, best_var)
          current_model <- best_model

          # Update status
          status_msg <- paste0("Adding variable: ", best_var,
                               " (p=", format.pval(best_p, digits=3), ")")
          self$results$text2_model_selection$setContent(status_msg)

          private$.checkpoint()
        } else {
          # No more variables meet criteria
          break
        }
      }

      # Final model is ready
      self$results$text_model_selection$setStatus('complete')
      self$results$text2_model_selection$setStatus('complete')
      private$.checkpoint()

      # Store selection steps for reporting
      attr(current_model, "selection_steps") <- list(
        added = added_vars,
        final = selected_vars
      )

      return(current_model)
    }

    # For stepwise (both directions)
    else if (modelSelection == "both") {
      # Use MASS::stepAIC for bidirectional selection
      if (requireNamespace("MASS", quietly = TRUE)) {
        # Set status
        self$results$text_model_selection$setStatus('running')
        self$results$text2_model_selection$setStatus('running')

        private$.checkpoint()

        # Use stepwise selection with AIC
        step_model <- MASS::stepAIC(full_model,
                                    scope = list(lower = null_model, upper = full_model),
                                    direction = "both",
                                    trace = 0)  # Silent operation

        # Final model is ready
        self$results$text_model_selection$setStatus('complete')
        self$results$text2_model_selection$setStatus('complete')
        private$.checkpoint()

        return(step_model)
      } else {
        # Fallback to backward selection if MASS not available
        return(private$.fitModelWithSelection(formula, data))
      }
    }

    # Default: return full model
    return(full_model)

  }, error = function(e) {
    # Set error status
    self$results$text_model_selection$setStatus('error')
    self$results$text2_model_selection$setContent(paste(.("Model selection error:"), e$message))

    # Return full model as fallback
    return(survival::coxph(formula, data = data))
  })
}

,
    ## Final Fit ----
.final_fit2 = function() {
  # Retrieve cleaned data and variable information
  cleaneddata <- private$.cleandata()

  # Extract necessary data components
  mydata <- cleaneddata$cleanData

  # Extract variable names
  myexplanatory <- NULL
  if (!is.null(self$options$explanatory)) {
    myexplanatory <- as.vector(cleaneddata$myexplanatory_labelled)
  }

  mycontexpl <- NULL
  if (!is.null(self$options$contexpl)) {
    mycontexpl <- as.vector(cleaneddata$mycontexpl_labelled)
  }

  # Prepare the formula for model fitting
  formula2 <- c(myexplanatory, mycontexpl)
  myformula <- paste("survival::Surv(mytime, myoutcome) ~ ", paste(formula2, collapse = " + "))
  myformula <- as.formula(myformula)


  private$.checkpoint()


  # Perform model selection
  model <- private$.fitModelWithSelection(myformula, mydata)

  private$.checkpoint()


  # Get model summary for statistics
  model_summary <- summary(model)


  # self$results$mydataview_modelselection$setContent(
  #   list(
  #     mydata = head(mydata),
  #     mytime = cleaneddata$name1time,
  #     myexplanatory = myexplanatory,
  #     mycontexpl = mycontexpl,
  #     myformula = myformula,
  #     model = model,
  #     use_modelSelection = self$options$use_modelSelection,
  #     modelSelection = self$options$modelSelection,
  #     selectionCriteria = self$options$selectionCriteria,
  #     pEntry = self$options$pEntry,
  #     pRemoval = self$options$pRemoval
  #   )
  #   )




  # Create metrics text with comprehensive error handling
  metrics_text <- tryCatch({
    # Calculate statistics safely
    logtest_value <- if(is.null(model_summary$logtest) || length(model_summary$logtest) < 1 ||
                        !is.numeric(model_summary$logtest[1])) {
      NA  # Use NA if logtest is missing or invalid
    } else {
      model_summary$logtest[1]
    }

    loglik_value <- if(is.null(model$loglik) || length(model$loglik) < 1 ||
                       !is.numeric(model$loglik[1])) {
      NA  # Use NA if loglik is missing or invalid
    } else {
      model$loglik[1]
    }

    # Calculate R-squared safely
    r_squared <- if(is.na(logtest_value) || is.na(model$n) || model$n == 0) {
      NA  # Use NA if we can't calculate
    } else {
      round(1 - exp(-logtest_value/model$n), 3)
    }

    # Calculate max possible R-squared safely
    max_r_squared <- if(is.na(loglik_value) || is.na(model$n) || model$n == 0) {
      NA  # Use NA if we can't calculate
    } else {
      round(1 - exp(-2 * loglik_value/model$n), 3)
    }

    # Format metrics text with safe fallbacks
    paste0(
      "Number in dataframe = ", nrow(mydata),
      ", Number in model = ", ifelse(is.null(model$n), "Unknown", model$n),
      ", Missing = 0",  # You might want to calculate this if needed
      ", Number of events = ", ifelse(is.null(model$nevent), "Unknown", model$nevent),
      ", Concordance = ", ifelse(is.null(model_summary$concordance) || length(model_summary$concordance) < 1,
                                 "Unknown", round(model_summary$concordance[1], 3)),
      " (SE = ", ifelse(is.null(model_summary$concordance) || length(model_summary$concordance) < 2,
                        "Unknown", round(model_summary$concordance[2], 3)), ")",
      ", R-squared = ", ifelse(is.na(r_squared), "Unknown", r_squared),
      "( Max possible = ", ifelse(is.na(max_r_squared), "Unknown", max_r_squared), ")",
      ", Likelihood ratio test = ", ifelse(is.na(logtest_value), "Unknown", round(logtest_value, 3)),
      " (df = ", ifelse(is.null(model_summary$logtest) || length(model_summary$logtest) < 2,
                        "Unknown", model_summary$logtest[2]),
      ", p = ", ifelse(is.null(model_summary$logtest) || length(model_summary$logtest) < 3,
                       "Unknown", format.pval(model_summary$logtest[3], digits=3)), ")"
    )
  }, error = function(e) {
    # Fallback metrics if calculation fails
    paste0(
      "Number in dataframe = ", nrow(mydata),
      ", Number in model = ", ifelse(is.null(model$n), "Unknown", model$n),
      ", Number of events = ", ifelse(is.null(model$nevent), "Unknown", model$nevent),
      ", Note: Some model metrics could not be calculated."
    )
  })

  # Create the base model metrics text
  text2_model_selection <- glue::glue("
    <br>
    <b>Model Metrics:</b><br>
    {metrics_text}
    <br>
  ")

  # Add landmark information if used
  if (self$options$uselandmark) {
    landmark <- jmvcore::toNumeric(self$options$landmark)

    text2_model_selection <- glue::glue(
      text2_model_selection,
      "Landmark time used as: ",
      landmark,
      " ",
      self$options$timetypeoutput,
      "."
    )
  }

  # Add selection results to the output - only once
  if (self$options$modelSelection != "enter") {
    # Safely extract coefficient names
    coef_names <- tryCatch({
      if (!is.null(model$coefficients) && length(model$coefficients) > 0) {
        paste(names(model$coefficients), collapse = ", ")
      } else {
        "None"
      }
    }, error = function(e) {
      "Unknown (error extracting coefficients)"
    })

    # Use the selection method directly from options
    selection_method <- self$options$modelSelection

    text2_model_selection <- paste0(
      text2_model_selection,
      "\n<br><b>Model Selection Results:</b><br>",
      "Selection method: ", selection_method,  # Use the actual selection method
      "<br>Selection criteria: ", self$options$selectionCriteria,
      "<br>Variables in final model: ", coef_names
    )

    # Add note about stepwise selection
    text2_model_selection <- paste0(
      text2_model_selection,
      "<br><br>Note: Stepwise selection methods should be used with caution. They may not always select the most theoretically meaningful model and can lead to overfitting."
    )
  }

  # Set the content for the model metrics
  self$results$text2_model_selection$setContent(text2_model_selection)

  # Create a formatted table of hazard ratios with error handling
  hr_table <- tryCatch({
    private$.createHRTable(model)
  }, error = function(e) {
    # Create a simple fallback table if the main function fails
    data.frame(
      Variable = "Error creating hazard ratio table",
      "HR (multivariable)" = paste("Error:", e$message)
    )
  })

  # Convert to HTML table and set content
  text_model_selection <- knitr::kable(
    hr_table,
    row.names = FALSE,
    align = c('l', 'l'),
    format = "html"
  )

  # Set the content for the HR table
  self$results$text_model_selection$setContent(text_model_selection)
}

,
# Helper function to create HR table with error handling
.createHRTable = function(model) {
  # If model has no coefficients, return empty table
  if (is.null(model$coefficients) || length(model$coefficients) == 0) {
    return(data.frame(
      Variable = "No variables in model",
      "HR (multivariable)" = "N/A"
    ))
  }

  # Get model summary
  summary_model <- summary(model)

  # Extract coefficients, hazard ratios, and CIs safely
  tryCatch({
    coefs <- summary_model$coefficients
    confint <- summary_model$conf.int

    # Create data frame with variable names and hazard ratios
    hr_table <- data.frame(
      Variable = row.names(coefs),
      HR = round(confint[, 1], 2),
      Lower_CI = round(confint[, 3], 2),
      Upper_CI = round(confint[, 4], 2),
      P_value = format.pval(coefs[, 5], digits = 3)
    )

    # Format the HR with CI
    hr_table$HR_with_CI <- paste0(
      hr_table$HR, " (",
      hr_table$Lower_CI, "-",
      hr_table$Upper_CI, ", p=",
      hr_table$P_value, ")"
    )

    # Return simplified table
    final_table <- data.frame(
      Variable = hr_table$Variable,
      "HR (multivariable)" = hr_table$HR_with_CI
    )

    return(final_table)
  }, error = function(e) {
    # If something goes wrong, return a basic table with the error
    return(data.frame(
      Variable = names(model$coefficients),
      "HR (multivariable)" = "Error calculating hazard ratios"
    ))
  })
}

      # Survival Decision Tree Function ----
      ,
      .survivalTree = function(results) {
        tryCatch({
          # Skip if tree analysis not requested
          if (!self$options$use_tree) {
            return(NULL)
          }

          # Check required packages
          if (!requireNamespace("rpart", quietly = TRUE)) {
            self$results$tree_summary$setContent(
              "<p>Error: The 'rpart' package is required for decision tree analysis but not available.</p>"
            )
            return(NULL)
          }

          # Get cleaned data
          cleanData <- results$cleanData
          # Use the standardized column names that actually exist in cleanData
          mytime <- "mytime"
          myoutcome <- "myoutcome"













          # Validate data
          if (is.null(cleanData) || nrow(cleanData) == 0) {
            self$results$tree_summary$setContent(
              "<p>Error: No data available for decision tree analysis.</p>"
            )
            return(NULL)
          }

          # Check if standardized columns exist
          if (!"mytime" %in% names(cleanData) || !"myoutcome" %in% names(cleanData)) {
            self$results$tree_summary$setContent(
              paste0("<p>Error: Required columns not found in cleaned data. Available columns: ",
                     paste(names(cleanData), collapse = ", "), "</p>")
            )
            return(NULL)
          }

          # Get explanatory variables
          expl_vars <- NULL
          if (!is.null(self$options$explanatory)) {
            expl_vars <- c(expl_vars, as.vector(results$myexplanatory_labelled))
          }
          if (!is.null(self$options$contexpl)) {
            expl_vars <- c(expl_vars, as.vector(results$mycontexpl_labelled))
          }

          # Check for explanatory variables
          if (length(expl_vars) == 0) {
            self$results$tree_summary$setContent(
              "<p>Error: At least one explanatory variable is required for decision tree analysis.</p>"
            )
            return(NULL)
          }

          # Validate that explanatory variables exist in data
          missing_vars <- setdiff(expl_vars, names(cleanData))
          if (length(missing_vars) > 0) {
            self$results$tree_summary$setContent(
              paste0("<p>Error: Variables not found in data: ", paste(missing_vars, collapse = ", "), "</p>")
            )
            return(NULL)
          }

          private$.checkpoint()

          # Create formula for rpart using the actual column names from results
          formula_string <- paste("survival::Surv(", mytime, ", ", myoutcome, ") ~ ",
                                   paste(expl_vars, collapse = " + "))
          formula <- as.formula(formula_string)

          # Validate minimum parameters
          min_node <- max(1, self$options$min_node)
          complexity <- max(0.001, self$options$complexity)
          max_depth <- max(1, min(30, self$options$max_depth))

          # Fit survival tree using rpart with error handling
          tree <- tryCatch({
            rpart::rpart(
              formula = formula,
              data = cleanData,
              method = "exp",  # exponential survival model
              control = rpart::rpart.control(
                minsplit = 2 * min_node,
                minbucket = min_node,
                cp = complexity,
                maxdepth = max_depth
              )
            )
          }, error = function(e) {
            NULL
          })

          # Create summary text
          if (is.null(tree) || nrow(tree$frame) == 0) {
            tree_text <- paste0(
              "<h3>Survival Decision Tree Results</h3>",
              "<p><strong>The survival tree could not be built with the current parameters.</strong></p>",
              "<p>This may be due to:</p>",
              "<ul>",
              "<li>Insufficient data for the specified minimum node size</li>",
              "<li>Complexity parameter too high</li>",
              "<li>Variables not providing meaningful splits</li>",
              "</ul>",
              "<p>Try adjusting the parameters:</p>",
              "<ul>",
              "<li>Reduce minimum node size</li>",
              "<li>Lower complexity parameter</li>",
              "<li>Include more variables</li>",
              "</ul>"
            )
          } else {
            # Get variable importance
            var_imp <- tree$variable.importance
            if (!is.null(var_imp) && length(var_imp) > 0) {
              var_imp_df <- data.frame(
                Variable = names(var_imp),
                Importance = var_imp,
                stringsAsFactors = FALSE
              )
              var_imp_df <- var_imp_df[order(-var_imp_df$Importance), ]

              var_imp_html <- paste(
                "<tr>",
                "<td>", var_imp_df$Variable, "</td>",
                "<td>", round(var_imp_df$Importance, 2), "</td>",
                "</tr>",
                collapse = ""
              )

              var_imp_table <- paste0(
                "<table class='jmv-results-table'>",
                "<thead><tr><th>Variable</th><th>Importance</th></tr></thead>",
                "<tbody>", var_imp_html, "</tbody>",
                "</table>"
              )
            } else {
              var_imp_table <- "<p>No variable importance measures available.</p>"
            }

            # Get tree statistics
            n_terminal <- sum(tree$frame$var == "<leaf>")
            n_splits <- nrow(tree$frame) - 1

            tree_text <- paste0(
              "<h3>Survival Decision Tree Results</h3>",
              "<p>The decision tree was successfully built with the following characteristics:</p>",
              "<ul>",
              "<li><strong>Terminal nodes:</strong> ", n_terminal, "</li>",
              "<li><strong>Internal splits:</strong> ", n_splits, "</li>",
              "<li><strong>Variables used:</strong> ", length(unique(tree$frame$var[tree$frame$var != "<leaf>"])), "</li>",
              "</ul>",
              "<p><strong>Parameters used:</strong></p>",
              "<ul>",
              "<li>Complexity parameter: ", complexity, "</li>",
              "<li>Minimum node size: ", min_node, "</li>",
              "<li>Maximum depth: ", max_depth, "</li>",
              "</ul>",
              "<h4>Variable Importance</h4>",
              var_imp_table,
              "<p><i>Note: The decision tree plot visualizes how the variables split the data into groups with different survival outcomes.</i></p>"
            )
          }

          self$results$tree_summary$setContent(tree_text)

          # Store tree for plotting
          return(tree)

        }, error = function(e) {
          error_msg <- private$.formatErrorMessage(
            "Survival Decision Tree Error",
            paste("An error occurred while building the decision tree:", e$message),
            "<li>Check that you have sufficient data for tree building</li><li>Try reducing the minimum node size</li><li>Ensure your variables contain valid data</li>"
          )
          self$results$tree_summary$setContent(error_msg)
          return(NULL)
        })
      }

      # Plot Tree ----
      ,
      .plotTree = function(image, ggtheme, theme, ...) {
        tryCatch({
          # Skip if tree analysis not requested
          if (!self$options$use_tree) {
            return(FALSE)
          }

          # Check required packages
          if (!requireNamespace("rpart.plot", quietly = TRUE)) {
            return(FALSE)
          }

          # Get results and tree
          results <- private$.cleandata()
          tree <- private$.survivalTree(results)

          if (is.null(tree) || nrow(tree$frame) == 0) {
            return(FALSE)
          }

            self$results$mydataview_survivaldecisiontree$setContent(
    list(
      results = results,
      tree = tree
    )
  )


          # Add checkpoint before plotting
          private$.checkpoint()

          # Plot tree with error handling
          rpart.plot::rpart.plot(
            tree,
            main = "Survival Decision Tree",
            extra = 101,  # show fitted risk and percentage of observations
            box.palette = "auto",  # color by fitted risk
            shadow.col = "gray",  # add shadows to the boxes
            nn = TRUE,  # show node numbers
            fallen.leaves = TRUE,  # align leaf nodes
            roundint = FALSE,  # don't round integers
            cex = 0.8,  # text size
            clip.right.labs = FALSE  # don't clip labels
          )

          return(TRUE)

        }, error = function(e) {
          # Report tree plotting error for debugging
          self$results$tree_summary$setContent(
            paste0("<p>Tree plotting error: ", e$message, "</p>")
          )
          return(FALSE)
        })
      }

      # Plot Node Survival ----
      ,
      .plotNodeSurvival = function(image, ggtheme, theme, ...) {
        tryCatch({
          # Skip if not requested
          if (!self$options$use_tree || !self$options$show_terminal_nodes) {
            return(FALSE)
          }

          # Check required packages
          if (!requireNamespace("survminer", quietly = TRUE)) {
            return(FALSE)
          }

          # Get results and tree
          results <- private$.cleandata()
          message("Node survival: results obtained, cleanData columns: ", paste(names(results$cleanData), collapse = ", "))
          tree <- private$.survivalTree(results)
          message("Node survival: tree obtained")

          if (is.null(tree) || nrow(tree$frame) == 0) {
            return(FALSE)
          }

          # Get cleaned data
          cleanData <- results$cleanData
          # Use the standardized column names that actually exist in cleanData
          mytime <- "mytime"
          myoutcome <- "myoutcome"

          # Validate data
          if (is.null(cleanData) || nrow(cleanData) == 0) {
            return(FALSE)
          }

          # Add checkpoint before plotting
          private$.checkpoint()

          # Get terminal node assignments for each observation
          message("Node survival: getting node assignments")
          node_assignments <- tree$where
          cleanData$node <- paste("Node", node_assignments)
          message("Node survival: node assignments created, unique nodes: ", length(unique(cleanData$node)))

          # Check if we have at least 2 nodes
          unique_nodes <- unique(cleanData$node)
          if (length(unique_nodes) < 2) {
            message("Node survival: insufficient nodes (", length(unique_nodes), ")")
            return(FALSE)
          }

          # Plot survival curves for each terminal node
          # Check that required columns exist
          if (!"mytime" %in% names(cleanData)) {
            message("Error: mytime column not found in cleanData")
            return(FALSE)
          }
          if (!"myoutcome" %in% names(cleanData)) {
            message("Error: myoutcome column not found in cleanData")
            return(FALSE)
          }

          # Create formula properly
          message("Node survival: creating formula with proper syntax")
          formula <- as.formula("Surv(mytime, myoutcome) ~ node")
          message("Node survival: formula created: ", deparse(formula))

          message("Node survival: calling survfit")
          fit <- survival::survfit(formula, data = cleanData)
          message("Node survival: survfit completed")

          message("Node survival: trying minimal ggsurvplot call")

          # Try the most minimal ggsurvplot call possible
          plot <- survminer::ggsurvplot(
            fit,
            data = cleanData
          )

          message("Node survival: minimal ggsurvplot completed, printing")
          print(plot)
          message("Node survival: plot printed successfully")
          return(TRUE)

        }, error = function(e) {
          # Report node survival plotting error for debugging
          message("Node survival plotting error: ", e$message)
          return(FALSE)
        })

        # Educational Explanations ----
        if (self$options$showExplanations) {
          private$.addExplanations()
        }
      }

      # Convert Wide Format to Long Format for Time-Dependent Covariates ----
      ,
      .convertWideToLong = function(mydata, time_dep_vars, all_labels) {

        # Get change time points with input sanitization
        change_times <- private$.sanitizeStringInput(
          self$options$change_times,
          private$DEFAULT_CHANGE_TIMES,
          "^[0-9., ]+$"  # Only numbers, commas, periods, spaces
        )

        # Parse change times
        time_points <- tryCatch({
          as.numeric(trimws(strsplit(change_times, ",")[[1]]))
        }, error = function(e) {
          as.numeric(trimws(strsplit(private$DEFAULT_CHANGE_TIMES, ",")[[1]]))
        })
        time_points <- sort(time_points[!is.na(time_points)])

        # Get suffix pattern with input sanitization
        suffix_pattern <- private$.sanitizeStringInput(
          self$options$td_suffix_pattern,
          private$DEFAULT_TD_SUFFIX,
          "^[a-zA-Z0-9_{}]+$"  # Only alphanumeric, underscore, braces
        )

        # Initialize long format data
        long_data <- data.frame()

        for (i in 1:nrow(mydata)) {
          subject_data <- mydata[i, ]

          # Get subject's total follow-up time
          total_time <- subject_data$mytime

          # Create time intervals: 0, change_times, total_time
          intervals <- c(0, time_points[time_points < total_time], total_time)
          intervals <- unique(sort(intervals))

          # If subject has very short follow-up, create just one interval
          if (length(intervals) < 2) {
            intervals <- c(0, total_time)
          }

          # Create rows for each interval
          for (j in 1:(length(intervals)-1)) {
            tstart <- intervals[j]
            tstop <- intervals[j+1]

            # Status is 1 only in the last interval if subject has event
            status <- ifelse(j == (length(intervals)-1), subject_data$myoutcome, 0)

            # Create new row
            new_row <- subject_data
            new_row$tstart <- tstart
            new_row$tstop <- tstop
            new_row$myoutcome <- status

            # Update time-dependent variables for this interval
            for (var in time_dep_vars) {

              # Determine which time-dependent version to use
              if (tstart == 0) {
                # Use baseline version for first interval
                baseline_var <- paste0(var, "_baseline")
                if (baseline_var %in% names(mydata)) {
                  new_row[[var]] <- subject_data[[baseline_var]]
                } else {
                  # If no baseline version, use the base variable
                  new_row[[var]] <- subject_data[[var]]
                }
              } else {
                # Find appropriate time-dependent version
                applicable_times <- time_points[time_points <= tstart]
                if (length(applicable_times) > 0) {
                  use_time <- max(applicable_times)
                  td_var_name <- gsub("\\{time\\}", use_time, suffix_pattern)
                  full_var_name <- paste0(var, td_var_name)

                  if (full_var_name %in% names(mydata)) {
                    new_row[[var]] <- subject_data[[full_var_name]]
                  } else {
                    # Fall back to previous value or baseline
                    new_row[[var]] <- subject_data[[var]]
                  }
                } else {
                  # Use baseline if no applicable time found
                  new_row[[var]] <- subject_data[[var]]
                }
              }
            }

            long_data <- rbind(long_data, new_row)
          }
        }

        return(long_data)
      }

      # Educational Explanations ----
      ,
      .addExplanations = function() {
        # Helper function to set explanation content
        private$.setExplanationContent <- function(result_name, content) {
          tryCatch({
            self$results[[result_name]]$setContent(content)
          }, error = function(e) {
            # Silently ignore if result doesn't exist
          })
        }

        # Multivariable Cox Regression Explanation
        private$.setExplanationContent("multivariableCoxExplanation", '
        <div class="explanation-box" style="background-color: #f0f8ff; padding: 15px; border-radius: 8px; margin: 10px 0;">
            <h3 style="color: #2c5282; margin-top: 0;">üî¨ Understanding Multivariable Cox Regression</h3>

            <div style="background-color: white; padding: 12px; border-radius: 5px; margin: 10px 0;">
                <h4 style="color: #2d3748; margin-top: 0;">What is Multivariable Survival Analysis?</h4>
                <p style="margin: 8px 0;">Multivariable Cox regression analyzes <strong>multiple risk factors simultaneously</strong> to identify which factors independently affect survival when all others are held constant.</p>

                <div style="background-color: #e6f7ff; padding: 10px; border-radius: 5px; margin: 10px 0;">
                    <strong>üéØ Key Advantage:</strong> Separates the <strong>independent effect</strong> of each variable from the effects of other variables
                </div>
            </div>

            <div style="background-color: #fef5e7; padding: 12px; border-radius: 5px; margin: 10px 0;">
                <h4 style="color: #d68910; margin-top: 0;">üìä Adjusted vs Unadjusted Hazard Ratios</h4>
                <table style="width: 100%; border-collapse: collapse; margin: 10px 0;">
                    <tr style="background-color: #fff3cd;">
                        <th style="padding: 8px; text-align: left; border: 1px solid #ffc107;">Type</th>
                        <th style="padding: 8px; text-align: left; border: 1px solid #ffc107;">What It Shows</th>
                        <th style="padding: 8px; text-align: left; border: 1px solid #ffc107;">Clinical Use</th>
                    </tr>
                    <tr>
                        <td style="padding: 8px; border: 1px solid #ffc107;"><strong>Unadjusted HR</strong></td>
                        <td style="padding: 8px; border: 1px solid #ffc107;">Raw association with survival</td>
                        <td style="padding: 8px; border: 1px solid #ffc107;">Initial screening of factors</td>
                    </tr>
                    <tr style="background-color: #fffbf0;">
                        <td style="padding: 8px; border: 1px solid #ffc107;"><strong>Adjusted HR</strong></td>
                        <td style="padding: 8px; border: 1px solid #ffc107;">Independent effect after controlling for other variables</td>
                        <td style="padding: 8px; border: 1px solid #ffc107;">True prognostic value</td>
                    </tr>
                </table>
            </div>

            <div style="background-color: #e8f5e9; padding: 12px; border-radius: 5px; margin: 10px 0;">
                <h4 style="color: #2e7d32; margin-top: 0;">üí° Clinical Examples</h4>

                <div style="background-color: white; padding: 10px; border-radius: 5px; margin: 10px 0;">
                    <strong>Example: Cancer Survival Model</strong>
                    <p style="margin: 8px 0;"><strong>Variables:</strong> Age, Stage, Grade, Treatment</p>
                    <table style="width: 100%; margin: 5px 0;">
                        <tr><td><strong>Age:</strong></td><td>Adjusted HR = 1.02 (p=0.01)</td></tr>
                        <tr><td><strong>Stage III vs I:</strong></td><td>Adjusted HR = 2.5 (p<0.001)</td></tr>
                        <tr><td><strong>High grade:</strong></td><td>Adjusted HR = 1.8 (p=0.003)</td></tr>
                        <tr><td><strong>Treatment B:</strong></td><td>Adjusted HR = 0.7 (p=0.02)</td></tr>
                    </table>
                    <p style="margin: 8px 0;"><strong>Interpretation:</strong> Stage is the strongest independent predictor, even after accounting for age, grade, and treatment.</p>
                </div>

                <div style="background-color: #f3e5f5; padding: 10px; border-radius: 5px; margin: 10px 0;">
                    <strong>üîç Confounding Example:</strong>
                    <ul style="margin: 5px 0; padding-left: 20px;">
                        <li><strong>Unadjusted:</strong> Age HR = 1.05 (appears strongly associated)</li>
                        <li><strong>Adjusted for stage:</strong> Age HR = 1.01 (much weaker effect)</li>
                        <li><strong>Reason:</strong> Older patients tend to have more advanced disease</li>
                    </ul>
                </div>
            </div>

            <div style="background-color: #e3f2fd; padding: 12px; border-radius: 5px; margin: 10px 0;">
                <h4 style="color: #1976d2; margin-top: 0;">üéØ Model Building Strategy</h4>
                <div style="background-color: white; padding: 10px; border-radius: 5px; margin: 10px 0;">
                    <strong>1. Variable Selection:</strong>
                    <ul style="margin: 5px 0; padding-left: 20px;">
                        <li>Include clinically important variables</li>
                        <li>Consider statistical significance (p<0.05 or p<0.1)</li>
                        <li>Check for multicollinearity</li>
                    </ul>

                    <strong>2. Model Assessment:</strong>
                    <ul style="margin: 5px 0; padding-left: 20px;">
                        <li>Concordance index (C-index): >0.7 indicates good discrimination</li>
                        <li>Proportional hazards assumption testing</li>
                        <li>Model calibration assessment</li>
                    </ul>
                </div>
            </div>

            <div style="background-color: #fff3e0; padding: 10px; border-radius: 5px; margin-top: 10px; border-left: 4px solid #ff9800;">
                <strong>üí° Clinical Applications:</strong>
                <ul style="margin: 5px 0; padding-left: 20px;">
                    <li><strong>Prognostic models:</strong> Identify independent risk factors</li>
                    <li><strong>Treatment decisions:</strong> Assess benefit after controlling for confounders</li>
                    <li><strong>Risk stratification:</strong> Combine multiple factors into risk scores</li>
                    <li><strong>Research:</strong> Control for baseline differences between groups</li>
                </ul>
            </div>
        </div>
        ')

        # Adjusted Survival Curves Explanation
        private$.setExplanationContent("adjustedSurvivalExplanation", '
        <div style="margin-bottom: 20px; padding: 15px; background-color: #d1ecf1; border-left: 4px solid #bee5eb;">
            <h4 style="margin-top: 0; color: #2c3e50;">Understanding Adjusted Survival Curves</h4>
            <p><strong>Adjusted Curves:</strong> Survival curves that account for differences in patient characteristics between groups.</p>
            <ul>
                <li><strong>Covariate Adjustment:</strong> Controls for confounding variables that might bias group comparisons</li>
                <li><strong>Average Patient:</strong> Shows survival for a typical patient with average covariate values</li>
                <li><strong>True Group Effect:</strong> Isolates the effect of the grouping variable from other factors</li>
                <li><strong>Fair Comparison:</strong> Enables valid comparisons between groups with different baseline characteristics</li>
            </ul>
            <p><em>When to use:</em> Essential when comparing groups that differ in important prognostic factors.</p>
        </div>
        ')

        # Risk Score Analysis Explanation
        private$.setExplanationContent("riskScoreExplanation", '
        <div style="margin-bottom: 20px; padding: 15px; background-color: #fff3cd; border-left: 4px solid #ffc107;">
            <h4 style="margin-top: 0; color: #2c3e50;">Understanding Risk Score Analysis</h4>
            <p><strong>Risk Scoring:</strong> Combines multiple prognostic factors into a single risk prediction score.</p>
            <ul>
                <li><strong>Linear Predictor:</strong> Weighted sum of all variables in the Cox model</li>
                <li><strong>Risk Stratification:</strong> Divides patients into low, intermediate, and high-risk groups</li>
                <li><strong>Prognostic Tool:</strong> Single score that summarizes overall patient risk</li>
                <li><strong>Clinical Utility:</strong> Facilitates treatment decisions and patient counseling</li>
            </ul>
            <p><em>Advantage:</em> Simplifies complex multivariable models into an easily interpretable risk score.</p>
        </div>
        ')

        # Nomogram Explanation
        private$.setExplanationContent("nomogramExplanation", '
        <div style="margin-bottom: 20px; padding: 15px; background-color: #f8d7da; border-left: 4px solid #dc3545;">
            <h4 style="margin-top: 0; color: #721c24;">Understanding Nomograms</h4>
            <p><strong>Nomogram:</strong> Graphical calculation tool that translates regression models into visual risk calculators.</p>
            <ul>
                <li><strong>Point System:</strong> Each predictor contributes points based on its value and hazard ratio</li>
                <li><strong>Total Points:</strong> Sum of individual points provides overall risk score</li>
                <li><strong>Survival Probability:</strong> Converts total points to predicted survival at specific time points</li>
                <li><strong>Clinical Tool:</strong> Enables bedside risk calculation without complex mathematics</li>
            </ul>
            <p><em>Clinical application:</em> Allows clinicians to quickly estimate individual patient survival probabilities.</p>
        </div>
        ')

        # Person-Time Analysis Explanation
        private$.setExplanationContent("personTimeExplanation", '
        <div style="margin-bottom: 20px; padding: 15px; background-color: #d4edda; border-left: 4px solid #28a745;">
            <h4 style="margin-top: 0; color: #2c3e50;">Understanding Person-Time Analysis</h4>
            <p><strong>Person-Time:</strong> Comprehensive measure combining participant count and observation duration.</p>
            <ul>
                <li><strong>Incidence Rates:</strong> Events per person-time unit across different time intervals</li>
                <li><strong>Time-Stratified Analysis:</strong> Examines how event rates change over follow-up time</li>
                <li><strong>Group Comparisons:</strong> Compares incidence rates between different risk groups</li>
                <li><strong>Rate Ratios:</strong> Quantifies relative differences in event rates between groups</li>
            </ul>
            <p><em>Clinical insight:</em> Reveals patterns of risk over time and identifies periods of highest event rates.</p>
        </div>
        ')

        # Stratified Analysis Explanation
        private$.setExplanationContent("stratifiedAnalysisExplanation", '
        <div style="margin-bottom: 20px; padding: 15px; background-color: #e2e3e5; border-left: 4px solid #6c757d;">
            <h4 style="margin-top: 0; color: #2c3e50;">Understanding Stratified Cox Regression</h4>
            <p><strong>Stratification:</strong> Allows different baseline hazards for distinct patient subgroups while estimating common covariate effects.</p>
            <ul>
                <li><strong>Heterogeneous Baseline Risk:</strong> Accounts for fundamentally different risk levels between strata</li>
                <li><strong>Common Covariate Effects:</strong> Assumes treatment/predictor effects are similar across strata</li>
                <li><strong>Improved Model Fit:</strong> Better accommodates population heterogeneity</li>
                <li><strong>Robust Estimates:</strong> Provides more accurate hazard ratios when baseline risks differ</li>
            </ul>
            <p><em>When to use:</em> When proportional hazards assumption is violated due to different baseline hazards between groups.</p>
        </div>
        ')

        # Survival Plots Explanation
        private$.setExplanationContent("survivalPlotsExplanation", '
        <div class="explanation-box" style="background-color: #f9f9f9; padding: 15px; border-radius: 8px; margin: 10px 0;">
            <h3 style="color: #2c5282; margin-top: 0;">üìä Understanding Adjusted Survival Curves and Hazard Ratio Plots</h3>

            <div style="background-color: #e8f5e9; padding: 12px; border-radius: 5px; margin: 10px 0;">
                <h4 style="color: #2e7d32; margin-top: 0;">üéØ Adjusted Survival Curves</h4>
                <p style="margin: 8px 0;">Adjusted survival curves show survival probabilities after <strong>controlling for confounding variables</strong>, providing a fair comparison between groups.</p>

                <div style="background-color: white; padding: 10px; border-radius: 5px; margin: 10px 0;">
                    <strong>Key Features:</strong>
                    <ul style="margin: 5px 0; padding-left: 20px;">
                        <li><strong>Covariate-adjusted:</strong> Controls for differences in patient characteristics</li>
                        <li><strong>Population-averaged:</strong> Shows survival for typical patients with average risk factors</li>
                        <li><strong>Isolates group effect:</strong> Separates the true effect of the grouping variable</li>
                        <li><strong>Clinical relevance:</strong> Provides realistic survival estimates for clinical decision-making</li>
                    </ul>
                </div>

                <div style="background-color: #e3f2fd; padding: 10px; border-radius: 5px; margin: 10px 0;">
                    <strong>üìà Interpretation Guide:</strong>
                    <table style="width: 100%; border-collapse: collapse; margin: 5px 0;">
                        <tr style="background-color: #bbdefb;">
                            <th style="padding: 8px; text-align: left; border: 1px solid #2196f3;">Curve Pattern</th>
                            <th style="padding: 8px; text-align: left; border: 1px solid #2196f3;">Clinical Meaning</th>
                        </tr>
                        <tr>
                            <td style="padding: 8px; border: 1px solid #2196f3;">Steep early decline</td>
                            <td style="padding: 8px; border: 1px solid #2196f3;">High early mortality risk</td>
                        </tr>
                        <tr style="background-color: #f3f8ff;">
                            <td style="padding: 8px; border: 1px solid #2196f3;">Plateau phase</td>
                            <td style="padding: 8px; border: 1px solid #2196f3;">Stable survival period with low event rate</td>
                        </tr>
                        <tr>
                            <td style="padding: 8px; border: 1px solid #2196f3;">Wide confidence bands</td>
                            <td style="padding: 8px; border: 1px solid #2196f3;">Uncertainty due to small sample size or high censoring</td>
                        </tr>
                    </table>
                </div>
            </div>

            <div style="background-color: #fff3e0; padding: 12px; border-radius: 5px; margin: 10px 0;">
                <h4 style="color: #d68910; margin-top: 0;">üéØ Hazard Ratio (Forest) Plots</h4>
                <p style="margin: 8px 0;">Forest plots visualize <strong>hazard ratios and confidence intervals</strong> for multiple variables simultaneously, enabling quick assessment of relative risk factors.</p>

                <div style="background-color: white; padding: 10px; border-radius: 5px; margin: 10px 0;">
                    <strong>Reading Forest Plots:</strong>
                    <ul style="margin: 5px 0; padding-left: 20px;">
                        <li><strong>Vertical line at HR=1:</strong> Line of no effect (reference)</li>
                        <li><strong>Points to the right (HR>1):</strong> Increased hazard (worse survival)</li>
                        <li><strong>Points to the left (HR<1):</strong> Decreased hazard (better survival)</li>
                        <li><strong>Horizontal lines:</strong> 95% confidence intervals for each HR</li>
                        <li><strong>Crossing HR=1:</strong> Non-significant effect (p>0.05)</li>
                    </ul>
                </div>

                <div style="background-color: #fef5e7; padding: 10px; border-radius: 5px; margin: 10px 0;">
                    <strong>üîç Clinical Example - Cancer Study:</strong>
                    <table style="width: 100%; margin: 5px 0;">
                        <tr><td><strong>Age (per year):</strong></td><td>HR = 1.02 [0.99-1.05] ‚Üí Minimal age effect</td></tr>
                        <tr><td><strong>Stage III vs I:</strong></td><td>HR = 3.2 [2.1-4.8] ‚Üí Strong predictor of poor survival</td></tr>
                        <tr><td><strong>Treatment B vs A:</strong></td><td>HR = 0.6 [0.4-0.9] ‚Üí Protective treatment effect</td></tr>
                    </table>
                </div>
            </div>

            <div style="background-color: #e6f7ff; padding: 12px; border-radius: 5px; margin: 10px 0;">
                <h4 style="color: #1976d2; margin-top: 0;">‚öïÔ∏è Clinical Applications</h4>

                <div style="background-color: white; padding: 10px; border-radius: 5px; margin: 10px 0;">
                    <strong>1. Treatment Comparison:</strong>
                    <ul style="margin: 5px 0; padding-left: 20px;">
                        <li>Adjusted curves eliminate confounding by patient characteristics</li>
                        <li>Shows true treatment effect independent of baseline differences</li>
                        <li>Critical for observational studies with treatment selection bias</li>
                    </ul>

                    <strong>2. Prognostic Modeling:</strong>
                    <ul style="margin: 5px 0; padding-left: 20px;">
                        <li>Identifies independent risk factors from forest plots</li>
                        <li>Quantifies relative importance of different predictors</li>
                        <li>Builds comprehensive prognostic models</li>
                    </ul>

                    <strong>3. Risk Stratification:</strong>
                    <ul style="margin: 5px 0; padding-left: 20px;">
                        <li>Combines multiple risk factors for patient classification</li>
                        <li>Guides treatment intensity decisions</li>
                        <li>Enables personalized survival predictions</li>
                    </ul>
                </div>
            </div>

            <div style="background-color: #f3e5f5; padding: 10px; border-radius: 5px; margin-top: 10px; border-left: 4px solid #9c27b0;">
                <strong>üí° Best Practices:</strong>
                <ul style="margin: 5px 0; padding-left: 20px;">
                    <li><strong>Always report confidence intervals:</strong> Shows precision of estimates</li>
                    <li><strong>Check proportional hazards:</strong> Ensure model assumptions are met</li>
                    <li><strong>Consider clinical significance:</strong> Statistical significance ‚â† clinical importance</li>
                    <li><strong>Validate findings:</strong> Test models in independent populations when possible</li>
                </ul>
            </div>
        </div>
        ')
      }

      # Machine Learning Methods ----

      ,

.runMLAnalysis = function() {
        tryCatch({
          cleaneddata <- private$.cleandata()

          # Check for required packages
          if (self$options$ml_method == "rsf" && !requireNamespace("randomForestSRC", quietly = TRUE)) {
            self$results$ml_performance_metrics$setContent(.("randomForestSRC package not available. Please install it to use Random Survival Forest."))
            return()
          }

          if (self$options$ml_method == "glmnet" && !requireNamespace("glmnet", quietly = TRUE)) {
            self$results$ml_performance_metrics$setContent(.("glmnet package not available. Please install it to use regularized regression."))
            return()
          }

          if (self$options$ml_method == "xgboost" && !requireNamespace("xgboost", quietly = TRUE)) {
            self$results$ml_performance_metrics$setContent(.("xgboost package not available. Please install it to use XGBoost survival models."))
            return()
          }

          if (self$options$ml_method == "svm" && !requireNamespace("survivalsvm", quietly = TRUE)) {
            self$results$ml_performance_metrics$setContent(.("survivalsvm package not available. Please install it to use SVM survival analysis."))
            return()
          }

          # Select ML method
          if (self$options$ml_method == "rsf") {
            private$.performRandomForest(cleaneddata)
          } else if (self$options$ml_method == "glmnet") {
            private$.performGlmnet(cleaneddata)
          } else if (self$options$ml_method == "xgboost") {
            private$.performXGBoost(cleaneddata)
          } else if (self$options$ml_method == "svm") {
            private$.performSVM(cleaneddata)
          } else if (self$options$ml_method == "deepsurv") {
            private$.performDeepSurvival(cleaneddata)
          } else if (self$options$ml_method == "ensemble") {
            private$.performEnsemble(cleaneddata)
          }

          # Feature selection if requested
          if (self$options$ml_feature_selection) {
            private$.performFeatureSelection(cleaneddata)
          }

          # Cross-validation if requested
          if (self$options$ml_validation == "cv" && self$options$ml_method != "none") {
            private$.performCrossValidation(cleaneddata)
          }

          # SHAP values if requested
          if (self$options$ml_shap && self$options$ml_method %in% c("rsf", "xgboost")) {
            private$.calculateSHAPValues(cleaneddata)
          }

          # Performance metrics if requested
          if (self$options$ml_performance) {
            private$.calculateMLPerformanceMetrics(cleaneddata)
          }

        }, error = function(e) {
          error_msg <- glue::glue("Error in ML analysis: {e$message}")
          self$results$ml_performance_metrics$setContent(error_msg)
        })
      }

      ,
.performRandomForest = function(cleaneddata) {
        # Random Forest survival analysis
        formula_vars <- private$.prepareMLFormula(cleaneddata)

        tryCatch({
          # Fit Random Forest
          rf_model <- randomForestSRC::rfsrc(
            formula = formula_vars$formula,
            data = cleaneddata,
            ntree = 1000,
            importance = TRUE,
            proximity = TRUE
          )

          # Variable importance
          var_imp <- rf_model$importance
          private$.populateVariableImportance(var_imp)

          # Performance metrics
          oob_error <- rf_model$err.rate[length(rf_model$err.rate)]
          c_index <- 1 - oob_error

          metrics_html <- paste0(
            "<h4>", .("Random Forest Survival Model Results"), "</h4>",
            "<p><strong>", .("Out-of-Bag Error Rate:"), "</strong> ", round(oob_error, 4), "</p>",
            "<p><strong>", .("Concordance Index:"), "</strong> ", round(c_index, 4), "</p>",
            "<p><strong>", .("Number of Trees:"), "</strong> ", rf_model$ntree, "</p>",
            "<p><strong>", .("Variables Used:"), "</strong> ", length(formula_vars$variables), "</p>"
          )

          self$results$ml_performance_metrics$setContent(metrics_html)

          # Prediction intervals
          predictions <- predict(rf_model, newdata = cleaneddata)
          private$.populatePredictionIntervals(predictions, cleaneddata)

        }, error = function(e) {
          error_msg <- glue::glue("Random Forest error: {e$message}")
          self$results$ml_performance_metrics$setContent(error_msg)
        })
      }

      ,
.performGlmnet = function(cleaneddata) {
        # Regularized Cox regression with cross-validation
        formula_vars <- private$.prepareMLFormula(cleaneddata)

        tryCatch({
          # Prepare data for glmnet
          x <- model.matrix(formula_vars$formula, data = cleaneddata)[,-1]
          y <- survival::Surv(cleaneddata$mytime, cleaneddata$myoutcome)

          # Cross-validated glmnet
          cv_fit <- glmnet::cv.glmnet(x, y, family = "cox", alpha = 0.5, nfolds = self$options$ml_cv_folds)

          # Best lambda
          best_lambda <- cv_fit$lambda.min

          # Final model coefficients
          coefs <- coef(cv_fit, s = "lambda.min")
          selected_vars <- which(coefs != 0)

          # Performance metrics
          c_index <- max(cv_fit$glmnet.fit$dev.ratio)

          metrics_html <- paste0(
            "<h4>", .("Regularized Cox Regression Results"), "</h4>",
            "<p><strong>", .("Best Lambda:"), "</strong> ", round(best_lambda, 6), "</p>",
            "<p><strong>", .("Selected Variables:"), "</strong> ", length(selected_vars), " out of ", ncol(x), "</p>",
            "<p><strong>", .("Deviance Explained:"), "</strong> ", round(c_index * 100, 2), "%</p>",
            "<p><strong>", .("Cross-Validation Folds:"), "</strong> ", self$options$ml_cv_folds, "</p>"
          )

          self$results$ml_performance_metrics$setContent(metrics_html)

          # Variable importance from coefficients
          if (length(selected_vars) > 0) {
            var_names <- rownames(coefs)[selected_vars]
            var_coefs <- as.numeric(coefs[selected_vars])
            var_imp <- abs(var_coefs)
            names(var_imp) <- var_names
            private$.populateVariableImportance(var_imp)
          }

        }, error = function(e) {
          error_msg <- glue::glue("Glmnet error: {e$message}")
          self$results$ml_performance_metrics$setContent(error_msg)
        })
      }

      ,
.performEnsemble = function(cleaneddata) {
        # Ensemble of multiple methods
        tryCatch({
          ensemble_results <- list()

          # Random Forest component
          if (requireNamespace("randomForestSRC", quietly = TRUE)) {
            formula_vars <- private$.prepareMLFormula(cleaneddata)
            rf_model <- randomForestSRC::rfsrc(
              formula = formula_vars$formula,
              data = cleaneddata,
              ntree = 500,
              importance = TRUE
            )
            ensemble_results$rf <- rf_model
          }

          # Cox regression component
          cox_model <- private$.cox_model()
          ensemble_results$cox <- cox_model

          # Glmnet component
          if (requireNamespace("glmnet", quietly = TRUE)) {
            formula_vars <- private$.prepareMLFormula(cleaneddata)
            x <- model.matrix(formula_vars$formula, data = cleaneddata)[,-1]
            y <- survival::Surv(cleaneddata$mytime, cleaneddata$myoutcome)
            glmnet_model <- glmnet::cv.glmnet(x, y, family = "cox", alpha = 0.5)
            ensemble_results$glmnet <- glmnet_model
          }

          # Ensemble summary
          n_models <- length(ensemble_results)
          model_names <- paste(names(ensemble_results), collapse = ", ")

          ensemble_html <- glue::glue("
            <h4>Ensemble Model Summary</h4>
            <p><strong>Component Models:</strong> {model_names}</p>
            <p><strong>Total Models:</strong> {n_models}</p>
            <p><strong>Ensemble Method:</strong> {self$options$ml_ensemble_weights}</p>
            <p>Ensemble predictions combine multiple modeling approaches for robust predictions.</p>
          ")

          self$results$ml_ensemble_summary$setContent(ensemble_html)

        }, error = function(e) {
          error_msg <- glue::glue("Ensemble error: {e$message}")
          self$results$ml_performance_metrics$setContent(error_msg)
        })
      }

      ,
.performFeatureSelection = function(cleaneddata) {
        # Cross-validated feature selection
        tryCatch({
          formula_vars <- private$.prepareMLFormula(cleaneddata)
          all_vars <- formula_vars$variables

          # Stability selection simulation
          n_bootstrap <- 50
          selected_vars <- character(0)
          selection_freq <- rep(0, length(all_vars))
          names(selection_freq) <- all_vars

          for (i in 1:n_bootstrap) {
            # Bootstrap sample
            boot_indices <- sample(nrow(cleaneddata), replace = TRUE)
            boot_data <- cleaneddata[boot_indices, ]

            # Fit model and select variables (simplified)
            if (requireNamespace("glmnet", quietly = TRUE)) {
              x <- model.matrix(formula_vars$formula, data = boot_data)[,-1]
              y <- survival::Surv(boot_data$mytime, boot_data$myoutcome)
              cv_fit <- glmnet::cv.glmnet(x, y, family = "cox", alpha = 1)
              coefs <- coef(cv_fit, s = "lambda.min")
              selected <- which(coefs != 0)

              if (length(selected) > 0) {
                var_names <- rownames(coefs)[selected]
                for (var in var_names) {
                  if (var %in% names(selection_freq)) {
                    selection_freq[var] <- selection_freq[var] + 1
                  }
                }
              }
            }
          }

          # Normalize frequencies
          selection_freq <- selection_freq / n_bootstrap

          # Populate results table
          feature_results <- data.frame(
            variable = names(selection_freq),
            selected = ifelse(selection_freq >= 0.8, "Yes", ifelse(selection_freq >= 0.5, "Maybe", "No")),
            selection_frequency = selection_freq,
            importance_score = selection_freq,
            stringsAsFactors = FALSE
          )

          # Sort by frequency
          feature_results <- feature_results[order(-feature_results$selection_frequency), ]

          table <- self$results$ml_feature_selection_results
          for (i in 1:nrow(feature_results)) {
            table$addRow(rowKey = i, values = list(
              variable = feature_results$variable[i],
              selected = feature_results$selected[i],
              selection_frequency = round(feature_results$selection_frequency[i], 3),
              importance_score = round(feature_results$importance_score[i], 3)
            ))
          }

        }, error = function(e) {
          error_msg <- glue::glue("Feature selection error: {e$message}")
          self$results$ml_performance_metrics$setContent(error_msg)
        })
      }

      ,
.performXGBoost = function(cleaneddata) {
        # XGBoost survival analysis
        formula_vars <- private$.prepareMLFormula(cleaneddata)

        tryCatch({
          # Check for required packages with graceful fallback
          pkg_check <- .checkPackageDependency("xgboost", "XGBoost Survival", "Random Survival Forest")
          if (!pkg_check$available) {
            self$results$ml_performance_metrics$setContent(pkg_check$message)
            # Fallback to Random Forest if available, or Cox regression
            if (requireNamespace("randomForestSRC", quietly = TRUE)) {
              private$.performRandomForest(cleaneddata)
            } else {
              private$.performCoxRegression(cleaneddata)
            }
            return()
          }

          # Prepare data for xgboost
          x <- model.matrix(formula_vars$formula, data = cleaneddata)[,-1]
          y <- survival::Surv(cleaneddata$mytime, cleaneddata$myoutcome)

          # XGBoost survival model
          dtrain <- xgboost::xgb.DMatrix(data = x, label = cleaneddata$mytime)

          # Set survival-specific parameters
          params <- list(
            objective = "survival:cox",
            eta = 0.1,
            max_depth = 6,
            subsample = 0.8,
            colsample_bytree = 0.8
          )

          # Train model
          xgb_model <- xgboost::xgb.train(
            params = params,
            data = dtrain,
            nrounds = 100,
            verbose = 0
          )

          # Variable importance
          var_imp <- xgboost::xgb.importance(model = xgb_model)
          importance_scores <- setNames(var_imp$Gain, var_imp$Feature)
          private$.populateVariableImportance(importance_scores)

          # Performance metrics (simplified)
          metrics_html <- paste0(
            "<h4>", .("XGBoost Survival Model Results"), "</h4>",
            "<p><strong>", .("Model Type:"), "</strong> ", .("Cox Proportional Hazards with Gradient Boosting"), "</p>",
            "<p><strong>", .("Number of Rounds:"), "</strong> 100</p>",
            "<p><strong>", .("Variables Used:"), "</strong> ", length(formula_vars$variables), "</p>",
            "<p><strong>", .("Learning Rate:"), "</strong> ", params$eta, "</p>",
            "<p><strong>", .("Max Depth:"), "</strong> ", params$max_depth, "</p>"
          )

          self$results$ml_performance_metrics$setContent(metrics_html)

        }, error = function(e) {
          error_msg <- glue::glue("XGBoost error: {e$message}")
          self$results$ml_performance_metrics$setContent(error_msg)
        })
      }

      ,
.performSVM = function(cleaneddata) {
        # Support Vector Survival analysis
        formula_vars <- private$.prepareMLFormula(cleaneddata)

        tryCatch({
          # Check for required packages with graceful fallback
          pkg_check <- .checkPackageDependency("survivalsvm", "SVM Survival", "Random Survival Forest")
          if (!pkg_check$available) {
            self$results$ml_performance_metrics$setContent(pkg_check$message)
            # Fallback to Random Forest if available, or Cox regression
            if (requireNamespace("randomForestSRC", quietly = TRUE)) {
              private$.performRandomForest(cleaneddata)
            } else {
              private$.performCoxRegression(cleaneddata)
            }
            return()
          }

          # Prepare data for SVM
          x <- model.matrix(formula_vars$formula, data = cleaneddata)[,-1]
          y <- survival::Surv(cleaneddata$mytime, cleaneddata$myoutcome)

          # Fit SVM survival model
          svm_model <- survivalsvm::survivalsvm(
            formula = formula_vars$formula,
            data = cleaneddata,
            gamma.mu = 1
          )

          # Performance metrics
          metrics_html <- paste0(
            "<h4>", .("Support Vector Survival Model Results"), "</h4>",
            "<p><strong>", .("Model Type:"), "</strong> ", .("Support Vector Machines for Survival Analysis"), "</p>",
            "<p><strong>", .("Variables Used:"), "</strong> ", length(formula_vars$variables), "</p>",
            "<p><strong>", .("Kernel:"), "</strong> ", .("RBF (Radial Basis Function)"), "</p>",
            "<p><strong>", .("Note:"), "</strong> ", .("SVM survival analysis provides non-parametric survival predictions"), "</p>"
          )

          self$results$ml_performance_metrics$setContent(metrics_html)

        }, error = function(e) {
          error_msg <- paste(.("SVM Survival error:"), e$message, .("Note: This method requires the 'survivalsvm' package."))
          self$results$ml_performance_metrics$setContent(error_msg)
        })
      }

      ,
.performDeepSurvival = function(cleaneddata) {
        # Deep Learning Survival analysis
        tryCatch({
          # Note: Deep survival is complex and would typically require Python integration
          # For now, provide informative message about implementation status

          metrics_html <- paste0(
            "<h4>", .("Deep Survival Learning"), "</h4>",
            "<p><strong>", .("Status:"), "</strong> ", .("Deep survival methods are computationally intensive and typically require specialized Python packages (DeepSurv, DeepHit)."), "</p>",
            "<p><strong>", .("Alternative:"), "</strong> ", .("Consider using Random Survival Forest or XGBoost for advanced non-linear survival modeling."), "</p>",
            "<p><strong>", .("Implementation Note:"), "</strong> ", .("Full deep learning integration would require:"), "</p>",
            "<ul>",
              "<li>", .("Python environment with TensorFlow/PyTorch"), "</li>",
              "<li>", .("Deep survival libraries (pycox, scikit-survival)"), "</li>",
              "<li>", .("GPU acceleration for optimal performance"), "</li>",
            "</ul>",
            "<p><strong>", .("Recommendation:"), "</strong> ", .("Use ensemble methods or XGBoost for similar performance with easier implementation."), "</p>"
          )

          self$results$ml_performance_metrics$setContent(metrics_html)

        }, error = function(e) {
          error_msg <- glue::glue("Deep Survival: {e$message}")
          self$results$ml_performance_metrics$setContent(error_msg)
        })
      }

      ,
.performCrossValidation = function(cleaneddata) {
        # Cross-validation for ML methods
        tryCatch({
          formula_vars <- private$.prepareMLFormula(cleaneddata)
          n_folds <- self$options$ml_cv_folds

          # Create folds
          folds <- sample(rep(1:n_folds, length.out = nrow(cleaneddata)))
          cv_results <- numeric(n_folds)

          for (i in 1:n_folds) {
            train_data <- cleaneddata[folds != i, ]
            test_data <- cleaneddata[folds == i, ]

            # Simple C-index calculation for cross-validation
            if (self$options$ml_method == "rsf" && requireNamespace("randomForestSRC", quietly = TRUE)) {
              model <- randomForestSRC::rfsrc(
                formula = formula_vars$formula,
                data = train_data,
                ntree = 500
              )
              pred <- predict(model, newdata = test_data)
              cv_results[i] <- 1 - pred$err.rate[length(pred$err.rate)]
            }
          }

          mean_cv_score <- mean(cv_results, na.rm = TRUE)
          sd_cv_score <- sd(cv_results, na.rm = TRUE)

          cv_html <- glue::glue("
            <h4>Cross-Validation Results</h4>
            <p><strong>Method:</strong> {n_folds}-fold cross-validation</p>
            <p><strong>Mean CV Score:</strong> {round(mean_cv_score, 4)} ¬± {round(sd_cv_score, 4)}</p>
            <p><strong>Individual Fold Scores:</strong> {paste(round(cv_results, 3), collapse = ', ')}</p>
          ")

          self$results$ml_cross_validation_summary$setContent(cv_html)

        }, error = function(e) {
          error_msg <- glue::glue(.("Cross-validation error: {e$message}"))
          self$results$ml_cross_validation_summary$setContent(error_msg)
        })
      }

      ,
.calculateSHAPValues = function(cleaneddata) {
        # SHAP values for interpretability
        tryCatch({
          shap_html <- paste0("
            <h4>", .("SHAP Values (SHapley Additive exPlanations)"), "</h4>
            <p><strong>", .("Status:"), "</strong> ", .("SHAP values provide model-agnostic interpretability by showing how each feature contributes to individual predictions."), "</p>
            <p><strong>", .("Implementation Note:"), "</strong> ", .("Full SHAP implementation requires specialized packages and significant computation time."), "</p>
            <p><strong>", .("Alternatives available in this module:"), "</strong></p>
            <ul>
              <li>", .("Variable importance scores (available in Random Forest and XGBoost methods)"), "</li>
              <li>", .("Hazard ratios from Cox regression (traditional interpretability)"), "</li>
              <li>", .("Decision tree visualization (rule-based interpretability)"), "</li>
            </ul>
            <p><strong>", .("For advanced SHAP analysis:"), "</strong> ", .("Consider using Python packages like 'shap' with 'scikit-survival' for comprehensive survival SHAP values."), "</p>
          ")

          # Note: Full SHAP implementation would require significant development
          # This provides informative guidance instead
          self$results$ml_performance_metrics$setContent(shap_html)

        }, error = function(e) {
          error_msg <- glue::glue(.("SHAP calculation error: {e$message}"))
          self$results$ml_performance_metrics$setContent(error_msg)
        })
      }

      ,
.calculateMLPerformanceMetrics = function(cleaneddata) {
        # Comprehensive performance metrics
        tryCatch({
          formula_vars <- private$.prepareMLFormula(cleaneddata)

          performance_html <- paste0("
            <h4>", .("Machine Learning Performance Metrics"), "</h4>
            <p><strong>", .("Available Metrics:"), "</strong></p>
            <table style='border-collapse: collapse; width: 100%;'>
              <tr style='border-bottom: 1px solid #ddd;'>
                <th style='text-align: left; padding: 8px;'>", .("Metric"), "</th>
                <th style='text-align: left; padding: 8px;'>", .("Description"), "</th>
                <th style='text-align: left; padding: 8px;'>", .("Status"), "</th>
              </tr>
              <tr style='border-bottom: 1px solid #ddd;'>
                <td style='padding: 8px;'>", .("Concordance Index (C-index)"), "</td>
                <td style='padding: 8px;'>", .("Discrimination ability"), "</td>
                <td style='padding: 8px;'>", .("Available in model outputs"), "</td>
              </tr>
              <tr style='border-bottom: 1px solid #ddd;'>
                <td style='padding: 8px;'>", .("Integrated Brier Score (IBS)"), "</td>
                <td style='padding: 8px;'>", .("Time-dependent prediction error"), "</td>
                <td style='padding: 8px;'>", .("Requires pec package"), "</td>
              </tr>
              <tr style='border-bottom: 1px solid #ddd;'>
                <td style='padding: 8px;'>", .("Time-dependent AUC"), "</td>
                <td style='padding: 8px;'>", .("Dynamic discrimination"), "</td>
                <td style='padding: 8px;'>", .("Available via survivalROC"), "</td>
              </tr>
              <tr>
                <td style='padding: 8px;'>", .("Calibration Plot"), "</td>
                <td style='padding: 8px;'>", .("Prediction reliability"), "</td>
                <td style='padding: 8px;'>", .("Requires specialized implementation"), "</td>
              </tr>
            </table>
            <p><strong>", .("Note:"), "</strong> ", .("Detailed performance metrics require additional computational resources and specialized packages. Use the cross-validation option for robust performance assessment."), "</p>
          ")

          self$results$ml_performance_metrics$setContent(performance_html)

        }, error = function(e) {
          error_msg <- glue::glue(.("Performance metrics error: {e$message}"))
          self$results$ml_performance_metrics$setContent(error_msg)
        })
      }

      ,
.prepareMLFormula = function(cleaneddata) {
        # Prepare formula and variables for ML methods
        myexplanatory_labelled <- private$.getData()$myexplanatory_labelled
        mycontexpl_labelled <- private$.getData()$mycontexpl_labelled

        # Combine all explanatory variables
        all_vars <- c(myexplanatory_labelled, mycontexpl_labelled)

        # Create survival formula
        formula_str <- paste("Surv(mytime, myoutcome) ~", paste(all_vars, collapse = " + "))
        formula_obj <- as.formula(formula_str)

        return(list(
          formula = formula_obj,
          variables = all_vars
        ))
      }

      ,
.populateVariableImportance = function(var_imp) {
        # Populate variable importance table
        if (length(var_imp) > 0) {
          var_imp_sorted <- sort(var_imp, decreasing = TRUE)

          table <- self$results$ml_variable_importance
          for (i in seq_along(var_imp_sorted)) {
            table$addRow(rowKey = i, values = list(
              variable = names(var_imp_sorted)[i],
              importance = round(var_imp_sorted[i], 4),
              rank = i
            ))
          }
        }
      }

      ,
.populatePredictionIntervals = function(predictions, cleaneddata) {
        # Populate prediction intervals table (simplified)
        if (!is.null(predictions)) {
          n_show <- min(10, nrow(cleaneddata))  # Show first 10 observations

          table <- self$results$ml_prediction_intervals
          for (i in 1:n_show) {
            # Simplified prediction intervals (would need proper implementation)
            pred_value <- if (is.list(predictions)) predictions$predicted[i] else predictions[i]

            table$addRow(rowKey = i, values = list(
              observation = i,
              prediction = round(pred_value, 4),
              lower_ci = round(pred_value * 0.8, 4),  # Simplified
              upper_ci = round(pred_value * 1.2, 4),  # Simplified
              risk_group = ifelse(pred_value > median(predictions, na.rm = TRUE), "High", "Low")
            ))
          }
        }
      }

        # Natural Language Summary Generation ----
        ,
        .generateMultivariableCoxSummary = function(tMultivariable, explanatory_vars, outcome_var) {
            tryCatch({
                # Extract the results table and metrics
                cox_table <- tMultivariable[[1]]
                metrics <- tMultivariable[[2]]

                # Generate summary components
                sig_data <- private$.generateSignificantPredictorsSummary(cox_table)
                model_performance <- private$.generateModelPerformanceSummary(metrics)
                clinical_interpretation <- private$.generateClinicalInterpretation(cox_table, outcome_var)

                # Generate main summary text
                summary_html <- paste0(
                    '<div style="background-color: #f0f8ff; padding: 15px; border-radius: 8px; margin: 10px 0;">',
                    '<h4 style="color: #2c5282; margin-top: 0;">üìä ', .("Multivariable Cox Regression Summary"), '</h4>',
                    '<p style="margin: 10px 0;"><strong>', .("Analysis Overview:"), '</strong> ', .("Multivariable Cox proportional hazards regression was performed to examine the relationship between"), ' ',
                    length(explanatory_vars), ' ', .("explanatory variable(s) and the time-to-event outcome"), ' <em>', outcome_var, '</em>.</p>'
                )

                # Add findings summary
                if (sig_data$significant_count > 0) {
                    summary_html <- paste0(summary_html,
                        '<p style="margin: 10px 0;"><strong>', .("Key Findings:"), '</strong></p>',
                        '<ul style="margin: 5px 0; padding-left: 20px;">',
                        '<li>', sig_data$significant_count, ' ', .("out of"), ' ', sig_data$total_predictors, ' ', .("predictor(s) showed statistically significant associations (p < 0.05)"), '</li>'
                    )

                    if (!is.null(sig_data$strongest_predictor)) {
                        summary_html <- paste0(summary_html,
                            '<li>', .("Strongest association:"), ' <em>', sig_data$strongest_predictor, '</em> ', .("with"), ' ', sig_data$strongest_effect, ' (HR = ', round(sig_data$strongest_hr, 2), ')</li>'
                        )
                    }

                    summary_html <- paste0(summary_html, '</ul>')
                } else if (sig_data$total_predictors > 0) {
                    summary_html <- paste0(summary_html,
                        '<p style="margin: 10px 0;"><strong>', .("Key Findings:"), '</strong> ', .("None of the"), ' ', sig_data$total_predictors,
                        ' ', .("predictor(s) showed statistically significant associations with the outcome (all p ‚â• 0.05)."), '</p>'
                    )
                } else {
                    summary_html <- paste0(summary_html,
                        '<p style="margin: 10px 0;"><strong>', .("Note:"), '</strong> ', .("Unable to extract predictor information from the analysis."), '</p>'
                    )
                }

                # Add model performance
                summary_html <- paste0(summary_html, model_performance)

                # Add clinical interpretation
                summary_html <- paste0(summary_html, clinical_interpretation, '</div>')

                return(summary_html)

            }, error = function(e) {
                return(paste0("<p>", .("Summary generation encountered an error."), "</p>"))
            })
        }

        # Helper Functions for Summary Generation ----
        ,
        .generateSignificantPredictorsSummary = function(cox_table) {
            tryCatch({
                # Count significant predictors
                significant_count <- 0
                total_predictors <- 0
                strongest_predictor <- NULL
                strongest_hr <- 0
                strongest_effect <- ""

                # Parse the table to identify significant predictors
                if (!is.null(cox_table) && nrow(cox_table) > 0) {
                    for (i in 1:nrow(cox_table)) {
                        if (!is.na(cox_table[i, "p"]) && cox_table[i, "p"] != "") {
                            p_value <- as.numeric(cox_table[i, "p"])
                            if (!is.na(p_value)) {
                                total_predictors <- total_predictors + 1
                                if (p_value < 0.05) {
                                    significant_count <- significant_count + 1
                                    # Track strongest predictor
                                    hr_value <- cox_table[i, "HR (95% CI, p-value)"]
                                    if (!is.na(hr_value) && hr_value != "" && hr_value != "-") {
                                        # Extract HR value from the formatted string
                                        hr_match <- regmatches(hr_value, regexpr("[0-9]+\\.?[0-9]*", hr_value))
                                        if (length(hr_match) > 0) {
                                            hr_numeric <- as.numeric(hr_match[1])
                                            if (!is.na(hr_numeric)) {
                                                # Calculate effect size (distance from 1.0)
                                                effect_size <- abs(log(hr_numeric))
                                                if (effect_size > abs(log(strongest_hr + 0.001))) {
                                                    strongest_hr <- hr_numeric
                                                    strongest_predictor <- cox_table[i, 1]
                                                    strongest_effect <- if (hr_numeric > 1) .("increased hazard") else .("decreased hazard")
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }

                # Return the significant predictors data
                return(list(
                    significant_count = significant_count,
                    total_predictors = total_predictors,
                    strongest_predictor = strongest_predictor,
                    strongest_hr = strongest_hr,
                    strongest_effect = strongest_effect
                ))
            }, error = function(e) {
                return(list(
                    significant_count = 0,
                    total_predictors = 0,
                    strongest_predictor = NULL,
                    strongest_hr = 0,
                    strongest_effect = ""
                ))
            })
        }

        ,
        .generateModelPerformanceSummary = function(metrics) {
            if (!is.null(metrics)) {
                return(paste0('<p style="margin: 10px 0;"><strong>', .("Model Performance:"), '</strong> ', metrics, '</p>'))
            }
            return("")
        }

        ,
        .generateClinicalInterpretation = function(cox_table, outcome_var) {
            # Generate interpretation guide
            summary_html <- paste0(
                '<div style="background-color: #e6f7ff; padding: 10px; border-radius: 5px; margin-top: 10px;">',
                '<strong>üí° ', .("Interpretation Guide:"), '</strong>',
                '<ul style="margin: 5px 0; padding-left: 20px; font-size: 0.95em;">',
                '<li>', .("HR > 1: Factor increases the hazard (risk) of the event"), '</li>',
                '<li>', .("HR < 1: Factor decreases the hazard (risk) of the event"), '</li>',
                '<li>', .("HR = 1: No association between factor and event timing"), '</li>',
                '<li>', .("95% CI not crossing 1.0 indicates statistical significance"), '</li>',
                '</ul>',
                '</div>'
            )

            return(summary_html)
        }

        ,
        .calculate_nomogram = function() {
            # Nomogram calculation function
            tryCatch({
                if (!requireNamespace("rms", quietly = TRUE)) {
                    self$results$nomogramSummary$setContent(paste0("
                        <p><strong>", .("Nomogram Analysis"), "</strong></p>
                        <p>", .("The 'rms' package is required for nomogram generation but is not available."), "</p>
                        <p>", .("Please install it using:"), " <code>install.packages('rms')</code></p>
                        <p>", .("Nomograms provide visual tools for calculating individual risk predictions from multivariable models."), "</p>
                    "))
                    return()
                }

                # Get cleaned data
                cleaneddata <- private$.cleandata()
                mydata <- cleaneddata$cleanData

                # Get Cox model results
                cox_results <- private$.performCoxRegression(cleaneddata)

                if (!is.null(cox_results)) {
                    nomogram_html <- paste0("
                        <h4>", .("Nomogram for Risk Prediction"), "</h4>
                        <p><strong>", .("Status:"), "</strong> ", .("Nomogram generation requires specialized implementation with the 'rms' package."), "</p>
                        <p><strong>", .("Purpose:"), "</strong> ", .("Nomograms provide a visual calculator for individual risk prediction based on the multivariable Cox model."), "</p>
                        <p><strong>", .("Implementation Note:"), "</strong> ", .("Full nomogram generation requires:"), "</p>
                        <ul>
                            <li>", .("Model fitting using rms::cph() instead of survival::coxph()"), "</li>
                            <li>", .("Calibration and validation procedures"), "</li>
                            <li>", .("Time-specific risk calculations"), "</li>
                            <li>", .("Graphical nomogram construction"), "</li>
                        </ul>
                        <p><strong>", .("Alternative:"), "</strong> ", .("Use the risk score functionality for individual risk stratification."), "</p>
                    ")

                    self$results$nomogramSummary$setContent(nomogram_html)
                } else {
                    self$results$nomogramSummary$setContent(.("Unable to generate nomogram: Cox model results not available."))
                }

            }, error = function(e) {
                error_msg <- paste(.("Nomogram calculation error:"), e$message)
                self$results$nomogramSummary$setContent(error_msg)
            })
        }

        ,
        .calculate_survivaldecisiontree = function() {
            # Decision tree calculation function
            tryCatch({
                # Get cleaned data
                cleaneddata <- private$.cleandata()

                # Use the existing decision tree analysis
                tree_results <- private$.survivalTree(list(cleanData = cleaneddata$cleanData))

                if (!is.null(tree_results)) {
                    # Tree analysis completed successfully
                    # Results are populated in .survivalTree function
                } else {
                    self$results$tree_summary$setContent(.("Decision tree analysis could not be completed."))
                }

            }, error = function(e) {
                error_msg <- paste(.("Decision tree calculation error:"), e$message)
                self$results$tree_summary$setContent(error_msg)
            })
        }

        ,
        .generateAndDisplayClinicalSummary = function(cleaneddata) {
          # Generate clinical interpretation summary for display
          tryCatch({
            # Get basic data information
            mydata <- cleaneddata$cleanData
            n_total <- nrow(mydata)
            n_events <- sum(mydata$myoutcome, na.rm = TRUE)
            n_vars <- length(c(cleaneddata$myexplanatory_labelled, cleaneddata$mycontexpl_labelled))

            # Try to get Cox regression results for summary
            cox_results <- NULL
            tryCatch({
              cox_model <- private$.performCoxRegression(cleaneddata)
              if (!is.null(cox_model)) {
                cox_summary <- summary(cox_model)
                cox_results <- cox_summary$coefficients
              }
            }, error = function(e) {
              # Silent error handling
            })

            # Generate clinical summary
            clinical_summary <- .generateClinicalSummary(
              results = cox_results,
              analysis_type = "cox",
              n_vars = n_vars,
              n_events = n_events
            )

            # Format for display
            summary_html <- paste0(
              "<div style='background-color: #e7f3ff; border: 1px solid #b3d9ff; padding: 20px; border-radius: 8px; margin: 15px 0;'>",
              "<h3 style='color: #0056b3; margin-top: 0; margin-bottom: 15px;'>üìä ", .("Clinical Summary"), "</h3>",
              "<div style='background-color: white; padding: 15px; border-radius: 5px; border-left: 4px solid #0056b3;'>",
              "<p style='font-size: 16px; line-height: 1.6; margin: 0;'>", clinical_summary$summary, "</p>",
              "</div>"
            )

            # Add study details
            if (n_vars > 0) {
              summary_html <- paste0(summary_html,
                "<div style='margin-top: 15px; padding: 10px; background-color: #f8f9fa; border-radius: 5px;'>",
                "<p style='margin: 5px 0; font-size: 14px;'><strong>", .("Study Details:"), "</strong></p>",
                "<ul style='margin: 5px 0; padding-left: 20px; font-size: 14px;'>",
                "<li>", .("Total patients:"), " ", n_total, "</li>",
                "<li>", .("Events observed:"), " ", n_events, " (", round(n_events/n_total*100, 1), "%)</li>",
                "<li>", .("Variables analyzed:"), " ", n_vars, "</li>",
                "</ul>",
                "</div>"
              )
            }

            # Add recommendations if there are issues
            if (n_events < 10) {
              summary_html <- paste0(summary_html,
                "<div style='margin-top: 15px; padding: 10px; background-color: #fff3cd; border: 1px solid #ffeaa7; border-radius: 5px;'>",
                "<p style='margin: 0; color: #856404;'><strong>‚ö†Ô∏è ", .("Recommendation:"), "</strong> ",
                .("With fewer than 10 events, results should be interpreted cautiously. Consider longer follow-up or pooled analysis."),
                "</p>",
                "</div>"
              )
            }

            summary_html <- paste0(summary_html, "</div>")

            # Display in a dedicated result area (prepend to existing text if possible)
            if (!is.null(self$results$text)) {
              current_content <- ""
              tryCatch({
                # Try to get existing content
                current_content <- self$results$text$content
                if (is.null(current_content)) current_content <- ""
              }, error = function(e) {
                current_content <- ""
              })

              # Prepend clinical summary
              new_content <- paste0(summary_html, current_content)
              self$results$text$setContent(new_content)
            }

          }, error = function(e) {
            # Silent error handling - don't break analysis if summary fails
            warning(paste("Clinical summary generation failed:", e$message))
          })
        }

    )  # Close private list
)

