
# This file is automatically generated, you probably don't want to edit this

concordanceindexClass <- if (requireNamespace('jmvcore', quietly=TRUE)) R6::R6Class(
    "concordanceindexClass",
    inherit = concordanceindexBase,
    private = list(
        .init = function() {
            private$.initInstructions()
        },

        .run = function() {
            # Check for required inputs
            if (is.null(self$options$time) || is.null(self$options$event) ||
                is.null(self$options$predictor)) {
                return()
            }

            # Get data
            data <- self$data
            time_var <- data[[self$options$time]]
            event_var <- data[[self$options$event]]
            predictor <- data[[self$options$predictor]]

            # Reverse direction if requested
            if (self$options$reverse_direction) {
                predictor <- -predictor
            }

            # Calculate C-index
            private$.populateCindexSummary(time_var, event_var, predictor)

            # Calculate time-dependent C-index if requested
            if (self$options$time_dependent) {
                private$.populateTimeDependentCindex(time_var, event_var, predictor)
            }

            # Model comparison if requested
            if (self$options$compare_models && !is.null(self$options$additional_predictors) &&
                length(self$options$additional_predictors) > 0) {
                private$.populateModelComparison(time_var, event_var, predictor)
            }

            # Populate interpretation
            private$.populateInterpretation()
        },

        .initInstructions = function() {
            instructions <- self$results$instructions
            html <- "<h3>Concordance Index (Harrell's C-index)</h3>
            <p>Rank-based discrimination measure for time-to-event predictions.</p>

            <h4>Required Inputs:</h4>
            <ul>
                <li><b>Time:</b> Time-to-event or censoring</li>
                <li><b>Event:</b> Binary event indicator (1 = event, 0 = censored)</li>
                <li><b>Predictor:</b> Risk score or linear predictor (higher = worse prognosis)</li>
            </ul>

            <h4>C-index Interpretation:</h4>
            <ul>
                <li><b>C = 0.5:</b> No discrimination (random)</li>
                <li><b>C = 0.6-0.7:</b> Poor to acceptable discrimination</li>
                <li><b>C = 0.7-0.8:</b> Good discrimination</li>
                <li><b>C = 0.8-0.9:</b> Excellent discrimination</li>
                <li><b>C > 0.9:</b> Outstanding discrimination (rare, check for overfitting)</li>
                <li><b>C = 1.0:</b> Perfect discrimination</li>
            </ul>

            <h4>What C-index Measures:</h4>
            <ul>
                <li>Proportion of all patient pairs correctly ranked by the model</li>
                <li>For any two patients, does the model predict longer survival for the one who actually lived longer?</li>
                <li>Accounts for censoring through appropriate pair weighting</li>
                <li>Extension of ROC's AUC to survival data</li>
            </ul>

            <h4>Calculation Methods:</h4>
            <ul>
                <li><b>Harrell's:</b> Standard method from survival package, handles censoring</li>
                <li><b>Uno's:</b> Uses inverse probability censoring weighting (IPCW), less biased with heavy censoring</li>
                <li><b>Gönen-Heller:</b> Bias-free for proportional hazards, doesn't need follow-up data</li>
            </ul>

            <h4>C-index vs Time-Dependent ROC:</h4>
            <ul>
                <li><b>C-index:</b> Global measure across entire follow-up</li>
                <li><b>TD-ROC:</b> Discrimination at specific time points (e.g., 5-year survival)</li>
                <li>Both valuable, C-index simpler and more interpretable</li>
            </ul>

            <h4>Clinical Applications:</h4>
            <ul>
                <li><b>Cox Model Validation:</b> Primary discrimination metric</li>
                <li><b>Risk Score Evaluation:</b> AJCC staging, Nottingham PI, gene signatures</li>
                <li><b>Biomarker Assessment:</b> Prognostic value of molecular markers</li>
                <li><b>ML Model Selection:</b> Compare random forests, neural nets, boosting</li>
                <li><b>External Validation:</b> Test generalizability in new populations</li>
            </ul>

            <h4>Somers' D:</h4>
            <ul>
                <li>D = 2 × (C-index - 0.5)</li>
                <li>Ranges from -1 to +1 (like correlation)</li>
                <li>Easier to interpret as strength of association</li>
                <li>D = 0.4 means moderate association, D = 0.6 strong</li>
            </ul>

            <h4>Sample Size Considerations:</h4>
            <ul>
                <li>Minimum ~100 events for stable C-index estimate</li>
                <li>More events needed for model comparison (200+ per model)</li>
                <li>Heavy censoring (>50%) may require Uno's method</li>
            </ul>

            <h4>Required R Packages:</h4>
            <ul>
                <li><b>survival:</b> concordance() function (Harrell's method)</li>
                <li><b>Hmisc:</b> rcorr.cens() alternative implementation</li>
                <li><b>survcomp:</b> Uno's C-index</li>
                <li><b>survAUC:</b> Various C-index estimators</li>
            </ul>

            <p><b>Note:</b> Implementation in development. Full functionality requires survival and Hmisc packages.</p>"

            instructions$setContent(html)
        },

        .populateCindexSummary = function(time_var, event_var, predictor) {
            table <- self$results$cindexSummary

            # Remove missing values
            complete_cases <- complete.cases(time_var, event_var, predictor)
            time_var <- time_var[complete_cases]
            event_var <- event_var[complete_cases]
            predictor <- predictor[complete_cases]

            # Calculate C-index based on selected method
            if (self$options$cindex_method == "harrell") {
                # Use survival::concordance() for Harrell's method
                cindex_result <- private$.calculateHarrellCindex(time_var, event_var, predictor)
            } else if (self$options$cindex_method == "uno") {
                # Use Uno's method with IPCW
                cindex_result <- private$.calculateUnoCindex(time_var, event_var, predictor)
            } else {
                # Gönen-Heller method
                cindex_result <- private$.calculateGonenHellerCindex(time_var, event_var, predictor)
            }

            # Calculate confidence intervals
            cindex_ci_lower <- NA
            cindex_ci_upper <- NA

            if (self$options$confidence_intervals) {
                ci_result <- private$.calculateCindexCI(
                    time_var = time_var,
                    event_var = event_var,
                    predictor = predictor,
                    cindex = cindex_result$cindex
                )
                cindex_ci_lower <- ci_result$lower
                cindex_ci_upper <- ci_result$upper
            }

            # Calculate Somers' D if requested
            somers_d <- NA
            if (self$options$somers_d) {
                somers_d <- 2 * (cindex_result$cindex - 0.5)
            }

            # Interpretation
            interpretation <- if (cindex_result$cindex < 0.6) {
                "Poor discrimination (< 0.6)"
            } else if (cindex_result$cindex < 0.7) {
                "Acceptable discrimination (0.6-0.7)"
            } else if (cindex_result$cindex < 0.8) {
                "Good discrimination (0.7-0.8)"
            } else if (cindex_result$cindex < 0.9) {
                "Excellent discrimination (0.8-0.9)"
            } else {
                "Outstanding discrimination (> 0.9)"
            }

            table$setRow(rowNo=1, values=list(
                predictor = self$options$predictor,
                method = self$options$cindex_method,
                n_pairs = cindex_result$n_pairs,
                concordant = cindex_result$concordant,
                discordant = cindex_result$discordant,
                tied = cindex_result$tied,
                cindex = cindex_result$cindex,
                cindex_se = cindex_result$se,
                cindex_ci_lower = cindex_ci_lower,
                cindex_ci_upper = cindex_ci_upper,
                somers_d = somers_d,
                interpretation = interpretation
            ))
        },

        .populateInterpretation = function() {
            interpretation <- self$results$interpretation

            html <- "<h4>Clinical Interpretation</h4>
            <p>Concordance index assessment for survival model discrimination.</p>

            <h5>Discrimination Performance:</h5>
            <ul>
                <li>C-index represents probability that model correctly ranks patient pairs</li>
                <li>Values > 0.7 generally indicate clinically useful discrimination</li>
                <li>Compare to clinical staging or established risk scores</li>
            </ul>

            <h5>Kaplan-Meier Risk Groups:</h5>
            <ul>
                <li>Visual assessment of separation between risk groups</li>
                <li>Good discrimination shows clear separation of curves</li>
                <li>Crossing curves suggest time-varying effects</li>
            </ul>

            <h5>Recommendations:</h5>
            <ul>
                <li>C > 0.7 supports clinical utility for prognostication</li>
                <li>For biomarker studies, C > 0.75 often needed for clinical adoption</li>
                <li>Consider calibration in addition to discrimination</li>
                <li>External validation essential before clinical implementation</li>
            </ul>"

            interpretation$setContent(html)
        },

        .calculateHarrellCindex = function(time_var, event_var, predictor) {
            # Harrell's C-index using survival::concordance()
            # Most commonly used method

            surv_obj <- survival::Surv(time_var, event_var)

            # Use survival::concordance() from survival package
            conc <- survival::concordance(surv_obj ~ predictor)

            # Extract concordance statistics
            cindex <- conc$concordance
            n_pairs <- sum(conc$count)
            concordant <- conc$count["concordant"]
            discordant <- conc$count["discordant"]
            tied_risk <- conc$count["tied.risk"]
            tied_time <- conc$count["tied.time"]

            # Total ties
            tied <- tied_risk + tied_time

            # Standard error
            se <- sqrt(conc$var)

            return(list(
                cindex = cindex,
                se = se,
                n_pairs = n_pairs,
                concordant = concordant,
                discordant = discordant,
                tied = tied
            ))
        },

        .calculateUnoCindex = function(time_var, event_var, predictor) {
            # Uno's C-index with Inverse Probability of Censoring Weighting (IPCW)
            # Less biased with heavy censoring

            n <- length(time_var)

            # Fit censoring distribution (reverse event indicator)
            surv_cens <- survival::Surv(time_var, 1 - event_var)
            km_cens <- survival::survfit(surv_cens ~ 1)

            # Calculate weights for each observation
            weights <- rep(1, n)
            for (i in 1:n) {
                idx <- which(km_cens$time <= time_var[i])
                if (length(idx) > 0) {
                    weights[i] <- km_cens$surv[max(idx)]
                }
            }

            # Avoid division by zero
            weights[weights < 0.01] <- 0.01
            weights <- 1 / weights

            # Calculate weighted concordance
            concordant <- 0
            discordant <- 0
            tied <- 0
            total_weight <- 0

            for (i in 1:(n-1)) {
                for (j in (i+1):n) {
                    # Only consider comparable pairs (one had event)
                    if (event_var[i] == 1 && time_var[i] <= time_var[j]) {
                        # i had event first, j either had event later or censored
                        weight <- weights[i]
                        total_weight <- total_weight + weight

                        if (predictor[i] > predictor[j]) {
                            concordant <- concordant + weight
                        } else if (predictor[i] < predictor[j]) {
                            discordant <- discordant + weight
                        } else {
                            tied <- tied + weight
                        }
                    } else if (event_var[j] == 1 && time_var[j] <= time_var[i]) {
                        # j had event first, i either had event later or censored
                        weight <- weights[j]
                        total_weight <- total_weight + weight

                        if (predictor[j] > predictor[i]) {
                            concordant <- concordant + weight
                        } else if (predictor[j] < predictor[i]) {
                            discordant <- discordant + weight
                        } else {
                            tied <- tied + weight
                        }
                    }
                }
            }

            # Calculate C-index
            if (self$options$handle_ties == "average") {
                cindex <- (concordant + 0.5 * tied) / total_weight
            } else if (self$options$handle_ties == "exclude") {
                cindex <- concordant / (concordant + discordant)
            } else {
                # Random
                cindex <- (concordant + 0.5 * tied) / total_weight
            }

            # Approximate SE
            se <- sqrt(cindex * (1 - cindex) / total_weight)

            return(list(
                cindex = cindex,
                se = se,
                n_pairs = total_weight,
                concordant = concordant,
                discordant = discordant,
                tied = tied
            ))
        },

        .calculateGonenHellerCindex = function(time_var, event_var, predictor) {
            # Gönen-Heller estimator - bias-free for proportional hazards
            # Doesn't require follow-up information, based on predictor distribution only

            n <- length(predictor)

            # Calculate all pairwise comparisons of predictors
            concordant <- 0
            discordant <- 0
            tied <- 0

            for (i in 1:(n-1)) {
                for (j in (i+1):n) {
                    diff <- predictor[i] - predictor[j]

                    if (abs(diff) < 1e-10) {
                        tied <- tied + 1
                    } else if (diff > 0) {
                        # i has higher risk than j
                        # Under PH, i more likely to have event first
                        concordant <- concordant + 1
                    } else {
                        discordant <- discordant + 1
                    }
                }
            }

            n_pairs <- choose(n, 2)

            # Gönen-Heller C-index
            if (self$options$handle_ties == "average") {
                cindex <- (concordant + 0.5 * tied) / n_pairs
            } else if (self$options$handle_ties == "exclude") {
                cindex <- concordant / (concordant + discordant)
            } else {
                cindex <- (concordant + 0.5 * tied) / n_pairs
            }

            # Approximate SE (simplified)
            se <- sqrt(cindex * (1 - cindex) / n_pairs)

            return(list(
                cindex = cindex,
                se = se,
                n_pairs = n_pairs,
                concordant = concordant,
                discordant = discordant,
                tied = tied
            ))
        },

        .calculateCindexCI = function(time_var, event_var, predictor, cindex) {
            # Calculate confidence intervals for C-index

            if (self$options$ci_method == "bootstrap") {
                # Bootstrap confidence intervals
                set.seed(self$options$random_seed)
                n_boot <- self$options$bootstrap_samples
                n <- length(time_var)

                boot_cindex <- numeric(n_boot)

                for (b in 1:n_boot) {
                    # Bootstrap sample
                    boot_idx <- sample(1:n, n, replace = TRUE)
                    boot_time <- time_var[boot_idx]
                    boot_event <- event_var[boot_idx]
                    boot_pred <- predictor[boot_idx]

                    # Calculate C-index for bootstrap sample
                    tryCatch({
                        if (self$options$cindex_method == "harrell") {
                            result <- private$.calculateHarrellCindex(boot_time, boot_event, boot_pred)
                        } else if (self$options$cindex_method == "uno") {
                            result <- private$.calculateUnoCindex(boot_time, boot_event, boot_pred)
                        } else {
                            result <- private$.calculateGonenHellerCindex(boot_time, boot_event, boot_pred)
                        }
                        boot_cindex[b] <- result$cindex
                    }, error = function(e) {
                        boot_cindex[b] <- NA
                    })
                }

                # Calculate percentile CI
                alpha <- 1 - self$options$confidence_level
                ci_lower <- quantile(boot_cindex, alpha/2, na.rm = TRUE)
                ci_upper <- quantile(boot_cindex, 1 - alpha/2, na.rm = TRUE)

            } else {
                # Asymptotic CI using SE approximation
                n <- length(time_var)
                se_cindex <- sqrt(cindex * (1 - cindex) / n)

                z_crit <- qnorm(1 - (1 - self$options$confidence_level) / 2)
                ci_lower <- max(0, cindex - z_crit * se_cindex)
                ci_upper <- min(1, cindex + z_crit * se_cindex)
            }

            return(list(lower = ci_lower, upper = ci_upper))
        },

        .populateTimeDependentCindex = function(time_var, event_var, predictor) {
            # Calculate time-dependent C-index at specific time horizons
            # This is a simplified implementation - full implementation would use timeROC package

            table <- self$results$timeDependentCindex

            # Parse evaluation times
            eval_times_str <- self$options$evaluation_times
            eval_times <- as.numeric(unlist(strsplit(eval_times_str, ",")))

            for (i in seq_along(eval_times)) {
                t_horizon <- eval_times[i]

                # For time-dependent C-index, only consider pairs where:
                # 1. Both patients are at risk at time 0
                # 2. At least one had event or was censored after t_horizon

                # Simple approximation: restrict data to those who survived past t_horizon
                # or had event before t_horizon
                include <- (time_var > t_horizon) | (time_var <= t_horizon & event_var == 1)

                if (sum(include) < 10) {
                    next  # Skip if too few observations
                }

                # Calculate C-index for this subset
                tryCatch({
                    result <- private$.calculateHarrellCindex(
                        time_var[include],
                        event_var[include],
                        predictor[include]
                    )

                    table$addRow(rowKey=i, values=list(
                        time_horizon = t_horizon,
                        cindex = result$cindex,
                        cindex_se = result$se,
                        n_pairs = result$n_pairs,
                        n_events = sum(event_var[include] == 1)
                    ))
                }, error = function(e) {
                    # Skip time points with errors
                })
            }
        },

        .populateModelComparison = function(time_var, event_var, predictor) {
            # Compare C-index across multiple models
            # TODO: Implement model comparison
        },

        .plotCindexOverTime = function(image, ...) {
            # Stub for C-index over time plot
        },

        .plotModelComparison = function(image, ...) {
            # Stub for model comparison plot
        },

        .plotRiskGroupKM = function(image, ...) {
            # Stub for Kaplan-Meier by risk groups
        },

        .plotDecomposition = function(image, ...) {
            # Stub for C-index decomposition plot
        }
    )
)
