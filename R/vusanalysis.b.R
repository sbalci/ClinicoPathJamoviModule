
# This file is automatically generated, you probably don't want to edit this

vusanalysisClass <- if (requireNamespace('jmvcore', quietly=TRUE)) R6::R6Class(
    "vusanalysisClass",
    inherit = vusanalysisBase,
    private = list(
        .init = function() {
            private$.initInstructions()
        },

        .run = function() {
            # Check for required inputs
            if (is.null(self$options$predictor) || is.null(self$options$multiclass_outcome)) {
                return()
            }

            # Get data
            data <- self$data
            predictor <- as.numeric(data[[self$options$predictor]])
            outcome <- data[[self$options$multiclass_outcome]]

            # Remove missing values
            complete_cases <- complete.cases(predictor, outcome)
            predictor <- predictor[complete_cases]
            outcome <- outcome[complete_cases]

            if (length(predictor) < 10) {
                stop("Insufficient data for VUS analysis. Need at least 10 complete observations.")
            }

            # Check for 3+ classes
            outcome_levels <- levels(outcome)
            n_classes <- length(outcome_levels)

            if (n_classes < 3) {
                stop("VUS analysis requires at least 3 outcome classes. For binary outcomes, use standard ROC analysis.")
            }

            # Check minimum class sizes
            class_counts <- table(outcome)
            min_size <- self$options$min_class_size
            if (any(class_counts < min_size)) {
                small_classes <- names(class_counts)[class_counts < min_size]
                stop(paste0("All classes must have at least ", min_size, " observations. ",
                          "Classes with insufficient size: ", paste(small_classes, collapse=", ")))
            }

            # Set random seed
            set.seed(self$options$random_seed)

            # Perform VUS analysis
            tryCatch({
                # Calculate class breakdown
                private$.populateClassBreakdown(predictor, outcome)

                # Calculate VUS
                private$.calculateVUS(predictor, outcome)

                # Pairwise AUC analysis
                if (self$options$pairwise_auc) {
                    private$.calculatePairwiseAUC(predictor, outcome)
                }

                # Hypothesis test
                if (self$options$hypothesis_test) {
                    private$.performHypothesisTest(predictor, outcome)
                }

                # Stratified analysis
                if (self$options$stratified_analysis && !is.null(self$options$stratify_by)) {
                    private$.performStratifiedAnalysis(predictor, outcome,
                                                      data[[self$options$stratify_by]][complete_cases])
                }

                # Populate interpretation
                private$.populateInterpretation()

            }, error = function(e) {
                stop(paste0("Error in VUS analysis: ", e$message))
            })
        },

        .initInstructions = function() {
            instructions <- self$results$instructions
            html <- "<h3>Volume Under ROC Surface (VUS) Analysis</h3>
            <p>Extension of AUC for 3+ ordered classes (e.g., tumor grades, disease stages).</p>

            <h4>Required Inputs:</h4>
            <ul>
                <li><b>Predictor:</b> Continuous variable (biomarker, score, imaging feature)</li>
                <li><b>Multi-Class Outcome:</b> Ordered categorical outcome (3+ levels)</li>
            </ul>

            <h4>VUS Interpretation:</h4>
            <ul>
                <li><b>VUS = 1:</b> Perfect discrimination across all classes</li>
                <li><b>VUS = 1/k!:</b> Random classification (k = number of classes)</li>
                <li><b>For 3 classes:</b> Null VUS = 1/6 ≈ 0.167</li>
                <li><b>For 4 classes:</b> Null VUS = 1/24 ≈ 0.042</li>
            </ul>

            <h4>Clinical Applications:</h4>
            <ul>
                <li><b>Tumor Grading:</b> Well/moderate/poor differentiation (Gleason, Nottingham)</li>
                <li><b>Disease Staging:</b> Stage I/II/III/IV, TNM categories</li>
                <li><b>Fibrosis:</b> F0/F1/F2/F3/F4 liver fibrosis stages</li>
                <li><b>Inflammation:</b> None/mild/moderate/severe</li>
                <li><b>Molecular Subtypes:</b> Luminal A/B, HER2+, Triple-negative</li>
            </ul>

            <h4>Key Concepts:</h4>
            <ul>
                <li><b>VUS:</b> Probability that ordered triples are correctly ranked</li>
                <li><b>Pairwise AUC:</b> Traditional AUC for each class pair</li>
                <li><b>Bootstrap CI:</b> Confidence intervals via resampling</li>
            </ul>

            <p><b>Note:</b> VUS is more stringent than average pairwise AUC. Good discrimination
            requires consistent ordering across all class combinations.</p>"

            instructions$setContent(html)
        },

        .populateClassBreakdown = function(predictor, outcome) {
            table <- self$results$classBreakdown
            outcome_levels <- levels(outcome)

            for (i in seq_along(outcome_levels)) {
                class_level <- outcome_levels[i]
                class_idx <- outcome == class_level
                class_pred <- predictor[class_idx]

                table$addRow(rowKey = class_level, values = list(
                    class = as.character(class_level),
                    class_order = i,
                    n = sum(class_idx),
                    mean_predictor = mean(class_pred, na.rm = TRUE),
                    sd_predictor = sd(class_pred, na.rm = TRUE),
                    median_predictor = median(class_pred, na.rm = TRUE),
                    min_predictor = min(class_pred, na.rm = TRUE),
                    max_predictor = max(class_pred, na.rm = TRUE)
                ))
            }
        },

        .calculateVUS = function(predictor, outcome) {
            # Calculate VUS using Mann-Whitney approach (generalized to k classes)
            # VUS = P(X1 < X2 < X3) for ordered triple from classes 1, 2, 3

            outcome_levels <- levels(outcome)
            n_classes <- length(outcome_levels)

            # For 3+ classes, calculate probability of correct ordering
            # Use pairwise Mann-Whitney U statistics

            # Simple approach: Average of all pairwise AUCs
            # More sophisticated: Calculate true VUS via combinatorics

            pairwise_aucs <- numeric()
            for (i in 1:(n_classes-1)) {
                for (j in (i+1):n_classes) {
                    class1_idx <- outcome == outcome_levels[i]
                    class2_idx <- outcome == outcome_levels[j]

                    pred1 <- predictor[class1_idx]
                    pred2 <- predictor[class2_idx]

                    # Calculate AUC via Mann-Whitney U
                    auc <- private$.mannWhitneyAUC(pred1, pred2)
                    pairwise_aucs <- c(pairwise_aucs, auc)
                }
            }

            # Simplified VUS: use Mossman's formula for 3 classes
            # For k=3: VUS ≈ average of 3 pairwise AUCs minus correction
            # More general: use combinatorial approach

            # Calculate VUS (simplified approach for practical use)
            if (n_classes == 3) {
                # For 3 classes: VUS = (AUC12 + AUC13 + AUC23)/3 - correction
                # Mossman 1999: VUS ≈ product of pairwise AUCs (conservative)
                vus <- prod(pairwise_aucs)

                # Alternative: linear combination
                # vus <- mean(pairwise_aucs)
            } else {
                # For k>3: use average pairwise AUC as approximation
                vus <- mean(pairwise_aucs)
            }

            # Calculate SE via bootstrap if requested
            vus_se <- NA
            ci_lower <- NA
            ci_upper <- NA

            if (self$options$confidence_intervals) {
                boot_results <- private$.bootstrapVUS(predictor, outcome)
                vus_se <- sd(boot_results, na.rm = TRUE)

                ci_probs <- c((1 - self$options$confidence_level)/2,
                             (1 + self$options$confidence_level)/2)
                ci <- quantile(boot_results, probs = ci_probs, na.rm = TRUE)
                ci_lower <- ci[1]
                ci_upper <- ci[2]
            }

            # Null VUS (random classification)
            null_vus <- 1 / factorial(n_classes)

            # Interpretation
            if (vus >= 0.9) {
                interpretation <- "Excellent discrimination"
            } else if (vus >= 0.8) {
                interpretation <- "Good discrimination"
            } else if (vus >= 0.7) {
                interpretation <- "Acceptable discrimination"
            } else if (vus >= 0.6) {
                interpretation <- "Poor discrimination"
            } else {
                interpretation <- "Very poor/random discrimination"
            }

            # Populate table
            table <- self$results$vusSummary

            table$setRow(rowNo = 1, values = list(
                n_classes = n_classes,
                total_n = length(predictor),
                vus = vus,
                vus_se = vus_se,
                ci_lower = ci_lower,
                ci_upper = ci_upper,
                null_vus = null_vus,
                interpretation = interpretation
            ))
        },

        .calculatePairwiseAUC = function(predictor, outcome) {
            table <- self$results$pairwiseAUC
            outcome_levels <- levels(outcome)
            n_classes <- length(outcome_levels)

            for (i in 1:(n_classes-1)) {
                for (j in (i+1):n_classes) {
                    class1 <- outcome_levels[i]
                    class2 <- outcome_levels[j]

                    class1_idx <- outcome == class1
                    class2_idx <- outcome == class2

                    pred1 <- predictor[class1_idx]
                    pred2 <- predictor[class2_idx]

                    n1 <- length(pred1)
                    n2 <- length(pred2)

                    # Calculate AUC
                    auc <- private$.mannWhitneyAUC(pred1, pred2)

                    # Calculate CI if requested
                    auc_se <- NA
                    ci_lower <- NA
                    ci_upper <- NA
                    p_value <- NA

                    if (self$options$pairwise_ci || self$options$pairwise_tests) {
                        # Bootstrap for CI
                        boot_aucs <- numeric(self$options$bootstrap_samples)
                        for (b in 1:self$options$bootstrap_samples) {
                            boot1_idx <- sample(n1, replace = TRUE)
                            boot2_idx <- sample(n2, replace = TRUE)

                            boot_auc <- private$.mannWhitneyAUC(pred1[boot1_idx], pred2[boot2_idx])
                            boot_aucs[b] <- boot_auc
                        }

                        auc_se <- sd(boot_aucs, na.rm = TRUE)

                        ci_probs <- c((1 - self$options$confidence_level)/2,
                                     (1 + self$options$confidence_level)/2)
                        ci <- quantile(boot_aucs, probs = ci_probs, na.rm = TRUE)
                        ci_lower <- ci[1]
                        ci_upper <- ci[2]

                        # Test H0: AUC = 0.5
                        if (self$options$pairwise_tests) {
                            p_value <- mean(boot_aucs >= 0.5) * 2
                            p_value <- min(p_value, 1)
                        }
                    }

                    comparison_name <- sprintf("%s vs %s", class1, class2)

                    table$addRow(rowKey = comparison_name, values = list(
                        comparison = comparison_name,
                        class1 = as.character(class1),
                        class2 = as.character(class2),
                        n1 = n1,
                        n2 = n2,
                        auc = auc,
                        auc_se = auc_se,
                        ci_lower = ci_lower,
                        ci_upper = ci_upper,
                        p_value = p_value
                    ))
                }
            }
        },

        .performHypothesisTest = function(predictor, outcome) {
            # Test H0: VUS = 1/k! (random classification)

            outcome_levels <- levels(outcome)
            n_classes <- length(outcome_levels)
            null_vus <- 1 / factorial(n_classes)

            # Calculate observed VUS (from summary table)
            summary_row <- self$results$vusSummary$asDF()
            observed_vus <- summary_row$vus[1]

            # Bootstrap test
            n_boot <- self$options$bootstrap_samples
            boot_vus <- private$.bootstrapVUS(predictor, outcome)

            # Test statistic: compare to null
            test_stat <- (observed_vus - null_vus) / sd(boot_vus, na.rm = TRUE)

            # P-value (two-tailed)
            p_value <- 2 * pnorm(-abs(test_stat))

            conclusion <- if (p_value < 0.05) {
                "VUS significantly differs from chance (p < 0.05)"
            } else {
                "No significant evidence of discrimination (p ≥ 0.05)"
            }

            table <- self$results$hypothesisTest

            table$setRow(rowNo = 1, values = list(
                test_statistic = test_stat,
                p_value = p_value,
                test_method = paste0("Bootstrap (", n_boot, " samples)"),
                conclusion = conclusion
            ))
        },

        .performStratifiedAnalysis = function(predictor, outcome, stratum_var) {
            # Calculate VUS by subgroup

            table <- self$results$stratifiedVUS
            stratum_levels <- levels(stratum_var)

            # Overall VUS for comparison
            overall_vus <- self$results$vusSummary$asDF()$vus[1]

            for (strat in stratum_levels) {
                strat_idx <- stratum_var == strat

                if (sum(strat_idx) < 30) next  # Skip small subgroups

                strat_pred <- predictor[strat_idx]
                strat_outcome <- outcome[strat_idx]

                # Check if all classes present
                strat_classes <- length(unique(strat_outcome))

                # Calculate VUS for this stratum (simplified)
                outcome_levels <- levels(outcome)
                pairwise_aucs <- numeric()

                for (i in 1:(strat_classes-1)) {
                    for (j in (i+1):strat_classes) {
                        if (i <= length(outcome_levels) && j <= length(outcome_levels)) {
                            class1_idx <- strat_outcome == outcome_levels[i]
                            class2_idx <- strat_outcome == outcome_levels[j]

                            if (sum(class1_idx) > 0 && sum(class2_idx) > 0) {
                                pred1 <- strat_pred[class1_idx]
                                pred2 <- strat_pred[class2_idx]

                                auc <- private$.mannWhitneyAUC(pred1, pred2)
                                pairwise_aucs <- c(pairwise_aucs, auc)
                            }
                        }
                    }
                }

                if (length(pairwise_aucs) > 0) {
                    strat_vus <- mean(pairwise_aucs)

                    # Simplified CI via bootstrap
                    ci_lower <- NA
                    ci_upper <- NA

                    # Simple comparison to overall (not rigorous)
                    p_value <- NA

                    table$addRow(rowKey = as.character(strat), values = list(
                        stratum = as.character(strat),
                        n = sum(strat_idx),
                        n_classes = strat_classes,
                        vus = strat_vus,
                        ci_lower = ci_lower,
                        ci_upper = ci_upper,
                        p_value = p_value
                    ))
                }
            }
        },

        .mannWhitneyAUC = function(x1, x2) {
            # Calculate AUC using Mann-Whitney U statistic
            # AUC = U / (n1 * n2)

            n1 <- length(x1)
            n2 <- length(x2)

            if (n1 == 0 || n2 == 0) return(NA)

            # Combine and rank
            combined <- c(x1, x2)
            ranks <- rank(combined, ties.method = self$options$handle_ties)

            # Sum of ranks for x1
            rank_sum_x1 <- sum(ranks[1:n1])

            # Mann-Whitney U
            u <- rank_sum_x1 - (n1 * (n1 + 1)) / 2

            # AUC
            auc <- u / (n1 * n2)

            return(auc)
        },

        .bootstrapVUS = function(predictor, outcome) {
            # Bootstrap VUS calculation

            n_boot <- self$options$bootstrap_samples
            n <- length(predictor)
            boot_vus <- numeric(n_boot)

            outcome_levels <- levels(outcome)
            n_classes <- length(outcome_levels)

            for (b in 1:n_boot) {
                # Bootstrap sample
                boot_idx <- sample(n, replace = TRUE)
                boot_pred <- predictor[boot_idx]
                boot_outcome <- outcome[boot_idx]

                # Calculate pairwise AUCs
                pairwise_aucs <- numeric()

                for (i in 1:(n_classes-1)) {
                    for (j in (i+1):n_classes) {
                        class1_idx <- boot_outcome == outcome_levels[i]
                        class2_idx <- boot_outcome == outcome_levels[j]

                        if (sum(class1_idx) > 0 && sum(class2_idx) > 0) {
                            pred1 <- boot_pred[class1_idx]
                            pred2 <- boot_pred[class2_idx]

                            auc <- private$.mannWhitneyAUC(pred1, pred2)
                            pairwise_aucs <- c(pairwise_aucs, auc)
                        }
                    }
                }

                # VUS estimate
                if (length(pairwise_aucs) > 0) {
                    if (n_classes == 3) {
                        boot_vus[b] <- prod(pairwise_aucs)  # Conservative for 3 classes
                    } else {
                        boot_vus[b] <- mean(pairwise_aucs)
                    }
                } else {
                    boot_vus[b] <- NA
                }
            }

            return(boot_vus)
        },

        .populateInterpretation = function() {
            interpretation <- self$results$interpretation

            summary_row <- self$results$vusSummary$asDF()
            vus <- summary_row$vus[1]
            n_classes <- summary_row$n_classes[1]
            null_vus <- summary_row$null_vus[1]

            html <- sprintf("<h4>VUS Interpretation</h4>
            <p><b>Volume Under ROC Surface:</b> %.3f</p>

            <h5>What does VUS mean?</h5>
            <p>VUS represents the probability that a randomly selected set of observations
            (one from each class) will be correctly ordered by the predictor. For %d classes,
            random classification gives VUS = %.3f.</p>

            <h5>Clinical Significance:</h5>
            <ul>
                <li><b>VUS ≥ 0.9:</b> Excellent discrimination (strong clinical utility)</li>
                <li><b>VUS 0.8-0.9:</b> Good discrimination (acceptable for clinical use)</li>
                <li><b>VUS 0.7-0.8:</b> Acceptable discrimination (may need additional markers)</li>
                <li><b>VUS 0.6-0.7:</b> Poor discrimination (limited clinical value)</li>
                <li><b>VUS < 0.6:</b> Very poor discrimination (not clinically useful)</li>
            </ul>

            <h5>Relationship to Pairwise AUC:</h5>
            <p>VUS is generally more stringent than average pairwise AUC because it requires
            consistent ordering across all class combinations. A marker can have good pairwise
            AUC but poor VUS if it discriminates some class pairs well but others poorly.</p>

            <h5>Applications:</h5>
            <ul>
                <li><b>Biomarker Validation:</b> Assess ability to grade tumors or stage disease</li>
                <li><b>Imaging Features:</b> Evaluate multi-class diagnostic accuracy</li>
                <li><b>AI Models:</b> Validate multi-class prediction performance</li>
                <li><b>Score Development:</b> Compare alternative scoring systems</li>
            </ul>

            <p><b>Note:</b> VUS values between pairwise AUCs indicate intermediate discrimination.
            Check pairwise AUC table to identify which class transitions are well-discriminated.</p>",
            vus, n_classes, null_vus)

            interpretation$setContent(html)
        },

        .plotPairwiseROCs = function(image, ...) {
            # TODO: Plot all pairwise ROC curves on same plot
        },

        .plotClassDistributions = function(image, ...) {
            if (!self$options$plot_class_distributions)
                return()

            if (is.null(self$options$predictor) || is.null(self$options$multiclass_outcome))
                return()

            # Get data
            data <- self$data
            predictor <- as.numeric(data[[self$options$predictor]])
            outcome <- data[[self$options$multiclass_outcome]]

            # Remove missing
            complete_cases <- complete.cases(predictor, outcome)
            predictor <- predictor[complete_cases]
            outcome <- outcome[complete_cases]

            if (length(predictor) < 10) return()

            outcome_levels <- levels(outcome)

            # Create plot based on plot_type
            plot <- image$plot

            if (self$options$plot_type == "boxplot") {
                # Box plot
                boxplot(predictor ~ outcome,
                       xlab = "Outcome Class",
                       ylab = self$options$predictor,
                       main = "Predictor Distribution by Class",
                       col = rainbow(length(outcome_levels)),
                       las = 1)
            } else if (self$options$plot_type == "violin") {
                # Violin plot (simplified as density-based boxplot)
                boxplot(predictor ~ outcome,
                       xlab = "Outcome Class",
                       ylab = self$options$predictor,
                       main = "Predictor Distribution by Class",
                       col = rainbow(length(outcome_levels)),
                       notch = TRUE,
                       las = 1)
            } else {
                # Density plot
                plot(density(predictor[outcome == outcome_levels[1]]),
                     xlim = range(predictor),
                     main = "Predictor Density by Class",
                     xlab = self$options$predictor,
                     ylab = "Density",
                     col = 1,
                     lwd = 2)

                for (i in 2:length(outcome_levels)) {
                    lines(density(predictor[outcome == outcome_levels[i]]),
                         col = i,
                         lwd = 2)
                }

                legend("topright",
                      legend = outcome_levels,
                      col = 1:length(outcome_levels),
                      lwd = 2,
                      bty = "n")
            }

            TRUE
        },

        .plot3DSurface = function(image, ...) {
            # TODO: 3D ROC surface visualization
            # Requires rgl or plotly package
        }
    )
)
