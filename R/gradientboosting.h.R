
# This file is automatically generated, you probably don't want to edit this

gradientboostingOptions <- if (requireNamespace("jmvcore", quietly=TRUE)) R6::R6Class(
    "gradientboostingOptions",
    inherit = jmvcore::Options,
    public = list(
        initialize = function(
            time = NULL,
            event = NULL,
            predictors = NULL,
            strata = NULL,
            algorithm = "mboost",
            n_trees = 100,
            learning_rate = 0.1,
            max_depth = 3,
            min_node_size = 10,
            subsample = 1,
            cv_folds = 5,
            early_stopping = TRUE,
            patience = 10,
            reg_alpha = 0,
            reg_lambda = 1,
            variable_selection = TRUE,
            importance_threshold = 0.01,
            show_convergence = TRUE,
            show_importance = TRUE,
            show_predictions = FALSE,
            plot_convergence = TRUE,
            plot_importance = TRUE,
            plot_partial = FALSE,
            plot_survival = FALSE,
            interaction_depth = 1,
            bag_fraction = 0.5,
            random_seed = 123, ...) {

            super$initialize(
                package="ClinicoPath",
                name="gradientboosting",
                requiresData=TRUE,
                ...)

            private$..time <- jmvcore::OptionVariable$new(
                "time",
                time,
                suggested=list(
                    "continuous"),
                permitted=list(
                    "numeric"))
            private$..event <- jmvcore::OptionVariable$new(
                "event",
                event,
                suggested=list(
                    "ordinal",
                    "nominal"),
                permitted=list(
                    "factor",
                    "numeric"))
            private$..predictors <- jmvcore::OptionVariables$new(
                "predictors",
                predictors,
                suggested=list(
                    "continuous",
                    "ordinal",
                    "nominal"),
                permitted=list(
                    "numeric",
                    "factor"))
            private$..strata <- jmvcore::OptionVariable$new(
                "strata",
                strata,
                suggested=list(
                    "nominal",
                    "ordinal"),
                permitted=list(
                    "factor"))
            private$..algorithm <- jmvcore::OptionList$new(
                "algorithm",
                algorithm,
                options=list(
                    "mboost",
                    "gbm",
                    "xgboost"),
                default="mboost")
            private$..n_trees <- jmvcore::OptionInteger$new(
                "n_trees",
                n_trees,
                default=100,
                min=10,
                max=5000)
            private$..learning_rate <- jmvcore::OptionNumber$new(
                "learning_rate",
                learning_rate,
                default=0.1,
                min=0.001,
                max=1)
            private$..max_depth <- jmvcore::OptionInteger$new(
                "max_depth",
                max_depth,
                default=3,
                min=1,
                max=10)
            private$..min_node_size <- jmvcore::OptionInteger$new(
                "min_node_size",
                min_node_size,
                default=10,
                min=1,
                max=100)
            private$..subsample <- jmvcore::OptionNumber$new(
                "subsample",
                subsample,
                default=1,
                min=0.1,
                max=1)
            private$..cv_folds <- jmvcore::OptionInteger$new(
                "cv_folds",
                cv_folds,
                default=5,
                min=3,
                max=20)
            private$..early_stopping <- jmvcore::OptionBool$new(
                "early_stopping",
                early_stopping,
                default=TRUE)
            private$..patience <- jmvcore::OptionInteger$new(
                "patience",
                patience,
                default=10,
                min=1,
                max=100)
            private$..reg_alpha <- jmvcore::OptionNumber$new(
                "reg_alpha",
                reg_alpha,
                default=0,
                min=0,
                max=10)
            private$..reg_lambda <- jmvcore::OptionNumber$new(
                "reg_lambda",
                reg_lambda,
                default=1,
                min=0,
                max=10)
            private$..variable_selection <- jmvcore::OptionBool$new(
                "variable_selection",
                variable_selection,
                default=TRUE)
            private$..importance_threshold <- jmvcore::OptionNumber$new(
                "importance_threshold",
                importance_threshold,
                default=0.01,
                min=0,
                max=1)
            private$..show_convergence <- jmvcore::OptionBool$new(
                "show_convergence",
                show_convergence,
                default=TRUE)
            private$..show_importance <- jmvcore::OptionBool$new(
                "show_importance",
                show_importance,
                default=TRUE)
            private$..show_predictions <- jmvcore::OptionBool$new(
                "show_predictions",
                show_predictions,
                default=FALSE)
            private$..plot_convergence <- jmvcore::OptionBool$new(
                "plot_convergence",
                plot_convergence,
                default=TRUE)
            private$..plot_importance <- jmvcore::OptionBool$new(
                "plot_importance",
                plot_importance,
                default=TRUE)
            private$..plot_partial <- jmvcore::OptionBool$new(
                "plot_partial",
                plot_partial,
                default=FALSE)
            private$..plot_survival <- jmvcore::OptionBool$new(
                "plot_survival",
                plot_survival,
                default=FALSE)
            private$..interaction_depth <- jmvcore::OptionInteger$new(
                "interaction_depth",
                interaction_depth,
                default=1,
                min=1,
                max=5)
            private$..bag_fraction <- jmvcore::OptionNumber$new(
                "bag_fraction",
                bag_fraction,
                default=0.5,
                min=0.1,
                max=1)
            private$..random_seed <- jmvcore::OptionInteger$new(
                "random_seed",
                random_seed,
                default=123,
                min=1,
                max=999999)

            self$.addOption(private$..time)
            self$.addOption(private$..event)
            self$.addOption(private$..predictors)
            self$.addOption(private$..strata)
            self$.addOption(private$..algorithm)
            self$.addOption(private$..n_trees)
            self$.addOption(private$..learning_rate)
            self$.addOption(private$..max_depth)
            self$.addOption(private$..min_node_size)
            self$.addOption(private$..subsample)
            self$.addOption(private$..cv_folds)
            self$.addOption(private$..early_stopping)
            self$.addOption(private$..patience)
            self$.addOption(private$..reg_alpha)
            self$.addOption(private$..reg_lambda)
            self$.addOption(private$..variable_selection)
            self$.addOption(private$..importance_threshold)
            self$.addOption(private$..show_convergence)
            self$.addOption(private$..show_importance)
            self$.addOption(private$..show_predictions)
            self$.addOption(private$..plot_convergence)
            self$.addOption(private$..plot_importance)
            self$.addOption(private$..plot_partial)
            self$.addOption(private$..plot_survival)
            self$.addOption(private$..interaction_depth)
            self$.addOption(private$..bag_fraction)
            self$.addOption(private$..random_seed)
        }),
    active = list(
        time = function() private$..time$value,
        event = function() private$..event$value,
        predictors = function() private$..predictors$value,
        strata = function() private$..strata$value,
        algorithm = function() private$..algorithm$value,
        n_trees = function() private$..n_trees$value,
        learning_rate = function() private$..learning_rate$value,
        max_depth = function() private$..max_depth$value,
        min_node_size = function() private$..min_node_size$value,
        subsample = function() private$..subsample$value,
        cv_folds = function() private$..cv_folds$value,
        early_stopping = function() private$..early_stopping$value,
        patience = function() private$..patience$value,
        reg_alpha = function() private$..reg_alpha$value,
        reg_lambda = function() private$..reg_lambda$value,
        variable_selection = function() private$..variable_selection$value,
        importance_threshold = function() private$..importance_threshold$value,
        show_convergence = function() private$..show_convergence$value,
        show_importance = function() private$..show_importance$value,
        show_predictions = function() private$..show_predictions$value,
        plot_convergence = function() private$..plot_convergence$value,
        plot_importance = function() private$..plot_importance$value,
        plot_partial = function() private$..plot_partial$value,
        plot_survival = function() private$..plot_survival$value,
        interaction_depth = function() private$..interaction_depth$value,
        bag_fraction = function() private$..bag_fraction$value,
        random_seed = function() private$..random_seed$value),
    private = list(
        ..time = NA,
        ..event = NA,
        ..predictors = NA,
        ..strata = NA,
        ..algorithm = NA,
        ..n_trees = NA,
        ..learning_rate = NA,
        ..max_depth = NA,
        ..min_node_size = NA,
        ..subsample = NA,
        ..cv_folds = NA,
        ..early_stopping = NA,
        ..patience = NA,
        ..reg_alpha = NA,
        ..reg_lambda = NA,
        ..variable_selection = NA,
        ..importance_threshold = NA,
        ..show_convergence = NA,
        ..show_importance = NA,
        ..show_predictions = NA,
        ..plot_convergence = NA,
        ..plot_importance = NA,
        ..plot_partial = NA,
        ..plot_survival = NA,
        ..interaction_depth = NA,
        ..bag_fraction = NA,
        ..random_seed = NA)
)

gradientboostingResults <- if (requireNamespace("jmvcore", quietly=TRUE)) R6::R6Class(
    "gradientboostingResults",
    inherit = jmvcore::Group,
    active = list(
        todo = function() private$.items[["todo"]],
        modelSummary = function() private$.items[["modelSummary"]],
        convergenceStats = function() private$.items[["convergenceStats"]],
        variableImportance = function() private$.items[["variableImportance"]],
        predictions = function() private$.items[["predictions"]],
        convergencePlot = function() private$.items[["convergencePlot"]],
        importancePlot = function() private$.items[["importancePlot"]],
        partialPlots = function() private$.items[["partialPlots"]],
        survivalPlot = function() private$.items[["survivalPlot"]]),
    private = list(),
    public=list(
        initialize=function(options) {
            super$initialize(
                options=options,
                name="",
                title="Gradient Boosting for Survival Analysis",
                refs=list(
                    "GradientBoosting",
                    "Survival",
                    "mboost",
                    "gbm",
                    "xgboost",
                    "ClinicoPathJamoviModule"))
            self$add(jmvcore::Html$new(
                options=options,
                name="todo",
                title="TODO",
                visible=TRUE))
            self$add(jmvcore::Table$new(
                options=options,
                name="modelSummary",
                title="Model Summary",
                visible="(show_convergence)",
                rows=0,
                columns=list(
                    list(
                        `name`="parameter", 
                        `title`="Parameter", 
                        `type`="text"),
                    list(
                        `name`="value", 
                        `title`="Value", 
                        `type`="text"))))
            self$add(jmvcore::Table$new(
                options=options,
                name="convergenceStats",
                title="Convergence Statistics",
                visible="(show_convergence)",
                rows=0,
                columns=list(
                    list(
                        `name`="metric", 
                        `title`="Metric", 
                        `type`="text"),
                    list(
                        `name`="training", 
                        `title`="Training", 
                        `type`="number", 
                        `format`="zto"),
                    list(
                        `name`="validation", 
                        `title`="Validation", 
                        `type`="number", 
                        `format`="zto"),
                    list(
                        `name`="optimal_trees", 
                        `title`="Optimal Trees", 
                        `type`="integer"))))
            self$add(jmvcore::Table$new(
                options=options,
                name="variableImportance",
                title="Variable Importance",
                visible="(show_importance)",
                rows=0,
                columns=list(
                    list(
                        `name`="variable", 
                        `title`="Variable", 
                        `type`="text"),
                    list(
                        `name`="importance", 
                        `title`="Relative Importance", 
                        `type`="number", 
                        `format`="pc"),
                    list(
                        `name`="rank", 
                        `title`="Rank", 
                        `type`="integer"),
                    list(
                        `name`="selected", 
                        `title`="Selected", 
                        `type`="text"))))
            self$add(jmvcore::Table$new(
                options=options,
                name="predictions",
                title="Model Predictions",
                visible="(show_predictions)",
                rows=0,
                columns=list(
                    list(
                        `name`="case_id", 
                        `title`="Case ID", 
                        `type`="integer"),
                    list(
                        `name`="risk_score", 
                        `title`="Risk Score", 
                        `type`="number", 
                        `format`="zto"),
                    list(
                        `name`="predicted_risk", 
                        `title`="Predicted Risk", 
                        `type`="number", 
                        `format`="pc"),
                    list(
                        `name`="risk_group", 
                        `title`="Risk Group", 
                        `type`="text"))))
            self$add(jmvcore::Image$new(
                options=options,
                name="convergencePlot",
                title="Convergence Diagnostics",
                width=800,
                height=600,
                visible="(plot_convergence)",
                renderFun=".plotConvergence",
                requiresData=TRUE))
            self$add(jmvcore::Image$new(
                options=options,
                name="importancePlot",
                title="Variable Importance Plot",
                width=600,
                height=400,
                visible="(plot_importance)",
                renderFun=".plotImportance",
                requiresData=TRUE))
            self$add(jmvcore::Image$new(
                options=options,
                name="partialPlots",
                title="Partial Dependence Plots",
                width=800,
                height=600,
                visible="(plot_partial)",
                renderFun=".plotPartial",
                requiresData=TRUE))
            self$add(jmvcore::Image$new(
                options=options,
                name="survivalPlot",
                title="Risk Group Survival Curves",
                width=800,
                height=600,
                visible="(plot_survival)",
                renderFun=".plotSurvival",
                requiresData=TRUE))}))

gradientboostingBase <- if (requireNamespace("jmvcore", quietly=TRUE)) R6::R6Class(
    "gradientboostingBase",
    inherit = jmvcore::Analysis,
    public = list(
        initialize = function(options, data=NULL, datasetId="", analysisId="", revision=0) {
            super$initialize(
                package = "ClinicoPath",
                name = "gradientboosting",
                version = c(0,0,31),
                options = options,
                results = gradientboostingResults$new(options=options),
                data = data,
                datasetId = datasetId,
                analysisId = analysisId,
                revision = revision,
                pause = NULL,
                completeWhenFilled = FALSE,
                requiresMissings = FALSE,
                weightsSupport = 'auto')
        }))

#' Gradient Boosting for Survival Analysis
#'
#' Gradient Boosting for survival analysis using ensemble methods that combine 
#' multiple weak learners (typically shallow trees) to create strong 
#' predictive models. This implementation supports both traditional gradient 
#' boosting (gbm) and modern component-wise boosting (mboost) approaches. The 
#' method is particularly effective for high-dimensional survival data and 
#' complex non-linear relationships between predictors and survival outcomes. 
#' Features include automatic variable selection, handling of mixed-type 
#' predictors, built-in cross-validation for optimal stopping, and robust 
#' performance with noisy data. Especially suitable for biomarker discovery, 
#' prognostic modeling, and complex survival prediction tasks.
#' 
#'
#' @examples
#' result <- gradientboosting(
#'     data = mydata,
#'     time = "time_to_event",
#'     event = "event_indicator",
#'     predictors = c("age", "stage", "biomarker1", "biomarker2"),
#'     algorithm = "mboost",
#'     n_trees = 100,
#'     learning_rate = 0.1,
#'     max_depth = 3,
#'     cv_folds = 5
#' )
#'
#' @param data The data as a data frame.
#' @param time Time to event variable (numeric). For right-censored data, this
#'   is the  time from study entry to event or censoring.
#' @param event Event indicator variable. For survival analysis: 0 = censored,
#'   1 = event. For competing risks: 0 = censored, 1+ = different event types.
#' @param predictors Variables to use for boosting. Can include numeric,
#'   ordinal, and  nominal variables. The algorithm automatically handles
#'   mixed-type predictors and performs variable selection.
#' @param strata Optional stratification variable for stratified survival
#'   analysis. Creates separate baseline hazards for each stratum.
#' @param algorithm Boosting algorithm to use. mboost provides component-wise
#'   boosting with statistical framework, gbm offers traditional gradient
#'   boosting, xgboost provides extreme gradient boosting with advanced
#'   regularization.
#' @param n_trees Number of boosting iterations (trees). More trees can
#'   improve performance but may lead to overfitting. Use cross-validation to
#'   determine optimal value.
#' @param learning_rate Learning rate (shrinkage parameter). Lower values
#'   require more trees but often provide better generalization. Typical values:
#'   0.01-0.3.
#' @param max_depth Maximum depth of individual trees. Shallow trees (1-6) are
#'   typically sufficient for boosting. Deeper trees may capture interactions
#'   but increase overfitting risk.
#' @param min_node_size Minimum number of observations in terminal nodes.
#'   Higher values create simpler trees and reduce overfitting.
#' @param subsample Fraction of observations used for each tree. Values < 1.0
#'   introduce stochasticity and can improve generalization (stochastic gradient
#'   boosting).
#' @param cv_folds Number of folds for cross-validation to determine optimal
#'   number of trees and prevent overfitting. Set to 0 to disable
#'   cross-validation.
#' @param early_stopping Use early stopping based on cross-validation to
#'   prevent overfitting. Stops training when validation error stops improving.
#' @param patience Number of iterations without improvement before early
#'   stopping. Higher values allow more exploration but may lead to overfitting.
#' @param reg_alpha L1 (Lasso) regularization parameter for XGBoost. Higher
#'   values increase sparsity by driving coefficients to zero.
#' @param reg_lambda L2 (Ridge) regularization parameter for XGBoost. Higher
#'   values reduce overfitting by penalizing large coefficients.
#' @param variable_selection Perform automatic variable selection during
#'   boosting. Variables with low importance are excluded from final model.
#' @param importance_threshold Minimum relative importance for variable
#'   inclusion in final model. Variables below this threshold are excluded.
#' @param show_convergence Display convergence diagnostics including training
#'   and validation error curves, optimal stopping point, and convergence
#'   statistics.
#' @param show_importance Calculate and display variable importance measures
#'   based on the frequency and improvement of splits.
#' @param show_predictions Generate survival predictions and risk scores for
#'   the training data. Useful for model evaluation and risk stratification.
#' @param plot_convergence Plot training and validation error curves showing
#'   convergence behavior and optimal stopping point.
#' @param plot_importance Generate variable importance plot showing relative
#'   importance of predictors in the boosted model.
#' @param plot_partial Create partial dependence plots for top variables
#'   showing marginal effect on survival hazard.
#' @param plot_survival Plot Kaplan-Meier curves for risk groups defined by
#'   boosted model predictions with statistical comparisons.
#' @param interaction_depth Maximum order of variable interactions to
#'   consider. Higher values capture complex interactions but increase
#'   computational complexity.
#' @param bag_fraction Fraction of variables randomly selected for each tree
#'   (for gbm). Introduces randomness and can improve generalization.
#' @param random_seed Random seed for reproducible results. Change to get
#'   different random splits and variable selections.
#' @return A results object containing:
#' \tabular{llllll}{
#'   \code{results$todo} \tab \tab \tab \tab \tab a html \cr
#'   \code{results$modelSummary} \tab \tab \tab \tab \tab a table \cr
#'   \code{results$convergenceStats} \tab \tab \tab \tab \tab a table \cr
#'   \code{results$variableImportance} \tab \tab \tab \tab \tab a table \cr
#'   \code{results$predictions} \tab \tab \tab \tab \tab a table \cr
#'   \code{results$convergencePlot} \tab \tab \tab \tab \tab an image \cr
#'   \code{results$importancePlot} \tab \tab \tab \tab \tab an image \cr
#'   \code{results$partialPlots} \tab \tab \tab \tab \tab an image \cr
#'   \code{results$survivalPlot} \tab \tab \tab \tab \tab an image \cr
#' }
#'
#' Tables can be converted to data frames with \code{asDF} or \code{\link{as.data.frame}}. For example:
#'
#' \code{results$modelSummary$asDF}
#'
#' \code{as.data.frame(results$modelSummary)}
#'
#' @export
gradientboosting <- function(
    data,
    time,
    event,
    predictors,
    strata,
    algorithm = "mboost",
    n_trees = 100,
    learning_rate = 0.1,
    max_depth = 3,
    min_node_size = 10,
    subsample = 1,
    cv_folds = 5,
    early_stopping = TRUE,
    patience = 10,
    reg_alpha = 0,
    reg_lambda = 1,
    variable_selection = TRUE,
    importance_threshold = 0.01,
    show_convergence = TRUE,
    show_importance = TRUE,
    show_predictions = FALSE,
    plot_convergence = TRUE,
    plot_importance = TRUE,
    plot_partial = FALSE,
    plot_survival = FALSE,
    interaction_depth = 1,
    bag_fraction = 0.5,
    random_seed = 123) {

    if ( ! requireNamespace("jmvcore", quietly=TRUE))
        stop("gradientboosting requires jmvcore to be installed (restart may be required)")

    if ( ! missing(time)) time <- jmvcore::resolveQuo(jmvcore::enquo(time))
    if ( ! missing(event)) event <- jmvcore::resolveQuo(jmvcore::enquo(event))
    if ( ! missing(predictors)) predictors <- jmvcore::resolveQuo(jmvcore::enquo(predictors))
    if ( ! missing(strata)) strata <- jmvcore::resolveQuo(jmvcore::enquo(strata))
    if (missing(data))
        data <- jmvcore::marshalData(
            parent.frame(),
            `if`( ! missing(time), time, NULL),
            `if`( ! missing(event), event, NULL),
            `if`( ! missing(predictors), predictors, NULL),
            `if`( ! missing(strata), strata, NULL))

    for (v in strata) if (v %in% names(data)) data[[v]] <- as.factor(data[[v]])

    options <- gradientboostingOptions$new(
        time = time,
        event = event,
        predictors = predictors,
        strata = strata,
        algorithm = algorithm,
        n_trees = n_trees,
        learning_rate = learning_rate,
        max_depth = max_depth,
        min_node_size = min_node_size,
        subsample = subsample,
        cv_folds = cv_folds,
        early_stopping = early_stopping,
        patience = patience,
        reg_alpha = reg_alpha,
        reg_lambda = reg_lambda,
        variable_selection = variable_selection,
        importance_threshold = importance_threshold,
        show_convergence = show_convergence,
        show_importance = show_importance,
        show_predictions = show_predictions,
        plot_convergence = plot_convergence,
        plot_importance = plot_importance,
        plot_partial = plot_partial,
        plot_survival = plot_survival,
        interaction_depth = interaction_depth,
        bag_fraction = bag_fraction,
        random_seed = random_seed)

    analysis <- gradientboostingClass$new(
        options = options,
        data = data)

    analysis$run()

    analysis$results
}

