
# This file is automatically generated, you probably don't want to edit this

roc2dClass <- if (requireNamespace('jmvcore', quietly=TRUE)) R6::R6Class(
    "roc2dClass",
    inherit = roc2dBase,
    private = list(
        .init = function() {
            private$.initInstructions()
        },

        .run = function() {
            if (is.null(self$options$marker1) || is.null(self$options$marker2) ||
                is.null(self$options$outcome)) {
                return()
            }

            # Get data
            data <- self$data
            marker1 <- data[[self$options$marker1]]
            marker2 <- data[[self$options$marker2]]
            outcome <- data[[self$options$outcome]]

            # Remove missing values
            complete_cases <- complete.cases(marker1, marker2, outcome)
            marker1 <- marker1[complete_cases]
            marker2 <- marker2[complete_cases]
            outcome <- outcome[complete_cases]

            # Identify positive class
            if (!is.null(self$options$positive_level)) {
                outcome_binary <- as.numeric(outcome == self$options$positive_level)
            } else {
                outcome_binary <- as.numeric(outcome) - 1
            }

            # Calculate individual marker AUCs
            private$.calculateIndividualAUCs(marker1, marker2, outcome_binary)

            # Calculate combination rules
            private$.calculateCombinationRules(marker1, marker2, outcome_binary)

            # Find optimal combination
            if (self$options$optimize_combination) {
                private$.optimizeLinearCombination(marker1, marker2, outcome_binary)
            }

            # Populate interpretation
            private$.populateInterpretation()
        },

        .initInstructions = function() {
            instructions <- self$results$instructions
            html <- "<h3>Two-Dimensional ROC Analysis</h3>
            <p>Joint evaluation of dual biomarker combinations.</p>

            <h4>Applications:</h4>
            <ul>
                <li><b>ER/PR combinations</b> in breast cancer</li>
                <li><b>Dual IHC markers</b> (e.g., p16/Ki67)</li>
                <li><b>Imaging + biomarker</b> combinations</li>
                <li><b>Multiplex assays</b> with multiple readouts</li>
            </ul>

            <h4>Decision Rules:</h4>
            <ul>
                <li><b>AND:</b> Both markers must be positive (high specificity)</li>
                <li><b>OR:</b> Either marker positive (high sensitivity)</li>
                <li><b>Linear combination:</b> Weighted sum (optimal for many cases)</li>
            </ul>

            <p><b>Note:</b> Implementation requires custom algorithms for 2D optimization.</p>"

            instructions$setContent(html)
        },

        .populateInterpretation = function() {
            interpretation <- self$results$interpretation
            html <- "<h4>Interpretation</h4>
            <p>2D ROC evaluates dual biomarker combinations for improved diagnostic accuracy.</p>
            <p>Compare individual marker AUCs to combination rules to assess added value.</p>
            <p>Optimal linear combination maximizes AUC by finding best weights.</p>"
            interpretation$setContent(html)
        },

        .calculateIndividualAUCs = function(marker1, marker2, outcome) {
            # Calculate AUC for each marker individually
            table <- self$results$individualAUCs

            for (marker_name in c(self$options$marker1, self$options$marker2)) {
                marker_data <- if (marker_name == self$options$marker1) marker1 else marker2

                # Calculate AUC using pROC if available
                if (requireNamespace("pROC", quietly = TRUE)) {
                    tryCatch({
                        roc_obj <- pROC::roc(outcome, marker_data, quiet = TRUE)
                        auc_val <- as.numeric(pROC::auc(roc_obj))
                        ci_obj <- pROC::ci.auc(roc_obj, quiet = TRUE)

                        # Find optimal threshold (Youden index)
                        coords <- pROC::coords(roc_obj, "best", ret = c("threshold", "sensitivity", "specificity"))

                        table$addRow(rowKey = marker_name, values = list(
                            marker = marker_name,
                            auc = auc_val,
                            ci_lower = ci_obj[1],
                            ci_upper = ci_obj[3],
                            optimal_threshold = coords$threshold,
                            sensitivity = coords$sensitivity,
                            specificity = coords$specificity
                        ))
                    }, error = function(e) {
                        # Skip on error
                    })
                } else {
                    # Manual calculation
                    diseased <- marker_data[outcome == 1]
                    healthy <- marker_data[outcome == 0]

                    if (length(diseased) > 0 && length(healthy) > 0) {
                        n1 <- length(diseased)
                        n0 <- length(healthy)
                        rank_sum <- sum(rank(c(diseased, healthy))[1:n1])
                        u_stat <- rank_sum - (n1 * (n1 + 1)) / 2
                        auc_val <- u_stat / (n1 * n0)

                        table$addRow(rowKey = marker_name, values = list(
                            marker = marker_name,
                            auc = auc_val,
                            ci_lower = NA,
                            ci_upper = NA,
                            optimal_threshold = median(marker_data),
                            sensitivity = NA,
                            specificity = NA
                        ))
                    }
                }
            }
        },

        .calculateCombinationRules = function(marker1, marker2, outcome) {
            # Test different combination rules
            table <- self$results$combinationRules

            # Standardize markers to 0-1 scale for fair comparison
            marker1_std <- (marker1 - min(marker1)) / (max(marker1) - min(marker1))
            marker2_std <- (marker2 - min(marker2)) / (max(marker2) - min(marker2))

            # 1. AND rule (both high) - maximize specificity
            combined_and <- pmin(marker1_std, marker2_std)
            auc_and <- private$.calculateAUC(combined_and, outcome)

            # 2. OR rule (either high) - maximize sensitivity
            combined_or <- pmax(marker1_std, marker2_std)
            auc_or <- private$.calculateAUC(combined_or, outcome)

            # 3. Average (simple linear combination)
            combined_avg <- (marker1_std + marker2_std) / 2
            auc_avg <- private$.calculateAUC(combined_avg, outcome)

            # 4. Product rule
            combined_prod <- marker1_std * marker2_std
            auc_prod <- private$.calculateAUC(combined_prod, outcome)

            # 5. Maximum (most optimistic)
            combined_max <- pmax(marker1_std, marker2_std)
            auc_max <- private$.calculateAUC(combined_max, outcome)

            # Populate table
            rules <- list(
                list(name = "AND (Min)", rule = "min(M1, M2)", auc = auc_and, use = "High specificity"),
                list(name = "OR (Max)", rule = "max(M1, M2)", auc = auc_or, use = "High sensitivity"),
                list(name = "Average", rule = "(M1 + M2)/2", auc = auc_avg, use = "Balanced"),
                list(name = "Product", rule = "M1 × M2", auc = auc_prod, use = "Both required"),
                list(name = "Maximum", rule = "max(M1, M2)", auc = auc_max, use = "Either sufficient")
            )

            for (i in seq_along(rules)) {
                rule <- rules[[i]]
                table$addRow(rowKey = i, values = list(
                    combination = rule$name,
                    formula = rule$rule,
                    auc = rule$auc,
                    clinical_use = rule$use
                ))
            }
        },

        .optimizeLinearCombination = function(marker1, marker2, outcome) {
            # Find optimal linear combination: w1*M1 + w2*M2
            # using grid search

            # Standardize markers
            marker1_std <- (marker1 - min(marker1)) / (max(marker1) - min(marker1))
            marker2_std <- (marker2 - min(marker2)) / (max(marker2) - min(marker2))

            # Grid search over weights
            weights <- seq(0, 1, by = 0.05)
            best_auc <- 0
            best_w1 <- 0.5
            best_w2 <- 0.5

            for (w1 in weights) {
                w2 <- 1 - w1  # Weights sum to 1

                combined <- w1 * marker1_std + w2 * marker2_std
                auc_val <- private$.calculateAUC(combined, outcome)

                if (auc_val > best_auc) {
                    best_auc <- auc_val
                    best_w1 <- w1
                    best_w2 <- w2
                }
            }

            # Populate optimal combination table
            table <- self$results$optimalCombination

            table$setRow(rowNo = 1, values = list(
                weight1 = best_w1,
                weight2 = best_w2,
                auc_optimal = best_auc,
                formula = sprintf("%.2f × %s + %.2f × %s",
                                best_w1, self$options$marker1,
                                best_w2, self$options$marker2),
                improvement = sprintf("%.3f vs individual", best_auc)
            ))
        },

        .calculateAUC = function(predictor, outcome) {
            # Helper function to calculate AUC
            if (requireNamespace("pROC", quietly = TRUE)) {
                tryCatch({
                    roc_obj <- pROC::roc(outcome, predictor, quiet = TRUE)
                    return(as.numeric(pROC::auc(roc_obj)))
                }, error = function(e) {
                    return(NA)
                })
            } else {
                # Manual Mann-Whitney U
                diseased <- predictor[outcome == 1]
                healthy <- predictor[outcome == 0]

                if (length(diseased) > 0 && length(healthy) > 0) {
                    n1 <- length(diseased)
                    n0 <- length(healthy)
                    rank_sum <- sum(rank(c(diseased, healthy))[1:n1])
                    u_stat <- rank_sum - (n1 * (n1 + 1)) / 2
                    return(u_stat / (n1 * n0))
                }
                return(NA)
            }
        },

        .plot2DROC = function(image, ...) {
            # TODO: Plot 2D ROC surface
        }
    )
)
