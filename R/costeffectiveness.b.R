
# This file is automatically generated, you probably don't want to edit this

costeffectivenessClass <- if (requireNamespace('jmvcore', quietly=TRUE)) R6::R6Class(
    "costeffectivenessClass",
    inherit = costeffectivenessBase,
    private = list(
        .init = function() {
            private$.initInstructions()
        },

        .run = function() {
            # Check for required inputs
            if (is.null(self$options$strategy) ||
                is.null(self$options$cost) ||
                is.null(self$options$effectiveness)) {
                return()
            }

            # Get data with variable escaping for special characters
            data <- self$data
            strategyVar <- private$.escapeVar(self$options$strategy)
            costVar <- private$.escapeVar(self$options$cost)
            effectivenessVar <- private$.escapeVar(self$options$effectiveness)

            strategy <- data[[strategyVar]]
            cost <- as.numeric(data[[costVar]])
            effectiveness <- as.numeric(data[[effectivenessVar]])

            # Remove missing values
            complete_cases <- complete.cases(strategy, cost, effectiveness)
            strategy <- strategy[complete_cases]
            cost <- cost[complete_cases]
            effectiveness <- effectiveness[complete_cases]

            if (length(cost) < 10) {
                stop("Insufficient data for cost-effectiveness analysis. Need at least 10 complete observations.")
            }

            # Validate strategies
            strategy_levels <- levels(strategy)
            if (length(strategy_levels) < 2) {
                stop("Need at least 2 strategies for comparison.")
            }

            # Validate comparator level exists and has sufficient data
            comparator_level <- self$options$comparator_level
            if (is.null(comparator_level) || comparator_level == "") {
                comparator_level <- strategy_levels[1]
            }

            # Check comparator exists in filtered data
            if (!(comparator_level %in% strategy_levels)) {
                stop(sprintf("Comparator strategy '%s' not found in data. Available strategies: %s",
                            comparator_level, paste(strategy_levels, collapse=", ")))
            }

            # Check comparator has observations after filtering
            comp_idx <- strategy == comparator_level
            if (sum(comp_idx) < 3) {
                stop(sprintf("Insufficient observations for comparator strategy '%s' (n=%d). Need at least 3 observations after removing missing values.",
                            comparator_level, sum(comp_idx)))
            }

            # Check all other strategies have sufficient observations
            for (strat in strategy_levels) {
                strat_idx <- strategy == strat
                if (sum(strat_idx) < 3) {
                    stop(sprintf("Insufficient observations for strategy '%s' (n=%d). Need at least 3 observations per strategy.",
                                strat, sum(strat_idx)))
                }
            }

            # Set random seed for reproducibility
            set.seed(self$options$random_seed)

            # Perform cost-effectiveness analysis
            tryCatch({
                # Strategy summary
                private$.populateStrategySummary(strategy, cost, effectiveness)

                # Incremental analysis
                if (self$options$calculate_incremental) {
                    private$.performIncrementalAnalysis(strategy, cost, effectiveness)
                }

                # Net Monetary Benefit
                if (self$options$net_monetary_benefit) {
                    private$.calculateNetBenefit(strategy, cost, effectiveness)
                }

                # Multiple WTP thresholds
                if (self$options$multiple_wtp_thresholds) {
                    private$.evaluateMultipleWTP(strategy, cost, effectiveness)
                }

                # Dominance analysis
                if (self$options$dominance_analysis) {
                    private$.performDominanceAnalysis(strategy, cost, effectiveness)
                }

                # Subgroup analysis
                if (self$options$subgroup_analysis && !is.null(self$options$subgroup_variable)) {
                    subgroupVar <- private$.escapeVar(self$options$subgroup_variable)
                    private$.performSubgroupAnalysis(strategy, cost, effectiveness,
                                                    data[[subgroupVar]][complete_cases])
                }

                # Deterministic sensitivity analysis
                if (self$options$deterministic_sensitivity) {
                    private$.performDeterministicSA(strategy, cost, effectiveness, data[complete_cases, ])
                }

                # Probabilistic sensitivity analysis
                if (self$options$probabilistic_sensitivity) {
                    private$.performProbabilisticSA(strategy, cost, effectiveness)
                }

                # Value of Information analysis (requires PSA)
                if (self$options$voi_analysis && self$options$probabilistic_sensitivity) {
                    private$.performVoIAnalysis(strategy, cost, effectiveness)
                }

                # Populate interpretation
                private$.populateInterpretation()

            }, error = function(e) {
                stop(paste0("Error in cost-effectiveness analysis: ", e$message))
            })
        },

        .initInstructions = function() {
            instructions <- self$results$instructions
            html <- "<h3>Cost-Effectiveness Analysis</h3>
            <p>Economic evaluation of diagnostic tests and clinical strategies.</p>

            <h4>Required Inputs:</h4>
            <ul>
                <li><b>Strategy Variable:</b> Factor indicating which strategy was used</li>
                <li><b>Cost Variable:</b> Total cost per patient (include test + follow-up)</li>
                <li><b>Effectiveness Variable:</b> Outcome measure (correct diagnoses, QALYs, etc.)</li>
                <li><b>Comparator:</b> Baseline strategy for comparison</li>
            </ul>

            <h4>Key Metrics:</h4>
            <ul>
                <li><b>ICER:</b> Incremental Cost-Effectiveness Ratio = ΔCost / ΔEffect</li>
                <li><b>NMB:</b> Net Monetary Benefit = (Effect × WTP) - Cost</li>
                <li><b>Dominance:</b> Strategy with lower cost AND higher effect dominates</li>
                <li><b>WTP Threshold:</b> Maximum acceptable cost per unit of effectiveness</li>
            </ul>

            <h4>Clinical Applications:</h4>
            <ul>
                <li><b>Digital Pathology:</b> Scanner ROI analysis</li>
                <li><b>AI Systems:</b> Cost-effectiveness of AI-assisted diagnosis</li>
                <li><b>Multiplex IHC:</b> Economic justification vs sequential testing</li>
                <li><b>Triage Systems:</b> Cost per case correctly triaged</li>
            </ul>

            <h4>Interpretation:</h4>
            <ul>
                <li><b>ICER < WTP:</b> New strategy is cost-effective</li>
                <li><b>Positive NMB:</b> Strategy provides value at that WTP</li>
                <li><b>Dominant:</b> Lower cost AND more effective (always adopt)</li>
                <li><b>Dominated:</b> Higher cost AND less effective (never adopt)</li>
            </ul>

            <p><b>Note:</b> Ensure costs and effects are measured consistently across strategies.</p>"

            instructions$setContent(html)
        },

        .populateStrategySummary = function(strategy, cost, effectiveness) {
            table <- self$results$strategySummary
            strategy_levels <- levels(strategy)

            for (strat in strategy_levels) {
                strat_idx <- strategy == strat
                strat_cost <- cost[strat_idx]
                strat_effect <- effectiveness[strat_idx]

                mean_cost <- mean(strat_cost, na.rm = TRUE)
                mean_effect <- mean(strat_effect, na.rm = TRUE)
                n <- sum(strat_idx)

                # Calculate confidence intervals if requested
                cost_ci_lower <- NA
                cost_ci_upper <- NA
                effect_ci_lower <- NA
                effect_ci_upper <- NA

                if (self$options$confidence_intervals) {
                    # Bootstrap confidence intervals
                    if (self$options$ci_method == "bootstrap" || self$options$ci_method == "bca") {
                        boot_results <- private$.bootstrapCI(strat_cost, strat_effect)
                        cost_ci_lower <- boot_results$cost_ci[1]
                        cost_ci_upper <- boot_results$cost_ci[2]
                        effect_ci_lower <- boot_results$effect_ci[1]
                        effect_ci_upper <- boot_results$effect_ci[2]
                    } else {
                        # Parametric CI
                        cost_se <- sd(strat_cost, na.rm = TRUE) / sqrt(n)
                        effect_se <- sd(strat_effect, na.rm = TRUE) / sqrt(n)
                        z <- qnorm((1 + self$options$confidence_level) / 2)

                        cost_ci_lower <- mean_cost - z * cost_se
                        cost_ci_upper <- mean_cost + z * cost_se
                        effect_ci_lower <- mean_effect - z * effect_se
                        effect_ci_upper <- mean_effect + z * effect_se
                    }
                }

                table$addRow(rowKey = strat, values = list(
                    strategy = strat,
                    n = n,
                    mean_cost = mean_cost,
                    cost_ci_lower = cost_ci_lower,
                    cost_ci_upper = cost_ci_upper,
                    mean_effect = mean_effect,
                    effect_ci_lower = effect_ci_lower,
                    effect_ci_upper = effect_ci_upper
                ))
            }
        },

        .performIncrementalAnalysis = function(strategy, cost, effectiveness) {
            table <- self$results$incrementalAnalysis
            strategy_levels <- levels(strategy)

            # Get comparator
            comparator_level <- self$options$comparator_level
            if (is.null(comparator_level) || comparator_level == "") {
                comparator_level <- strategy_levels[1]
            }

            # Calculate comparator means
            comp_idx <- strategy == comparator_level
            comp_cost <- mean(cost[comp_idx], na.rm = TRUE)
            comp_effect <- mean(effectiveness[comp_idx], na.rm = TRUE)

            for (strat in strategy_levels) {
                strat_idx <- strategy == strat
                strat_cost <- mean(cost[strat_idx], na.rm = TRUE)
                strat_effect <- mean(effectiveness[strat_idx], na.rm = TRUE)

                incremental_cost <- strat_cost - comp_cost
                incremental_effect <- strat_effect - comp_effect

                # Calculate ICER
                icer <- NA
                icer_interpretation <- ""
                dominance <- ""

                if (self$options$calculate_icer && strat != comparator_level) {
                    if (abs(incremental_effect) < 1e-10) {
                        icer_interpretation <- "No difference in effectiveness"
                        dominance <- if (incremental_cost < 0) "Dominant (less costly)" else "Dominated (more costly)"
                    } else {
                        icer <- incremental_cost / incremental_effect

                        if (incremental_cost < 0 && incremental_effect > 0) {
                            icer_interpretation <- "Dominant (less costly, more effective)"
                            dominance <- "Dominant"
                        } else if (incremental_cost > 0 && incremental_effect < 0) {
                            icer_interpretation <- "Dominated (more costly, less effective)"
                            dominance <- "Dominated"
                        } else if (incremental_cost > 0 && incremental_effect > 0) {
                            # Check against WTP threshold
                            wtp <- self$options$wtp_threshold
                            if (icer < wtp) {
                                icer_interpretation <- sprintf("Cost-effective at WTP $%s", format(wtp, big.mark=","))
                            } else {
                                icer_interpretation <- sprintf("NOT cost-effective at WTP $%s", format(wtp, big.mark=","))
                            }
                            dominance <- "Trade-off"
                        } else {
                            # incremental_cost < 0 && incremental_effect < 0
                            icer_interpretation <- "Trade-off (less costly, less effective)"
                            dominance <- "Trade-off"
                        }
                    }
                }

                table$addRow(rowKey = strat, values = list(
                    strategy = strat,
                    incremental_cost = incremental_cost,
                    incremental_effect = incremental_effect,
                    icer = icer,
                    icer_interpretation = icer_interpretation,
                    dominance = dominance
                ))
            }
        },

        .calculateNetBenefit = function(strategy, cost, effectiveness) {
            table <- self$results$netBenefit
            strategy_levels <- levels(strategy)
            wtp <- self$options$wtp_threshold

            max_nmb <- -Inf
            optimal_strategy <- ""

            for (strat in strategy_levels) {
                strat_idx <- strategy == strat
                strat_cost <- cost[strat_idx]
                strat_effect <- effectiveness[strat_idx]

                mean_cost <- mean(strat_cost, na.rm = TRUE)
                mean_effect <- mean(strat_effect, na.rm = TRUE)

                # Calculate NMB
                nmb <- (mean_effect * wtp) - mean_cost

                # Track optimal
                if (nmb > max_nmb) {
                    max_nmb <- nmb
                    optimal_strategy <- strat
                }

                # Calculate confidence interval for NMB if requested
                nmb_ci_lower <- NA
                nmb_ci_upper <- NA

                if (self$options$confidence_intervals) {
                    if (self$options$ci_method == "bootstrap" || self$options$ci_method == "bca") {
                        boot_results <- private$.bootstrapNMB(strat_cost, strat_effect, wtp)
                        nmb_ci_lower <- boot_results$nmb_ci[1]
                        nmb_ci_upper <- boot_results$nmb_ci[2]
                    } else {
                        # Parametric approximation
                        n <- length(strat_cost)
                        cost_var <- var(strat_cost, na.rm = TRUE)
                        effect_var <- var(strat_effect, na.rm = TRUE)
                        cost_effect_cov <- cov(strat_cost, strat_effect, use = "complete.obs")

                        nmb_var <- (wtp^2 * effect_var) + cost_var - (2 * wtp * cost_effect_cov)
                        nmb_se <- sqrt(nmb_var / n)

                        z <- qnorm((1 + self$options$confidence_level) / 2)
                        nmb_ci_lower <- nmb - z * nmb_se
                        nmb_ci_upper <- nmb + z * nmb_se
                    }
                }

                optimal_text <- if (strat == optimal_strategy) "Yes (Maximum NMB)" else "No"

                table$addRow(rowKey = strat, values = list(
                    strategy = strat,
                    wtp_threshold = wtp,
                    nmb = nmb,
                    nmb_ci_lower = nmb_ci_lower,
                    nmb_ci_upper = nmb_ci_upper,
                    optimal = optimal_text,
                    probability_optimal = NA  # Will be populated by PSA if enabled
                ))
            }
        },

        .evaluateMultipleWTP = function(strategy, cost, effectiveness) {
            table <- self$results$multipleWTP

            # Parse WTP range
            wtp_str <- self$options$wtp_range
            wtp_values <- as.numeric(unlist(strsplit(gsub(" ", "", wtp_str), ",")))

            # Get comparator
            comparator_level <- self$options$comparator_level
            if (is.null(comparator_level) || comparator_level == "") {
                comparator_level <- levels(strategy)[1]
            }

            comp_idx <- strategy == comparator_level
            comp_cost <- mean(cost[comp_idx], na.rm = TRUE)
            comp_effect <- mean(effectiveness[comp_idx], na.rm = TRUE)

            for (wtp in wtp_values) {
                max_nmb <- -Inf
                optimal_strategy <- ""
                max_nmb_val <- NA

                # Find optimal strategy at this WTP
                for (strat in levels(strategy)) {
                    strat_idx <- strategy == strat
                    mean_cost <- mean(cost[strat_idx], na.rm = TRUE)
                    mean_effect <- mean(effectiveness[strat_idx], na.rm = TRUE)

                    nmb <- (mean_effect * wtp) - mean_cost

                    if (nmb > max_nmb) {
                        max_nmb <- nmb
                        optimal_strategy <- strat
                        max_nmb_val <- nmb
                    }
                }

                # Calculate ICER for optimal vs comparator
                opt_idx <- strategy == optimal_strategy
                opt_cost <- mean(cost[opt_idx], na.rm = TRUE)
                opt_effect <- mean(effectiveness[opt_idx], na.rm = TRUE)

                icer_vs_comp <- NA
                if (abs(opt_effect - comp_effect) > 1e-10) {
                    icer_vs_comp <- (opt_cost - comp_cost) / (opt_effect - comp_effect)
                }

                cost_effective <- if (icer_vs_comp <= wtp || is.na(icer_vs_comp)) "Yes" else "No"

                table$addRow(rowKey = as.character(wtp), values = list(
                    wtp_threshold = wtp,
                    optimal_strategy = optimal_strategy,
                    max_nmb = max_nmb_val,
                    icer_vs_comparator = icer_vs_comp,
                    cost_effective = cost_effective
                ))
            }
        },

        .performDominanceAnalysis = function(strategy, cost, effectiveness) {
            table <- self$results$dominanceTable
            strategy_levels <- levels(strategy)

            # Calculate mean cost and effect for each strategy
            strategy_data <- data.frame(
                strategy = character(),
                mean_cost = numeric(),
                mean_effect = numeric(),
                stringsAsFactors = FALSE
            )

            for (strat in strategy_levels) {
                strat_idx <- strategy == strat
                strategy_data <- rbind(strategy_data, data.frame(
                    strategy = strat,
                    mean_cost = mean(cost[strat_idx], na.rm = TRUE),
                    mean_effect = mean(effectiveness[strat_idx], na.rm = TRUE),
                    stringsAsFactors = FALSE
                ))
            }

            # Check for dominance
            for (i in 1:nrow(strategy_data)) {
                strat <- strategy_data$strategy[i]
                cost_i <- strategy_data$mean_cost[i]
                effect_i <- strategy_data$mean_effect[i]

                dominated <- FALSE
                dominated_by <- ""
                reason <- ""
                on_frontier <- TRUE

                # Check if dominated by any other strategy
                for (j in 1:nrow(strategy_data)) {
                    if (i != j) {
                        cost_j <- strategy_data$mean_cost[j]
                        effect_j <- strategy_data$mean_effect[j]

                        # Absolute dominance: j is cheaper AND more effective
                        if (cost_j <= cost_i && effect_j >= effect_i && (cost_j < cost_i || effect_j > effect_i)) {
                            dominated <- TRUE
                            dominated_by <- strategy_data$strategy[j]
                            reason <- "Absolutely dominated (more costly and/or less effective)"
                            on_frontier <- FALSE
                            break
                        }
                    }
                }

                table$addRow(rowKey = strat, values = list(
                    strategy = strat,
                    dominated = if (dominated) "Yes" else "No",
                    dominated_by = dominated_by,
                    reason = reason,
                    on_frontier = if (on_frontier) "Yes" else "No"
                ))
            }
        },

        .performSubgroupAnalysis = function(strategy, cost, effectiveness, subgroup) {
            table <- self$results$subgroupCEA

            # Get comparator
            comparator_level <- self$options$comparator_level
            if (is.null(comparator_level) || comparator_level == "") {
                comparator_level <- levels(strategy)[1]
            }

            subgroup_levels <- levels(subgroup)
            strategy_levels <- levels(strategy)

            wtp <- self$options$wtp_threshold

            for (sg in subgroup_levels) {
                sg_idx <- subgroup == sg

                # Comparator in this subgroup
                comp_sg_idx <- sg_idx & strategy == comparator_level
                if (sum(comp_sg_idx) < 3) next

                comp_cost_sg <- mean(cost[comp_sg_idx], na.rm = TRUE)
                comp_effect_sg <- mean(effectiveness[comp_sg_idx], na.rm = TRUE)

                for (strat in strategy_levels) {
                    if (strat == comparator_level) next

                    strat_sg_idx <- sg_idx & strategy == strat
                    if (sum(strat_sg_idx) < 3) next

                    strat_cost_sg <- mean(cost[strat_sg_idx], na.rm = TRUE)
                    strat_effect_sg <- mean(effectiveness[strat_sg_idx], na.rm = TRUE)

                    incremental_cost <- strat_cost_sg - comp_cost_sg
                    incremental_effect <- strat_effect_sg - comp_effect_sg

                    icer <- NA
                    cost_effective <- ""

                    if (abs(incremental_effect) > 1e-10) {
                        icer <- incremental_cost / incremental_effect
                        cost_effective <- if (icer < wtp) "Yes" else "No"
                    }

                    table$addRow(rowKey = paste0(sg, "_", strat), values = list(
                        subgroup = as.character(sg),
                        strategy = strat,
                        n = sum(strat_sg_idx),
                        incremental_cost = incremental_cost,
                        incremental_effect = incremental_effect,
                        icer = icer,
                        cost_effective_at_wtp = cost_effective
                    ))
                }
            }
        },

        .performDeterministicSA = function(strategy, cost, effectiveness, data) {
            # One-way deterministic sensitivity analysis for ALL strategy comparisons
            # Vary cost and effectiveness parameters and recalculate ICER
            table <- self$results$sensitivityAnalysis

            # Get comparator and target strategies
            comparator_level <- self$options$comparator_level
            if (is.null(comparator_level) || comparator_level == "") {
                comparator_level <- levels(strategy)[1]
            }

            strategy_levels <- levels(strategy)
            target_strategies <- strategy_levels[strategy_levels != comparator_level]

            if (length(target_strategies) == 0) {
                table$addRow(rowKey = "note", values = list(
                    parameter = "No comparison strategy available",
                    base_value = NA, low_value = NA, high_value = NA,
                    icer_at_low = NA, icer_at_high = NA, icer_range = NA, sensitivity_rank = NA
                ))
                return()
            }

            # Calculate base case comparator values (shared across all comparisons)
            comp_idx <- strategy == comparator_level
            base_comp_cost <- mean(cost[comp_idx], na.rm = TRUE)
            base_comp_effect <- mean(effectiveness[comp_idx], na.rm = TRUE)

            range_pct <- self$options$sensitivity_range_pct / 100

            # Storage for ALL results across ALL strategies
            all_results <- list()
            result_counter <- 0

            # Loop over ALL target strategies (not just first one)
            for (target_strategy in target_strategies) {
                target_idx <- strategy == target_strategy

                base_target_cost <- mean(cost[target_idx], na.rm = TRUE)
                base_target_effect <- mean(effectiveness[target_idx], na.rm = TRUE)

                base_inc_cost <- base_target_cost - base_comp_cost
                base_inc_effect <- base_target_effect - base_comp_effect

                # Skip if no difference in effectiveness
                if (abs(base_inc_effect) < 1e-10) {
                    result_counter <- result_counter + 1
                    all_results[[result_counter]] <- list(
                        parameter = sprintf("%s: No effect difference", target_strategy),
                        base_value = NA,
                        low_value = NA,
                        high_value = NA,
                        icer_at_low = NA,
                        icer_at_high = NA,
                        icer_range = 0,
                        sensitivity_rank = 999
                    )
                    next
                }

                base_icer <- base_inc_cost / base_inc_effect

                # Parameters to vary for THIS comparison
                param_names <- c(
                    paste0(target_strategy, " Cost"),
                    paste0(target_strategy, " Effectiveness"),
                    paste0(comparator_level, " Cost"),
                    paste0(comparator_level, " Effectiveness")
                )
                base_values <- c(base_target_cost, base_target_effect, base_comp_cost, base_comp_effect)

                # Analyze each parameter
                for (i in 1:4) {
                    param_name <- param_names[i]
                    base_val <- base_values[i]
                    low_val <- base_val * (1 - range_pct)
                    high_val <- base_val * (1 + range_pct)

                    # Calculate ICER at low value
                    if (i == 1) {  # Target cost low
                        icer_low <- ((base_target_cost * (1 - range_pct)) - base_comp_cost) / base_inc_effect
                    } else if (i == 2) {  # Target effect low
                        low_inc_effect <- (base_target_effect * (1 - range_pct)) - base_comp_effect
                        icer_low <- if (abs(low_inc_effect) > 1e-10) base_inc_cost / low_inc_effect else base_icer
                    } else if (i == 3) {  # Comparator cost low
                        icer_low <- (base_target_cost - (base_comp_cost * (1 - range_pct))) / base_inc_effect
                    } else {  # Comparator effect low
                        low_inc_effect <- base_target_effect - (base_comp_effect * (1 - range_pct))
                        icer_low <- if (abs(low_inc_effect) > 1e-10) base_inc_cost / low_inc_effect else base_icer
                    }

                    # Calculate ICER at high value
                    if (i == 1) {  # Target cost high
                        icer_high <- ((base_target_cost * (1 + range_pct)) - base_comp_cost) / base_inc_effect
                    } else if (i == 2) {  # Target effect high
                        high_inc_effect <- (base_target_effect * (1 + range_pct)) - base_comp_effect
                        icer_high <- if (abs(high_inc_effect) > 1e-10) base_inc_cost / high_inc_effect else base_icer
                    } else if (i == 3) {  # Comparator cost high
                        icer_high <- (base_target_cost - (base_comp_cost * (1 + range_pct))) / base_inc_effect
                    } else {  # Comparator effect high
                        high_inc_effect <- base_target_effect - (base_comp_effect * (1 + range_pct))
                        icer_high <- if (abs(high_inc_effect) > 1e-10) base_inc_cost / high_inc_effect else base_icer
                    }

                    # Calculate range and store
                    icer_range_val <- abs(icer_high - icer_low)

                    result_counter <- result_counter + 1
                    all_results[[result_counter]] <- list(
                        parameter = param_name,
                        base_value = base_val,
                        low_value = low_val,
                        high_value = high_val,
                        icer_at_low = icer_low,
                        icer_at_high = icer_high,
                        icer_range = icer_range_val,
                        sensitivity_rank = NA  # Will be filled after sorting
                    )
                }
            }

            # Sort ALL results by icer_range (descending) for global sensitivity ranking
            if (length(all_results) > 0) {
                ranges <- sapply(all_results, function(x) x$icer_range)
                rank_order <- order(ranges, decreasing = TRUE)

                # Add rows to table in order of sensitivity
                for (rank in 1:length(rank_order)) {
                    idx <- rank_order[rank]
                    result <- all_results[[idx]]
                    result$sensitivity_rank <- rank

                    table$addRow(rowKey = paste0("param_", idx), values = result)
                }
            } else {
                table$addRow(rowKey = "note", values = list(
                    parameter = "No valid comparisons available",
                    base_value = NA, low_value = NA, high_value = NA,
                    icer_at_low = NA, icer_at_high = NA, icer_range = NA, sensitivity_rank = NA
                ))
            }
        },

        .performProbabilisticSA = function(strategy, cost, effectiveness) {
            # Placeholder for probabilistic sensitivity analysis
            # Would run Monte Carlo simulations with parameter uncertainty
            table <- self$results$psaSummary

            n_sims <- self$options$psa_simulations

            # For simplicity, use bootstrap to represent parameter uncertainty
            set.seed(self$options$random_seed)

            strategy_levels <- levels(strategy)
            comparator_level <- self$options$comparator_level
            if (is.null(comparator_level) || comparator_level == "") {
                comparator_level <- strategy_levels[1]
            }

            # Find first non-comparator strategy
            target_strategy <- strategy_levels[strategy_levels != comparator_level][1]

            icer_sims <- numeric(n_sims)

            for (sim in 1:n_sims) {
                # Bootstrap sample
                boot_idx <- sample(length(strategy), replace = TRUE)
                boot_strategy <- strategy[boot_idx]
                boot_cost <- cost[boot_idx]
                boot_effect <- effectiveness[boot_idx]

                # Calculate ICER for this simulation
                comp_idx <- boot_strategy == comparator_level
                target_idx <- boot_strategy == target_strategy

                if (sum(comp_idx) > 0 && sum(target_idx) > 0) {
                    comp_cost <- mean(boot_cost[comp_idx], na.rm = TRUE)
                    comp_effect <- mean(boot_effect[comp_idx], na.rm = TRUE)
                    target_cost <- mean(boot_cost[target_idx], na.rm = TRUE)
                    target_effect <- mean(boot_effect[target_idx], na.rm = TRUE)

                    inc_cost <- target_cost - comp_cost
                    inc_effect <- target_effect - comp_effect

                    if (abs(inc_effect) > 1e-10) {
                        icer_sims[sim] <- inc_cost / inc_effect
                    } else {
                        icer_sims[sim] <- NA
                    }
                }
            }

            # Remove NA values
            icer_sims <- icer_sims[!is.na(icer_sims)]

            mean_icer <- mean(icer_sims, na.rm = TRUE)
            median_icer <- median(icer_sims, na.rm = TRUE)
            icer_ci <- quantile(icer_sims, probs = c((1 - self$options$confidence_level)/2,
                                                     (1 + self$options$confidence_level)/2), na.rm = TRUE)

            wtp <- self$options$wtp_threshold
            prob_cost_effective <- mean(icer_sims < wtp, na.rm = TRUE)
            prob_dominant <- mean(icer_sims < 0, na.rm = TRUE)

            table$setRow(rowNo = 1, values = list(
                n_simulations = n_sims,
                mean_icer = mean_icer,
                median_icer = median_icer,
                icer_ci_lower = icer_ci[1],
                icer_ci_upper = icer_ci[2],
                prob_cost_effective = prob_cost_effective,
                prob_dominant = prob_dominant
            ))
        },

        .performVoIAnalysis = function(strategy, cost, effectiveness) {
            # Value of Information Analysis using PSA results
            wtp <- self$options$wtp_threshold
            population <- self$options$evpi_population
            n_sims <- self$options$psa_simulations

            # Get strategy levels
            strategy_levels <- levels(strategy)
            n_strategies <- length(strategy_levels)

            # Matrices to store simulated costs and effects
            sim_costs <- matrix(NA, nrow = n_sims, ncol = n_strategies)
            sim_effects <- matrix(NA, nrow = n_sims, ncol = n_strategies)
            sim_nmb <- matrix(NA, nrow = n_sims, ncol = n_strategies)

            # Run PSA for each strategy
            for (i in seq_along(strategy_levels)) {
                strat <- strategy_levels[i]
                strat_idx <- which(strategy == strat)

                strat_cost <- cost[strat_idx]
                strat_effect <- effectiveness[strat_idx]

                # Simulate costs and effects
                for (sim in 1:n_sims) {
                    boot_idx <- sample(length(strat_cost), replace = TRUE)

                    # Simulate cost
                    if (self$options$cost_distribution == "gamma") {
                        shape <- mean(strat_cost)^2 / var(strat_cost)
                        scale <- var(strat_cost) / mean(strat_cost)
                        sim_costs[sim, i] <- rgamma(1, shape = shape, scale = scale)
                    } else if (self$options$cost_distribution == "lognormal") {
                        meanlog <- log(mean(strat_cost)) - 0.5 * log(1 + var(strat_cost) / mean(strat_cost)^2)
                        sdlog <- sqrt(log(1 + var(strat_cost) / mean(strat_cost)^2))
                        sim_costs[sim, i] <- rlnorm(1, meanlog = meanlog, sdlog = sdlog)
                    } else {
                        sim_costs[sim, i] <- mean(strat_cost[boot_idx])
                    }

                    # Simulate effect
                    if (self$options$effect_distribution == "beta") {
                        eff_mean <- mean(strat_effect)
                        eff_var <- var(strat_effect)
                        if (eff_mean > 0 && eff_mean < 1 && eff_var > 0) {
                            alpha <- eff_mean * (eff_mean * (1 - eff_mean) / eff_var - 1)
                            beta <- (1 - eff_mean) * (eff_mean * (1 - eff_mean) / eff_var - 1)
                            sim_effects[sim, i] <- rbeta(1, shape1 = alpha, shape2 = beta)
                        } else {
                            sim_effects[sim, i] <- mean(strat_effect[boot_idx])
                        }
                    } else {
                        sim_effects[sim, i] <- mean(strat_effect[boot_idx])
                    }

                    # Calculate NMB
                    sim_nmb[sim, i] <- (sim_effects[sim, i] * wtp) - sim_costs[sim, i]
                }
            }

            # Calculate EVPI
            # 1. Find optimal strategy for each simulation (decision with uncertainty)
            max_nmb_with_uncertainty <- apply(sim_nmb, 1, max)
            expected_value_with_uncertainty <- mean(max_nmb_with_uncertainty)

            # 2. Find expected NMB for each strategy, then choose best (decision without uncertainty)
            expected_nmb_by_strategy <- colMeans(sim_nmb)
            max_expected_nmb <- max(expected_nmb_by_strategy)

            # 3. EVPI = difference
            evpi_per_person <- expected_value_with_uncertainty - max_expected_nmb
            total_evpi <- evpi_per_person * population

            # Populate EVPI table
            voiTable <- self$results$voiSummary

            interpretation <- if (evpi_per_person < wtp * 0.01) {
                "Very low uncertainty cost - current evidence sufficient"
            } else if (evpi_per_person < wtp * 0.05) {
                "Low uncertainty cost - further research may not be worthwhile"
            } else if (evpi_per_person < wtp * 0.10) {
                "Moderate uncertainty cost - consider targeted research"
            } else {
                "High uncertainty cost - further research highly valuable"
            }

            voiTable$setRow(rowNo = 1, values = list(
                wtp_threshold = wtp,
                evpi_per_person = evpi_per_person,
                population_size = population,
                total_evpi = total_evpi,
                interpretation = interpretation
            ))

            # Calculate EVPPI if requested
            if (self$options$evppi_parameters) {
                evppiTable <- self$results$evppiTable

                focus <- self$options$evppi_focus
                param_groups <- c()
                evppi_values <- c()

                if (focus %in% c("costs", "both")) {
                    # EVPPI for cost parameters
                    # Fix costs, vary effects
                    fixed_cost_nmb <- matrix(NA, nrow = n_sims, ncol = n_strategies)
                    mean_costs <- colMeans(sim_costs)
                    for (i in 1:n_strategies) {
                        fixed_cost_nmb[, i] <- (sim_effects[, i] * wtp) - mean_costs[i]
                    }
                    max_nmb_fixed_cost <- apply(fixed_cost_nmb, 1, max)
                    expected_with_perfect_cost_info <- mean(max_nmb_fixed_cost)
                    evppi_cost <- expected_with_perfect_cost_info - max_expected_nmb

                    param_groups <- c(param_groups, "Cost Parameters")
                    evppi_values <- c(evppi_values, evppi_cost)
                }

                if (focus %in% c("effects", "both")) {
                    # EVPPI for effect parameters
                    # Fix effects, vary costs
                    fixed_effect_nmb <- matrix(NA, nrow = n_sims, ncol = n_strategies)
                    mean_effects <- colMeans(sim_effects)
                    for (i in 1:n_strategies) {
                        fixed_effect_nmb[, i] <- (mean_effects[i] * wtp) - sim_costs[, i]
                    }
                    max_nmb_fixed_effect <- apply(fixed_effect_nmb, 1, max)
                    expected_with_perfect_effect_info <- mean(max_nmb_fixed_effect)
                    evppi_effect <- expected_with_perfect_effect_info - max_expected_nmb

                    param_groups <- c(param_groups, "Effect Parameters")
                    evppi_values <- c(evppi_values, evppi_effect)
                }

                # Populate EVPPI table
                for (i in seq_along(param_groups)) {
                    evppi_per_person <- evppi_values[i]
                    total_evppi <- evppi_per_person * population
                    pct_of_evpi <- if (evpi_per_person > 0) {
                        (evppi_per_person / evpi_per_person) * 100
                    } else { 0 }

                    research_priority <- if (pct_of_evpi > 75) {
                        "Very High"
                    } else if (pct_of_evpi > 50) {
                        "High"
                    } else if (pct_of_evpi > 25) {
                        "Medium"
                    } else {
                        "Low"
                    }

                    evppiTable$addRow(rowKey = param_groups[i], values = list(
                        parameter_group = param_groups[i],
                        evppi_per_person = evppi_per_person,
                        total_evppi = total_evppi,
                        percent_of_evpi = pct_of_evpi,
                        research_priority = research_priority
                    ))
                }
            }
        },

        .bootstrapCI = function(cost_vec, effect_vec) {
            n_boot <- self$options$bootstrap_samples
            n <- length(cost_vec)

            boot_cost <- numeric(n_boot)
            boot_effect <- numeric(n_boot)

            for (b in 1:n_boot) {
                boot_idx <- sample(n, replace = TRUE)
                boot_cost[b] <- mean(cost_vec[boot_idx], na.rm = TRUE)
                boot_effect[b] <- mean(effect_vec[boot_idx], na.rm = TRUE)
            }

            ci_probs <- c((1 - self$options$confidence_level)/2,
                         (1 + self$options$confidence_level)/2)

            return(list(
                cost_ci = quantile(boot_cost, probs = ci_probs, na.rm = TRUE),
                effect_ci = quantile(boot_effect, probs = ci_probs, na.rm = TRUE)
            ))
        },

        .bootstrapNMB = function(cost_vec, effect_vec, wtp) {
            n_boot <- self$options$bootstrap_samples
            n <- length(cost_vec)

            boot_nmb <- numeric(n_boot)

            for (b in 1:n_boot) {
                boot_idx <- sample(n, replace = TRUE)
                boot_cost_mean <- mean(cost_vec[boot_idx], na.rm = TRUE)
                boot_effect_mean <- mean(effect_vec[boot_idx], na.rm = TRUE)

                boot_nmb[b] <- (boot_effect_mean * wtp) - boot_cost_mean
            }

            ci_probs <- c((1 - self$options$confidence_level)/2,
                         (1 + self$options$confidence_level)/2)

            return(list(
                nmb_ci = quantile(boot_nmb, probs = ci_probs, na.rm = TRUE)
            ))
        },

        .populateInterpretation = function() {
            interpretation <- self$results$interpretation

            wtp <- self$options$wtp_threshold
            currency <- self$options$currency
            eff_label <- self$options$effectiveness_label
            perspective <- self$options$perspective
            cost_year <- self$options$cost_year
            time_horizon <- self$options$time_horizon
            handling_missing <- self$options$handling_missing

            # Get perspective label
            perspective_label <- switch(perspective,
                healthcare = "Healthcare System",
                provider = "Hospital/Provider",
                payer = "Payer/Insurance",
                societal = "Societal",
                "Healthcare System"
            )

            # Get missing handling label
            missing_label <- switch(handling_missing,
                complete = "Complete Cases Only",
                mean = "Mean Imputation",
                mi = "Multiple Imputation",
                "Complete Cases Only"
            )

            # Construct discounting message
            discount_msg <- "None (costs and effects not discounted)"
            if (self$options$discount_costs || self$options$discount_effects) {
                discount_parts <- character()
                if (self$options$discount_costs) {
                    discount_parts <- c(discount_parts, sprintf("Costs: %g%%", self$options$discount_rate_costs))
                }
                if (self$options$discount_effects) {
                    discount_parts <- c(discount_parts, sprintf("Effects: %g%%", self$options$discount_rate_effects))
                }
                discount_msg <- sprintf("%s (PLACEHOLDER - not yet implemented)", paste(discount_parts, collapse=", "))
            }

            html <- sprintf("<h4>Interpretation</h4>
            <p><b>Cost-Effectiveness Analysis Summary</b></p>

            <p><b>Analysis Parameters:</b></p>
            <ul>
                <li><b>Perspective:</b> %s</li>
                <li><b>Time Horizon:</b> %g years</li>
                <li><b>Cost Year:</b> %d</li>
                <li><b>Currency:</b> %s</li>
                <li><b>Missing Data:</b> %s</li>
                <li><b>Discounting:</b> %s</li>
            </ul>

            <p><b>Willingness-to-Pay Threshold:</b> %s %s per %s</p>

            <p><b>⚠️ IMPORTANT NOTE:</b> The current implementation uses complete-case analysis (missing values removed)
            without discounting from a healthcare perspective. Some options (discounting, alternative perspectives,
            imputation methods) are displayed in the interface but <b>DO NOT affect the current analysis</b> - they are
            placeholders for future implementation. All costs and effects are analyzed as provided in the data without
            adjustment for time value or perspective-specific cost components.</p>

            <h5>Key Decision Rules:</h5>",
            perspective_label, time_horizon, cost_year, currency, missing_label, discount_msg,
            currency, format(wtp, big.mark = ","), eff_label)

            html <- paste0(html, "
            <ul>
                <li><b>ICER < WTP:</b> New strategy is cost-effective at specified threshold</li>
                <li><b>Positive NMB:</b> Strategy provides net value (adopt if highest NMB)</li>
                <li><b>Dominant:</b> Lower cost AND more effective (strongly recommend adoption)</li>
                <li><b>Dominated:</b> Higher cost AND less effective (do not adopt)</li>
                <li><b>Extended Dominance:</b> On inefficient frontier (ruled out by linear combination)</li>
            </ul>

            <h5>Cost-Effectiveness Plane Quadrants:</h5>
            <ul>
                <li><b>Upper Right:</b> More costly, more effective (ICER determines if worthwhile)</li>
                <li><b>Upper Left:</b> More costly, less effective (dominated - reject)</li>
                <li><b>Lower Right:</b> Less costly, more effective (dominant - adopt)</li>
                <li><b>Lower Left:</b> Less costly, less effective (requires value judgment)</li>
            </ul>

            <h5>Clinical Applications:</h5>
            <p>Use this analysis to:</p>
            <ul>
                <li>Justify adoption of new diagnostic technologies to administrators</li>
                <li>Compare multiple diagnostic strategies on economic grounds</li>
                <li>Identify most efficient strategy at different budget constraints</li>
                <li>Perform sensitivity analyses to test robustness of conclusions</li>
                <li>Support health technology assessment submissions</li>
            </ul>

            <h5>Reporting Recommendations:</h5>
            <ul>
                <li>Always report perspective (healthcare system, societal, etc.)</li>
                <li>State time horizon explicitly</li>
                <li>Document all cost components included</li>
                <li>Report confidence intervals (bootstrap recommended)</li>
                <li>Perform sensitivity analyses on key parameters</li>
                <li>Consider subgroup analyses if heterogeneity expected</li>
            </ul>

            <p><b>Note:</b> Cost-effectiveness does not equal cost-saving. A strategy can be cost-effective
            even if it increases total costs, as long as the health gains justify the additional expenditure.</p>")

            interpretation$setContent(html)
        },

        .plotCEPlane = function(image, ...) {
            if (!self$options$plot_ce_plane)
                return()

            if (is.null(self$options$strategy) || is.null(self$options$cost) ||
                is.null(self$options$effectiveness))
                return()

            # Get data with variable escaping
            data <- self$data
            strategyVar <- private$.escapeVar(self$options$strategy)
            costVar <- private$.escapeVar(self$options$cost)
            effectivenessVar <- private$.escapeVar(self$options$effectiveness)

            strategy <- data[[strategyVar]]
            cost <- as.numeric(data[[costVar]])
            effectiveness <- as.numeric(data[[effectivenessVar]])

            # Remove missing
            complete_cases <- complete.cases(strategy, cost, effectiveness)
            strategy <- strategy[complete_cases]
            cost <- cost[complete_cases]
            effectiveness <- effectiveness[complete_cases]

            if (length(cost) < 3) return()

            # Get comparator
            comparator_level <- self$options$comparator_level
            if (is.null(comparator_level) || comparator_level == "") {
                comparator_level <- levels(strategy)[1]
            }

            # Calculate incremental costs and effects
            comp_idx <- strategy == comparator_level
            comp_cost <- mean(cost[comp_idx], na.rm = TRUE)
            comp_effect <- mean(effectiveness[comp_idx], na.rm = TRUE)

            strategy_levels <- levels(strategy)
            inc_costs <- numeric()
            inc_effects <- numeric()
            strat_names <- character()

            for (strat in strategy_levels) {
                if (strat == comparator_level) next

                strat_idx <- strategy == strat
                strat_cost <- mean(cost[strat_idx], na.rm = TRUE)
                strat_effect <- mean(effectiveness[strat_idx], na.rm = TRUE)

                inc_costs <- c(inc_costs, strat_cost - comp_cost)
                inc_effects <- c(inc_effects, strat_effect - comp_effect)
                strat_names <- c(strat_names, as.character(strat))
            }

            if (length(inc_costs) == 0) return()

            # Create plot
            plot_data <- data.frame(
                inc_effect = inc_effects,
                inc_cost = inc_costs,
                strategy = strat_names,
                stringsAsFactors = FALSE
            )

            # Determine plot limits
            xlim <- range(c(inc_effects, 0)) * 1.2
            ylim <- range(c(inc_costs, 0)) * 1.2

            wtp <- self$options$wtp_threshold
            currency <- self$options$currency

            # Start plot
            plot <- image$plot
            plot(0, 0, type = "n",
                 xlim = xlim, ylim = ylim,
                 xlab = sprintf("Incremental Effectiveness (%s)", self$options$effectiveness_label),
                 ylab = sprintf("Incremental Cost (%s)", currency),
                 main = "Cost-Effectiveness Plane",
                 las = 1)

            # Add reference lines
            abline(h = 0, lty = 2, col = "gray60")
            abline(v = 0, lty = 2, col = "gray60")

            # Add WTP threshold line (slope = WTP)
            if (wtp > 0) {
                abline(a = 0, b = wtp, lty = 1, col = "blue", lwd = 2)
                legend_text <- sprintf("WTP Threshold (%s %s)", currency, format(wtp, big.mark = ","))
                legend("topleft", legend = legend_text, col = "blue", lty = 1, lwd = 2, bty = "n")
            }

            # Add quadrant labels
            text_size <- 0.8
            text(xlim[2] * 0.8, ylim[2] * 0.8, "More costly\nMore effective", cex = text_size, col = "gray50")
            text(xlim[1] * 0.8, ylim[2] * 0.8, "More costly\nLess effective\n(Dominated)", cex = text_size, col = "red")
            text(xlim[2] * 0.8, ylim[1] * 0.8, "Less costly\nMore effective\n(Dominant)", cex = text_size, col = "darkgreen")
            text(xlim[1] * 0.8, ylim[1] * 0.8, "Less costly\nLess effective", cex = text_size, col = "gray50")

            # Plot points
            colors <- c("red", "blue", "green", "orange", "purple", "brown")
            for (i in seq_along(inc_effects)) {
                col_idx <- ((i - 1) %% length(colors)) + 1
                points(inc_effects[i], inc_costs[i], pch = 19, cex = 2, col = colors[col_idx])
                text(inc_effects[i], inc_costs[i], strat_names[i], pos = 3, cex = 0.8)
            }

            # Add comparator reference point
            points(0, 0, pch = 4, cex = 2, lwd = 2, col = "black")
            text(0, 0, comparator_level, pos = 1, cex = 0.8, col = "black")

            TRUE
        },

        .plotCEAC = function(image, ...) {
            if (!self$options$plot_ce_acceptability)
                return()

            if (!self$options$probabilistic_sensitivity)
                return()

            if (is.null(self$options$strategy) || is.null(self$options$cost) ||
                is.null(self$options$effectiveness))
                return()

            # Get data with variable escaping
            data <- self$data
            strategyVar <- private$.escapeVar(self$options$strategy)
            costVar <- private$.escapeVar(self$options$cost)
            effectivenessVar <- private$.escapeVar(self$options$effectiveness)

            strategy <- data[[strategyVar]]
            cost <- as.numeric(data[[costVar]])
            effectiveness <- as.numeric(data[[effectivenessVar]])

            # Remove missing
            complete_cases <- complete.cases(strategy, cost, effectiveness)
            strategy <- strategy[complete_cases]
            cost <- cost[complete_cases]
            effectiveness <- effectiveness[complete_cases]

            if (length(cost) < 10) return()

            strategy_levels <- levels(strategy)
            if (length(strategy_levels) < 2) return()

            # Get WTP range
            wtp_str <- self$options$wtp_range
            wtp_values <- as.numeric(unlist(strsplit(gsub(" ", "", wtp_str), ",")))
            if (length(wtp_values) < 3) {
                wtp_values <- seq(0, self$options$wtp_threshold * 2, length.out = 20)
            }

            # Run Monte Carlo simulation
            set.seed(self$options$random_seed)
            n_sims <- min(self$options$psa_simulations, 1000)  # Cap at 1000 for plot

            # Storage for probabilities
            prob_optimal <- matrix(0, nrow = length(strategy_levels), ncol = length(wtp_values))
            rownames(prob_optimal) <- strategy_levels

            # For each WTP threshold
            for (wtp_idx in seq_along(wtp_values)) {
                wtp <- wtp_values[wtp_idx]

                # Count optimal strategy in each simulation
                optimal_counts <- integer(length(strategy_levels))
                names(optimal_counts) <- strategy_levels

                for (sim in 1:n_sims) {
                    # Bootstrap sample
                    boot_idx <- sample(length(strategy), replace = TRUE)
                    boot_strategy <- strategy[boot_idx]
                    boot_cost <- cost[boot_idx]
                    boot_effect <- effectiveness[boot_idx]

                    # Calculate NMB for each strategy
                    max_nmb <- -Inf
                    optimal_strat <- ""

                    for (strat in strategy_levels) {
                        strat_idx <- boot_strategy == strat
                        if (sum(strat_idx) > 0) {
                            mean_cost <- mean(boot_cost[strat_idx], na.rm = TRUE)
                            mean_effect <- mean(boot_effect[strat_idx], na.rm = TRUE)
                            nmb <- (mean_effect * wtp) - mean_cost

                            if (nmb > max_nmb) {
                                max_nmb <- nmb
                                optimal_strat <- strat
                            }
                        }
                    }

                    if (optimal_strat != "") {
                        optimal_counts[optimal_strat] <- optimal_counts[optimal_strat] + 1
                    }
                }

                # Calculate probabilities
                prob_optimal[, wtp_idx] <- optimal_counts / n_sims
            }

            # Create plot
            plot <- image$plot

            # Determine y-axis limits
            ylim <- c(0, 1)

            # Initialize plot
            plot(wtp_values, prob_optimal[1, ],
                 type = "n",
                 xlim = range(wtp_values),
                 ylim = ylim,
                 xlab = sprintf("Willingness-to-Pay Threshold (%s)", self$options$currency),
                 ylab = "Probability Cost-Effective",
                 main = "Cost-Effectiveness Acceptability Curve (CEAC)",
                 las = 1)

            # Add reference lines
            abline(h = c(0, 0.5, 1), lty = 3, col = "gray80")
            abline(v = self$options$wtp_threshold, lty = 2, col = "blue", lwd = 1)

            # Plot lines for each strategy
            colors <- c("red", "blue", "green", "orange", "purple", "brown", "pink", "cyan")
            lty_types <- c(1, 2, 3, 4, 5, 6)

            for (i in seq_along(strategy_levels)) {
                col_idx <- ((i - 1) %% length(colors)) + 1
                lty_idx <- ((i - 1) %% length(lty_types)) + 1

                lines(wtp_values, prob_optimal[i, ],
                      col = colors[col_idx],
                      lwd = 2,
                      lty = lty_types[lty_idx])
            }

            # Add legend
            legend("right",
                   legend = strategy_levels,
                   col = colors[1:length(strategy_levels)],
                   lty = lty_types[1:length(strategy_levels)],
                   lwd = 2,
                   bty = "n",
                   cex = 0.8)

            # Add note about current WTP
            text(self$options$wtp_threshold, 0.95,
                 sprintf("Current WTP:\n%s %s",
                        self$options$currency,
                        format(self$options$wtp_threshold, big.mark = ",")),
                 pos = 4,
                 cex = 0.7,
                 col = "blue")

            TRUE
        },

        .plotNMB = function(image, ...) {
            if (!self$options$plot_nmb)
                return()

            if (!self$options$net_monetary_benefit)
                return()

            if (is.null(self$options$strategy) || is.null(self$options$cost) ||
                is.null(self$options$effectiveness))
                return()

            # Get data with variable escaping
            data <- self$data
            strategyVar <- private$.escapeVar(self$options$strategy)
            costVar <- private$.escapeVar(self$options$cost)
            effectivenessVar <- private$.escapeVar(self$options$effectiveness)

            strategy <- data[[strategyVar]]
            cost <- as.numeric(data[[costVar]])
            effectiveness <- as.numeric(data[[effectivenessVar]])

            # Remove missing
            complete_cases <- complete.cases(strategy, cost, effectiveness)
            strategy <- strategy[complete_cases]
            cost <- cost[complete_cases]
            effectiveness <- effectiveness[complete_cases]

            if (length(cost) < 3) return()

            strategy_levels <- levels(strategy)
            wtp <- self$options$wtp_threshold
            currency <- self$options$currency

            # Calculate NMB for each strategy
            nmb_values <- numeric()
            strat_names <- character()

            for (strat in strategy_levels) {
                strat_idx <- strategy == strat
                mean_cost <- mean(cost[strat_idx], na.rm = TRUE)
                mean_effect <- mean(effectiveness[strat_idx], na.rm = TRUE)

                nmb <- (mean_effect * wtp) - mean_cost
                nmb_values <- c(nmb_values, nmb)
                strat_names <- c(strat_names, as.character(strat))
            }

            if (length(nmb_values) == 0) return()

            # Identify optimal strategy
            optimal_idx <- which.max(nmb_values)

            # Create bar plot
            plot <- image$plot

            # Set margins for labels
            par(mar = c(5, 6, 4, 2) + 0.1, las = 1)

            # Create barplot
            bar_colors <- rep("lightblue", length(nmb_values))
            bar_colors[optimal_idx] <- "darkgreen"

            barplot(nmb_values,
                    names.arg = strat_names,
                    col = bar_colors,
                    border = "black",
                    main = sprintf("Net Monetary Benefit at WTP %s %s",
                                 currency, format(wtp, big.mark = ",")),
                    ylab = sprintf("Net Monetary Benefit (%s)", currency),
                    xlab = "Strategy",
                    las = 2,  # Rotate labels
                    cex.names = 0.8)

            # Add horizontal reference line at zero
            abline(h = 0, lty = 2, col = "gray50", lwd = 2)

            # Add legend
            legend("topright",
                   legend = c("Optimal Strategy", "Other Strategies"),
                   fill = c("darkgreen", "lightblue"),
                   border = "black",
                   bty = "n")

            # Add value labels on bars
            for (i in seq_along(nmb_values)) {
                text(x = (i - 0.5) * 1.2,
                     y = nmb_values[i],
                     labels = format(round(nmb_values[i]), big.mark = ","),
                     pos = if (nmb_values[i] > 0) 3 else 1,
                     cex = 0.7)
            }

            TRUE
        },

        .plotTornado = function(image, ...) {
            if (!self$options$plot_tornado)
                return()

            if (!self$options$deterministic_sensitivity)
                return()

            if (is.null(self$options$strategy) || is.null(self$options$cost) ||
                is.null(self$options$effectiveness))
                return()

            # Get data with variable escaping
            data <- self$data
            strategyVar <- private$.escapeVar(self$options$strategy)
            costVar <- private$.escapeVar(self$options$cost)
            effectivenessVar <- private$.escapeVar(self$options$effectiveness)

            strategy <- data[[strategyVar]]
            cost <- as.numeric(data[[costVar]])
            effectiveness <- as.numeric(data[[effectivenessVar]])

            # Remove missing
            complete_cases <- complete.cases(strategy, cost, effectiveness)
            strategy <- strategy[complete_cases]
            cost <- cost[complete_cases]
            effectiveness <- effectiveness[complete_cases]

            if (length(cost) < 10) return()

            # Get comparator
            comparator_level <- self$options$comparator_level
            if (is.null(comparator_level) || comparator_level == "") {
                comparator_level <- levels(strategy)[1]
            }

            # Find first non-comparator strategy for ICER calculation
            strategy_levels <- levels(strategy)
            target_strategy <- strategy_levels[strategy_levels != comparator_level][1]
            if (is.null(target_strategy)) return()

            # Calculate base case ICER
            comp_idx <- strategy == comparator_level
            target_idx <- strategy == target_strategy

            base_comp_cost <- mean(cost[comp_idx], na.rm = TRUE)
            base_comp_effect <- mean(effectiveness[comp_idx], na.rm = TRUE)
            base_target_cost <- mean(cost[target_idx], na.rm = TRUE)
            base_target_effect <- mean(effectiveness[target_idx], na.rm = TRUE)

            base_inc_cost <- base_target_cost - base_comp_cost
            base_inc_effect <- base_target_effect - base_comp_effect

            if (abs(base_inc_effect) < 1e-10) return()
            base_icer <- base_inc_cost / base_inc_effect

            # Perform one-way sensitivity analysis on cost and effectiveness
            # Vary ±sensitivity_range_pct%
            range_pct <- self$options$sensitivity_range_pct / 100

            # Parameters to vary
            params <- c("Target Cost", "Target Effectiveness", "Comparator Cost", "Comparator Effectiveness")
            base_values <- c(base_target_cost, base_target_effect, base_comp_cost, base_comp_effect)
            icer_low <- numeric(length(params))
            icer_high <- numeric(length(params))

            for (i in 1:4) {
                # Low value
                if (i == 1) {  # Target cost low
                    low_icer <- ((base_target_cost * (1 - range_pct)) - base_comp_cost) / base_inc_effect
                } else if (i == 2) {  # Target effect low
                    low_inc_effect <- (base_target_effect * (1 - range_pct)) - base_comp_effect
                    if (abs(low_inc_effect) > 1e-10) {
                        low_icer <- base_inc_cost / low_inc_effect
                    } else {
                        low_icer <- base_icer
                    }
                } else if (i == 3) {  # Comparator cost low
                    low_icer <- (base_target_cost - (base_comp_cost * (1 - range_pct))) / base_inc_effect
                } else {  # Comparator effect low
                    low_inc_effect <- base_target_effect - (base_comp_effect * (1 - range_pct))
                    if (abs(low_inc_effect) > 1e-10) {
                        low_icer <- base_inc_cost / low_inc_effect
                    } else {
                        low_icer <- base_icer
                    }
                }

                # High value
                if (i == 1) {  # Target cost high
                    high_icer <- ((base_target_cost * (1 + range_pct)) - base_comp_cost) / base_inc_effect
                } else if (i == 2) {  # Target effect high
                    high_inc_effect <- (base_target_effect * (1 + range_pct)) - base_comp_effect
                    if (abs(high_inc_effect) > 1e-10) {
                        high_icer <- base_inc_cost / high_inc_effect
                    } else {
                        high_icer <- base_icer
                    }
                } else if (i == 3) {  # Comparator cost high
                    high_icer <- (base_target_cost - (base_comp_cost * (1 + range_pct))) / base_inc_effect
                } else {  # Comparator effect high
                    high_inc_effect <- base_target_effect - (base_comp_effect * (1 + range_pct))
                    if (abs(high_inc_effect) > 1e-10) {
                        high_icer <- base_inc_cost / high_inc_effect
                    } else {
                        high_icer <- base_icer
                    }
                }

                icer_low[i] <- low_icer
                icer_high[i] <- high_icer
            }

            # Calculate range for each parameter
            icer_range <- abs(icer_high - icer_low)

            # Order by range (descending)
            order_idx <- order(icer_range, decreasing = TRUE)
            params <- params[order_idx]
            icer_low <- icer_low[order_idx]
            icer_high <- icer_high[order_idx]
            icer_range <- icer_range[order_idx]

            # Create tornado plot
            plot <- image$plot

            # Set margins
            par(mar = c(5, 10, 4, 2) + 0.1)

            # Determine x-axis limits
            xlim <- range(c(icer_low, icer_high, base_icer)) * c(0.95, 1.05)

            # Create empty plot
            plot(0, 0, type = "n",
                 xlim = xlim,
                 ylim = c(0.5, length(params) + 0.5),
                 xlab = sprintf("ICER (%s per %s)",
                               self$options$currency,
                               self$options$effectiveness_label),
                 ylab = "",
                 main = sprintf("Tornado Diagram: One-Way Sensitivity Analysis\n(±%d%% variation)",
                               self$options$sensitivity_range_pct),
                 yaxt = "n",
                 las = 1)

            # Add parameter labels
            axis(2, at = 1:length(params), labels = params, las = 1, cex.axis = 0.8)

            # Add base case line
            abline(v = base_icer, lty = 2, col = "red", lwd = 2)

            # Plot horizontal bars
            for (i in 1:length(params)) {
                # Bar from low to high
                segments(x0 = icer_low[i],
                        y0 = i,
                        x1 = icer_high[i],
                        y1 = i,
                        col = "steelblue",
                        lwd = 8,
                        lend = 1)

                # Add endpoints
                points(c(icer_low[i], icer_high[i]),
                      c(i, i),
                      pch = "|",
                      cex = 2,
                      col = "darkblue")
            }

            # Add legend
            legend("topright",
                   legend = c("ICER Range", "Base Case ICER"),
                   col = c("steelblue", "red"),
                   lwd = c(8, 2),
                   lty = c(1, 2),
                   bty = "n")

            # Add WTP reference if available
            wtp <- self$options$wtp_threshold
            if (wtp > xlim[1] && wtp < xlim[2]) {
                abline(v = wtp, lty = 3, col = "green", lwd = 1.5)
                text(wtp, length(params) + 0.3,
                     sprintf("WTP: %s", format(wtp, big.mark = ",")),
                     pos = 4,
                     cex = 0.7,
                     col = "green")
            }

            TRUE
        },

        .plotFrontier = function(image, ...) {
            if (!self$options$plot_incremental_frontier)
                return()

            if (is.null(self$options$strategy) || is.null(self$options$cost) ||
                is.null(self$options$effectiveness))
                return()

            # Get data with variable escaping
            data <- self$data
            strategyVar <- private$.escapeVar(self$options$strategy)
            costVar <- private$.escapeVar(self$options$cost)
            effectivenessVar <- private$.escapeVar(self$options$effectiveness)

            strategy <- data[[strategyVar]]
            cost <- as.numeric(data[[costVar]])
            effectiveness <- as.numeric(data[[effectivenessVar]])

            # Remove missing
            complete_cases <- complete.cases(strategy, cost, effectiveness)
            strategy <- strategy[complete_cases]
            cost <- cost[complete_cases]
            effectiveness <- effectiveness[complete_cases]

            if (length(cost) < 3) return()

            strategy_levels <- levels(strategy)
            currency <- self$options$currency

            # Calculate mean cost and effect for each strategy
            mean_costs <- numeric()
            mean_effects <- numeric()
            strat_names <- character()

            for (strat in strategy_levels) {
                strat_idx <- strategy == strat
                mean_costs <- c(mean_costs, mean(cost[strat_idx], na.rm = TRUE))
                mean_effects <- c(mean_effects, mean(effectiveness[strat_idx], na.rm = TRUE))
                strat_names <- c(strat_names, as.character(strat))
            }

            if (length(mean_costs) < 2) return()

            # Identify dominated strategies
            dominated <- logical(length(mean_costs))
            for (i in seq_along(mean_costs)) {
                for (j in seq_along(mean_costs)) {
                    if (i != j) {
                        # j dominates i if j has lower/equal cost AND higher/equal effect
                        if (mean_costs[j] <= mean_costs[i] && mean_effects[j] >= mean_effects[i] &&
                            (mean_costs[j] < mean_costs[i] || mean_effects[j] > mean_effects[i])) {
                            dominated[i] <- TRUE
                            break
                        }
                    }
                }
            }

            # Find efficient frontier (non-dominated strategies ordered by effect)
            frontier_idx <- which(!dominated)
            if (length(frontier_idx) > 1) {
                frontier_order <- order(mean_effects[frontier_idx])
                frontier_idx <- frontier_idx[frontier_order]
            }

            # Create plot
            plot <- image$plot

            # Determine plot limits
            xlim <- range(mean_effects) * c(0.95, 1.05)
            ylim <- range(mean_costs) * c(0.95, 1.05)

            plot(mean_effects, mean_costs,
                 type = "n",
                 xlim = xlim, ylim = ylim,
                 xlab = sprintf("Mean Effectiveness (%s)", self$options$effectiveness_label),
                 ylab = sprintf("Mean Cost (%s)", currency),
                 main = "Cost-Effectiveness Efficiency Frontier",
                 las = 1)

            # Plot dominated strategies
            if (any(dominated)) {
                points(mean_effects[dominated], mean_costs[dominated],
                       pch = 1, cex = 2, col = "red", lwd = 2)
            }

            # Plot non-dominated strategies
            if (any(!dominated)) {
                points(mean_effects[!dominated], mean_costs[!dominated],
                       pch = 19, cex = 2, col = "darkgreen")
            }

            # Draw frontier line
            if (length(frontier_idx) > 1) {
                lines(mean_effects[frontier_idx], mean_costs[frontier_idx],
                      col = "blue", lwd = 2, lty = 1)
            }

            # Add strategy labels
            for (i in seq_along(mean_costs)) {
                text(mean_effects[i], mean_costs[i], strat_names[i],
                     pos = 3, cex = 0.8,
                     col = if (dominated[i]) "red" else "darkgreen")
            }

            # Add legend
            legend_items <- character()
            legend_pch <- numeric()
            legend_col <- character()
            legend_lwd <- numeric()

            if (any(!dominated)) {
                legend_items <- c(legend_items, "Non-Dominated (Efficient)")
                legend_pch <- c(legend_pch, 19)
                legend_col <- c(legend_col, "darkgreen")
                legend_lwd <- c(legend_lwd, 1)
            }

            if (any(dominated)) {
                legend_items <- c(legend_items, "Dominated (Inefficient)")
                legend_pch <- c(legend_pch, 1)
                legend_col <- c(legend_col, "red")
                legend_lwd <- c(legend_lwd, 2)
            }

            if (length(frontier_idx) > 1) {
                legend_items <- c(legend_items, "Efficiency Frontier")
                legend_pch <- c(legend_pch, NA)
                legend_col <- c(legend_col, "blue")
                legend_lwd <- c(legend_lwd, 2)
            }

            if (length(legend_items) > 0) {
                legend("topleft", legend = legend_items,
                       pch = legend_pch, col = legend_col, lwd = legend_lwd,
                       bty = "n")
            }

            TRUE
        },

        .escapeVar = function(varName) {
            # Escape variable names with special characters using jmvcore
            if (is.null(varName)) return(NULL)
            return(jmvcore::composeTerm(varName))
        }
    )
)
