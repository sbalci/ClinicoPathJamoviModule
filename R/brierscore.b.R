
# This file is automatically generated, you probably don't want to edit this

brierscoreClass <- if (requireNamespace('jmvcore', quietly=TRUE)) R6::R6Class(
    "brierscoreClass",
    inherit = brierscoreBase,
    private = list(
        .init = function() {
            private$.initInstructions()
        },

        .run = function() {
            # Check for required inputs
            if (is.null(self$options$time) || is.null(self$options$event) ||
                is.null(self$options$predicted_survival)) {
                return()
            }

            # Get data
            data <- self$data
            time_var <- data[[self$options$time]]
            event_var <- data[[self$options$event]]
            pred_surv <- data[[self$options$predicted_survival]]

            # Validate predictions are probabilities
            if (any(pred_surv < 0 | pred_surv > 1, na.rm = TRUE)) {
                warning("Predicted survival probabilities should be between 0 and 1")
            }

            # Calculate Brier scores
            private$.populateBrierSummary(time_var, event_var, pred_surv)

            # Calculate Integrated Brier Score if requested
            if (self$options$calculate_ibs) {
                private$.populateIntegratedBrier(time_var, event_var, pred_surv)
            }

            # Populate interpretation
            private$.populateInterpretation()
        },

        .initInstructions = function() {
            instructions <- self$results$instructions
            html <- "<h3>Brier Score & Integrated Brier Score</h3>
            <p>Calibration accuracy assessment for time-to-event predictions.</p>

            <h4>Required Inputs:</h4>
            <ul>
                <li><b>Time:</b> Time-to-event or censoring (days, months, years)</li>
                <li><b>Event:</b> Binary event indicator (1 = event, 0 = censored)</li>
                <li><b>Predicted Survival:</b> Pre-computed survival probabilities (0-1)</li>
                <li><b>Prediction Time:</b> Time point for Brier score evaluation</li>
            </ul>

            <h4>Brier Score Interpretation:</h4>
            <ul>
                <li><b>Perfect prediction:</b> Brier = 0</li>
                <li><b>Excellent:</b> Brier < 0.10 (10% mean squared error)</li>
                <li><b>Good:</b> Brier 0.10-0.20</li>
                <li><b>Acceptable:</b> Brier 0.20-0.25</li>
                <li><b>Poor:</b> Brier > 0.25</li>
                <li><b>Worst possible:</b> Brier = 1.0</li>
            </ul>

            <h4>Scaled Brier Score:</h4>
            <ul>
                <li>Standardized relative to null model (Kaplan-Meier curve)</li>
                <li>Scaled = 1 - (Brier_model / Brier_null)</li>
                <li>Positive values indicate improvement over KM prediction</li>
                <li>Analogous to RÂ² in linear regression</li>
            </ul>

            <h4>Integrated Brier Score (IBS):</h4>
            <ul>
                <li>Average Brier score across time period (area under Brier curve)</li>
                <li>Single summary measure of overall prediction performance</li>
                <li>Lower IBS indicates better calibration across follow-up</li>
                <li>Useful for comparing models with different prediction horizons</li>
            </ul>

            <h4>Clinical Applications:</h4>
            <ul>
                <li><b>Cox Model Validation:</b> Assess calibration of proportional hazards model</li>
                <li><b>ML Model Evaluation:</b> Validate random forests, neural networks for survival</li>
                <li><b>Risk Calculator Assessment:</b> Evaluate clinical prediction tools</li>
                <li><b>External Validation:</b> Test model performance in new populations</li>
                <li><b>Temporal Validation:</b> Assess calibration drift over time</li>
            </ul>

            <h4>Key Concepts:</h4>
            <ul>
                <li><b>Discrimination vs Calibration:</b> Brier measures both, unlike C-index (discrimination only)</li>
                <li><b>IPCW:</b> Inverse probability censoring weighting handles censored observations</li>
                <li><b>Time-dependent:</b> Brier score changes over time as censoring increases</li>
                <li><b>Competing Risks:</b> Use cumulative incidence instead of survival</li>
            </ul>

            <h4>Required R Packages:</h4>
            <ul>
                <li><b>pec:</b> Prediction error curves</li>
                <li><b>riskRegression:</b> Integrated Brier score</li>
                <li><b>survival:</b> Kaplan-Meier for null model</li>
            </ul>

            <p><b>Note:</b> Implementation in development. Full functionality requires pec and riskRegression packages.</p>"

            instructions$setContent(html)
        },

        .populateBrierSummary = function(time_var, event_var, pred_surv) {
            table <- self$results$brierSummary

            # Determine time points to evaluate
            time_points <- self$options$prediction_time
            if (self$options$multiple_time_points && self$options$time_points != "") {
                additional_times <- as.numeric(unlist(strsplit(self$options$time_points, ",")))
                time_points <- c(time_points, additional_times)
                time_points <- sort(unique(time_points))
            }

            # Calculate Brier score for each time point
            for (i in seq_along(time_points)) {
                t_point <- time_points[i]

                # Calculate time-dependent Brier score
                brier_result <- private$.calculateBrierScore(
                    time_var = time_var,
                    event_var = event_var,
                    pred_surv = pred_surv,
                    time_point = t_point
                )

                # Calculate null model Brier score if requested
                null_brier <- NA
                scaled_brier <- NA
                if (self$options$scaled_brier) {
                    null_brier <- private$.calculateNullModelBrier(time_var, event_var, t_point)
                    if (!is.na(null_brier) && null_brier > 0) {
                        scaled_brier <- 1 - (brier_result$brier / null_brier)
                    }
                }

                # Calculate confidence intervals if requested
                brier_ci_lower <- NA
                brier_ci_upper <- NA
                if (self$options$confidence_intervals) {
                    ci_result <- private$.calculateBrierCI(
                        time_var = time_var,
                        event_var = event_var,
                        pred_surv = pred_surv,
                        time_point = t_point,
                        brier_point = brier_result$brier
                    )
                    brier_ci_lower <- ci_result$lower
                    brier_ci_upper <- ci_result$upper
                }

                table$addRow(rowKey=i, values=list(
                    time_point = t_point,
                    brier_score = brier_result$brier,
                    brier_ci_lower = brier_ci_lower,
                    brier_ci_upper = brier_ci_upper,
                    scaled_brier = scaled_brier,
                    null_model_brier = null_brier,
                    n_events = brier_result$n_events,
                    n_censored = brier_result$n_censored
                ))
            }
        },

        .populateInterpretation = function() {
            interpretation <- self$results$interpretation

            html <- "<h4>Clinical Interpretation</h4>
            <p>Brier score assessment for survival prediction calibration.</p>

            <h5>Calibration Quality:</h5>
            <ul>
                <li>Lower Brier scores indicate better agreement between predicted and observed survival</li>
                <li>Scaled Brier score shows improvement over simple Kaplan-Meier prediction</li>
                <li>Calibration curve shows systematic over- or under-estimation of risk</li>
            </ul>

            <h5>Recommendations:</h5>
            <ul>
                <li>Brier < 0.15 generally acceptable for clinical use</li>
                <li>Check calibration curve for systematic bias</li>
                <li>Compare IBS across models to select best calibrated approach</li>
                <li>Consider recalibration if systematic miscalibration detected</li>
            </ul>"

            interpretation$setContent(html)
        },

        .calculateBrierScore = function(time_var, event_var, pred_surv, time_point) {
            # Calculate time-dependent Brier score using IPCW (Inverse Probability of Censoring Weighting)

            # Remove missing values
            complete_cases <- complete.cases(time_var, event_var, pred_surv)
            time_var <- time_var[complete_cases]
            event_var <- event_var[complete_cases]
            pred_surv <- pred_surv[complete_cases]

            n <- length(time_var)

            # Count events and censoring
            n_events <- sum(event_var == 1)
            n_censored <- sum(event_var == 0)

            # Calculate censoring weights using Kaplan-Meier estimator
            if (self$options$inverse_probability_weighting) {
                # Fit KM for censoring distribution (reverse event indicator)
                surv_obj_cens <- survival::Surv(time_var, 1 - event_var)
                km_cens <- survival::survfit(surv_obj_cens ~ 1)

                # Get censoring probabilities at observation times
                cens_prob <- rep(1, n)
                for (i in 1:n) {
                    # Find censoring probability at this observation time
                    idx <- which(km_cens$time <= time_var[i])
                    if (length(idx) > 0) {
                        cens_prob[i] <- km_cens$surv[max(idx)]
                    }
                }

                # Avoid division by zero
                cens_prob[cens_prob < 0.01] <- 0.01

                # Calculate weights
                weights <- rep(0, n)

                # For patients who had event before time_point
                event_before <- (time_var <= time_point) & (event_var == 1)
                weights[event_before] <- 1 / cens_prob[event_before]

                # For patients who survived past time_point
                surv_past <- time_var > time_point
                # Get censoring probability at time_point
                idx_t <- which(km_cens$time <= time_point)
                if (length(idx_t) > 0) {
                    cens_prob_t <- km_cens$surv[max(idx_t)]
                } else {
                    cens_prob_t <- 1
                }
                cens_prob_t <- max(cens_prob_t, 0.01)
                weights[surv_past] <- 1 / cens_prob_t

            } else {
                # No weighting - complete case analysis (biased if censoring is informative)
                weights <- rep(1, n)
            }

            # Calculate observed outcomes at time_point
            # Y(t) = 1 if survived past t, 0 if had event before t
            observed <- as.numeric(time_var > time_point | (time_var > time_point & event_var == 0))

            # For those who had event before time_point
            observed[time_var <= time_point & event_var == 1] <- 0

            # For those who survived past time_point
            observed[time_var > time_point] <- 1

            # Exclude patients censored before time_point (they don't contribute)
            include <- (time_var > time_point) | (time_var <= time_point & event_var == 1)

            # Calculate Brier score: mean of weighted squared prediction errors
            squared_errors <- (pred_surv - observed)^2
            weighted_errors <- squared_errors * weights

            brier <- sum(weighted_errors[include]) / sum(weights[include])

            return(list(
                brier = brier,
                n_events = n_events,
                n_censored = n_censored
            ))
        },

        .calculateNullModelBrier = function(time_var, event_var, time_point) {
            # Calculate Brier score for null model (Kaplan-Meier)
            # This serves as baseline for scaled Brier score

            # Fit Kaplan-Meier curve
            surv_obj <- survival::Surv(time_var, event_var)
            km_fit <- survival::survfit(surv_obj ~ 1)

            # Get KM survival probability at time_point
            idx <- which(km_fit$time <= time_point)
            if (length(idx) > 0) {
                km_surv <- km_fit$surv[max(idx)]
            } else {
                km_surv <- 1.0
            }

            # Create constant prediction equal to KM estimate
            pred_km <- rep(km_surv, length(time_var))

            # Calculate Brier score for null model
            null_result <- private$.calculateBrierScore(
                time_var = time_var,
                event_var = event_var,
                pred_surv = pred_km,
                time_point = time_point
            )

            return(null_result$brier)
        },

        .calculateBrierCI = function(time_var, event_var, pred_surv, time_point, brier_point) {
            # Calculate confidence intervals for Brier score

            if (self$options$ci_method == "bootstrap") {
                # Bootstrap confidence intervals
                set.seed(self$options$random_seed)
                n_boot <- self$options$bootstrap_samples

                boot_briers <- numeric(n_boot)
                n <- length(time_var)

                for (b in 1:n_boot) {
                    # Bootstrap sample with replacement
                    boot_idx <- sample(1:n, n, replace = TRUE)
                    boot_time <- time_var[boot_idx]
                    boot_event <- event_var[boot_idx]
                    boot_pred <- pred_surv[boot_idx]

                    # Calculate Brier score for bootstrap sample
                    tryCatch({
                        boot_result <- private$.calculateBrierScore(
                            time_var = boot_time,
                            event_var = boot_event,
                            pred_surv = boot_pred,
                            time_point = time_point
                        )
                        boot_briers[b] <- boot_result$brier
                    }, error = function(e) {
                        boot_briers[b] <- NA
                    })
                }

                # Calculate percentile CI
                alpha <- 1 - self$options$confidence_level
                ci_lower <- quantile(boot_briers, alpha/2, na.rm = TRUE)
                ci_upper <- quantile(boot_briers, 1 - alpha/2, na.rm = TRUE)

            } else {
                # Influence function method (asymptotic approximation)
                # Using simple SE approximation
                n <- length(time_var)
                se_brier <- sqrt(brier_point * (1 - brier_point) / n)

                z_crit <- qnorm(1 - (1 - self$options$confidence_level) / 2)
                ci_lower <- max(0, brier_point - z_crit * se_brier)
                ci_upper <- min(1, brier_point + z_crit * se_brier)
            }

            return(list(lower = ci_lower, upper = ci_upper))
        },

        .populateIntegratedBrier = function(time_var, event_var, pred_surv) {
            # Calculate Integrated Brier Score (IBS) - area under Brier score curve
            table <- self$results$integratedBrier

            start_time <- self$options$ibs_start_time
            end_time <- self$options$ibs_end_time

            # Validate time range
            max_time <- max(time_var[event_var == 1], na.rm = TRUE)
            if (end_time > max_time) {
                warning(paste0("IBS end time (", end_time, ") exceeds maximum event time (",
                              round(max_time, 2), "). Using maximum event time instead."))
                end_time <- max_time
            }

            # Calculate Brier scores at multiple time points for integration
            # Use adaptive time grid based on event times
            event_times <- sort(unique(time_var[event_var == 1]))
            eval_times <- event_times[event_times >= start_time & event_times <= end_time]

            # Ensure we have enough evaluation points (minimum 10)
            if (length(eval_times) < 10) {
                eval_times <- seq(start_time, end_time, length.out = 20)
            }

            # Calculate Brier score at each time point
            brier_values <- numeric(length(eval_times))
            null_brier_values <- numeric(length(eval_times))

            for (i in seq_along(eval_times)) {
                t <- eval_times[i]

                # Calculate model Brier score
                brier_result <- private$.calculateBrierScore(
                    time_var = time_var,
                    event_var = event_var,
                    pred_surv = pred_surv,
                    time_point = t
                )
                brier_values[i] <- brier_result$brier

                # Calculate null model Brier score if scaled IBS requested
                if (self$options$scaled_brier) {
                    null_brier_values[i] <- private$.calculateNullModelBrier(
                        time_var = time_var,
                        event_var = event_var,
                        time_point = t
                    )
                }
            }

            # Integrate using trapezoidal rule
            time_diffs <- diff(eval_times)
            brier_avg <- (brier_values[-length(brier_values)] + brier_values[-1]) / 2
            ibs <- sum(time_diffs * brier_avg) / (end_time - start_time)

            # Calculate scaled IBS if requested
            scaled_ibs <- NA
            if (self$options$scaled_brier) {
                null_brier_avg <- (null_brier_values[-length(null_brier_values)] +
                                  null_brier_values[-1]) / 2
                ibs_null <- sum(time_diffs * null_brier_avg) / (end_time - start_time)
                if (ibs_null > 0) {
                    scaled_ibs <- 1 - (ibs / ibs_null)
                }
            }

            # Calculate confidence intervals if requested
            ibs_ci_lower <- NA
            ibs_ci_upper <- NA
            if (self$options$confidence_intervals) {
                if (self$options$ci_method == "bootstrap") {
                    set.seed(self$options$random_seed)
                    n_boot <- self$options$bootstrap_samples
                    boot_ibs <- numeric(n_boot)
                    n <- length(time_var)

                    for (b in 1:n_boot) {
                        boot_idx <- sample(1:n, n, replace = TRUE)
                        boot_time <- time_var[boot_idx]
                        boot_event <- event_var[boot_idx]
                        boot_pred <- pred_surv[boot_idx]

                        # Calculate IBS for bootstrap sample
                        tryCatch({
                            boot_brier_vals <- numeric(length(eval_times))
                            for (i in seq_along(eval_times)) {
                                br <- private$.calculateBrierScore(
                                    time_var = boot_time,
                                    event_var = boot_event,
                                    pred_surv = boot_pred,
                                    time_point = eval_times[i]
                                )
                                boot_brier_vals[i] <- br$brier
                            }
                            boot_brier_avg <- (boot_brier_vals[-length(boot_brier_vals)] +
                                              boot_brier_vals[-1]) / 2
                            boot_ibs[b] <- sum(time_diffs * boot_brier_avg) / (end_time - start_time)
                        }, error = function(e) {
                            boot_ibs[b] <- NA
                        })
                    }

                    alpha <- 1 - self$options$confidence_level
                    ibs_ci_lower <- quantile(boot_ibs, alpha/2, na.rm = TRUE)
                    ibs_ci_upper <- quantile(boot_ibs, 1 - alpha/2, na.rm = TRUE)
                } else {
                    # Simple SE approximation
                    se_ibs <- sqrt(ibs * (1 - ibs) / length(time_var))
                    z_crit <- qnorm(1 - (1 - self$options$confidence_level) / 2)
                    ibs_ci_lower <- max(0, ibs - z_crit * se_ibs)
                    ibs_ci_upper <- min(1, ibs + z_crit * se_ibs)
                }
            }

            # Interpretation
            interpretation <- if (ibs < 0.10) {
                "Excellent calibration across time"
            } else if (ibs < 0.15) {
                "Good calibration across time"
            } else if (ibs < 0.20) {
                "Acceptable calibration"
            } else {
                "Poor calibration - consider model recalibration"
            }

            table$setRow(rowNo=1, values=list(
                time_range = paste0("[", start_time, ", ", end_time, "]"),
                ibs = ibs,
                ibs_ci_lower = ibs_ci_lower,
                ibs_ci_upper = ibs_ci_upper,
                scaled_ibs = scaled_ibs,
                interpretation = interpretation
            ))
        },

        .plotBrierOverTime = function(image, ...) {
            # Plot time-dependent Brier score across follow-up period

            if (is.null(self$options$time) || is.null(self$options$event) ||
                is.null(self$options$predicted_survival)) {
                return()
            }

            # Get data
            data <- self$data
            time_var <- data[[self$options$time]]
            event_var <- data[[self$options$event]]
            pred_surv <- data[[self$options$predicted_survival]]

            # Remove missing
            complete_cases <- complete.cases(time_var, event_var, pred_surv)
            time_var <- time_var[complete_cases]
            event_var <- event_var[complete_cases]
            pred_surv <- pred_surv[complete_cases]

            # Create time grid for evaluation
            event_times <- sort(unique(time_var[event_var == 1]))
            max_time <- max(event_times)
            min_time <- min(event_times)

            # Create evaluation times
            eval_times <- seq(min_time, max_time, length.out = 50)

            # Calculate Brier score at each time point
            brier_data <- data.frame(
                time = numeric(),
                brier = numeric(),
                null_brier = numeric()
            )

            for (t in eval_times) {
                tryCatch({
                    brier_result <- private$.calculateBrierScore(
                        time_var = time_var,
                        event_var = event_var,
                        pred_surv = pred_surv,
                        time_point = t
                    )

                    null_brier <- NA
                    if (self$options$scaled_brier) {
                        null_brier <- private$.calculateNullModelBrier(
                            time_var = time_var,
                            event_var = event_var,
                            time_point = t
                        )
                    }

                    brier_data <- rbind(brier_data, data.frame(
                        time = t,
                        brier = brier_result$brier,
                        null_brier = null_brier
                    ))
                }, error = function(e) {
                    # Skip time points with errors
                })
            }

            # Create plot
            p <- ggplot2::ggplot(brier_data, ggplot2::aes(x = time, y = brier)) +
                ggplot2::geom_line(color = "blue", linewidth = 1.2) +
                ggplot2::geom_point(color = "blue", size = 2, alpha = 0.6) +
                ggplot2::labs(
                    x = "Time",
                    y = "Brier Score",
                    title = "Time-Dependent Brier Score",
                    subtitle = "Lower values indicate better calibration"
                ) +
                ggplot2::theme_minimal() +
                ggplot2::theme(
                    plot.title = ggplot2::element_text(face = "bold", size = 14),
                    plot.subtitle = ggplot2::element_text(size = 10, color = "gray40"),
                    axis.title = ggplot2::element_text(size = 12),
                    panel.grid.minor = ggplot2::element_blank()
                ) +
                ggplot2::ylim(0, max(brier_data$brier, na.rm = TRUE) * 1.1)

            # Add null model line if available
            if (self$options$scaled_brier && any(!is.na(brier_data$null_brier))) {
                p <- p + ggplot2::geom_line(
                    ggplot2::aes(y = null_brier),
                    color = "red",
                    linetype = "dashed",
                    linewidth = 1
                ) +
                ggplot2::scale_color_manual(
                    name = "Model",
                    values = c("Prediction Model" = "blue", "Null Model (KM)" = "red")
                )
            }

            # Add reference lines for interpretation
            p <- p +
                ggplot2::geom_hline(yintercept = 0.10, linetype = "dotted",
                                   color = "darkgreen", linewidth = 0.5) +
                ggplot2::geom_hline(yintercept = 0.15, linetype = "dotted",
                                   color = "orange", linewidth = 0.5) +
                ggplot2::geom_hline(yintercept = 0.25, linetype = "dotted",
                                   color = "red", linewidth = 0.5)

            print(p)
            TRUE
        },

        .plotCalibrationCurve = function(image, ...) {
            # Plot calibration curve showing predicted vs observed survival

            if (is.null(self$options$time) || is.null(self$options$event) ||
                is.null(self$options$predicted_survival)) {
                return()
            }

            # Get data
            data <- self$data
            time_var <- data[[self$options$time]]
            event_var <- data[[self$options$event]]
            pred_surv <- data[[self$options$predicted_survival]]

            # Remove missing
            complete_cases <- complete.cases(time_var, event_var, pred_surv)
            time_var <- time_var[complete_cases]
            event_var <- event_var[complete_cases]
            pred_surv <- pred_surv[complete_cases]

            # Use prediction time
            time_point <- self$options$prediction_time

            # Group patients into risk groups based on predicted survival
            n_groups <- self$options$calibration_groups
            pred_groups <- cut(pred_surv, breaks = quantile(pred_surv,
                              probs = seq(0, 1, length.out = n_groups + 1)),
                              include.lowest = TRUE, labels = FALSE)

            # Calculate observed survival (KM) and mean predicted for each group
            calib_data <- data.frame(
                group = integer(),
                mean_predicted = numeric(),
                observed = numeric(),
                n = integer()
            )

            for (g in unique(pred_groups)) {
                if (is.na(g)) next

                group_idx <- which(pred_groups == g)
                group_time <- time_var[group_idx]
                group_event <- event_var[group_idx]
                group_pred <- pred_surv[group_idx]

                # Calculate mean predicted survival for this group
                mean_pred <- mean(group_pred, na.rm = TRUE)

                # Calculate observed survival using Kaplan-Meier
                surv_obj <- survival::Surv(group_time, group_event)
                km_fit <- survival::survfit(surv_obj ~ 1)

                # Get observed survival at time_point
                idx <- which(km_fit$time <= time_point)
                if (length(idx) > 0) {
                    observed_surv <- km_fit$surv[max(idx)]
                } else {
                    observed_surv <- 1.0
                }

                calib_data <- rbind(calib_data, data.frame(
                    group = g,
                    mean_predicted = mean_pred,
                    observed = observed_surv,
                    n = length(group_idx)
                ))
            }

            # Create calibration plot
            p <- ggplot2::ggplot(calib_data, ggplot2::aes(x = mean_predicted, y = observed)) +
                ggplot2::geom_point(ggplot2::aes(size = n), color = "blue", alpha = 0.6) +
                ggplot2::geom_line(color = "blue", linewidth = 1) +
                ggplot2::geom_abline(intercept = 0, slope = 1, linetype = "dashed",
                                    color = "red", linewidth = 1) +
                ggplot2::labs(
                    x = "Predicted Survival Probability",
                    y = "Observed Survival (Kaplan-Meier)",
                    title = "Calibration Curve",
                    subtitle = paste0("At time = ", time_point, " (Perfect calibration = diagonal line)")
                ) +
                ggplot2::theme_minimal() +
                ggplot2::theme(
                    plot.title = ggplot2::element_text(face = "bold", size = 14),
                    plot.subtitle = ggplot2::element_text(size = 10, color = "gray40"),
                    axis.title = ggplot2::element_text(size = 12),
                    legend.position = "right"
                ) +
                ggplot2::scale_size_continuous(name = "N patients") +
                ggplot2::coord_cartesian(xlim = c(0, 1), ylim = c(0, 1))

            print(p)
            TRUE
        },

        .plotModelComparison = function(image, ...) {
            # Stub for model comparison plot
        },

        .plotIntegratedBrier = function(image, ...) {
            # Stub for integrated Brier score visualization
        }
    )
)
