
# This file is automatically generated, you probably don't want to edit this

rocregClass <- if (requireNamespace('jmvcore', quietly=TRUE)) R6::R6Class(
    "rocregClass",
    inherit = rocregBase,
    private = list(
        .init = function() {
            private$.initInstructions()
        },

        .run = function() {
            if (is.null(self$options$predictor) || is.null(self$options$outcome) ||
                length(self$options$covariates) == 0) {
                return()
            }

            # Get data
            data <- self$data
            predictor <- data[[self$options$predictor]]
            outcome <- data[[self$options$outcome]]

            # Remove missing values
            complete_cases <- complete.cases(predictor, outcome)
            predictor <- predictor[complete_cases]
            outcome <- outcome[complete_cases]

            # Identify positive class
            if (!is.null(self$options$positive_level)) {
                outcome_binary <- as.numeric(outcome == self$options$positive_level)
            } else {
                outcome_binary <- as.numeric(outcome) - 1
            }

            # Implement stratified ROC analysis (practical alternative to full ROC regression)
            # For each covariate, stratify and calculate ROC curves
            for (cov_name in self$options$covariates) {
                covariate <- data[[cov_name]][complete_cases]

                # Handle continuous vs categorical covariates
                if (is.numeric(covariate) && !is.factor(covariate)) {
                    # Create quartile groups for continuous covariates
                    cov_groups <- cut(covariate,
                                     breaks = quantile(covariate, probs = c(0, 0.25, 0.5, 0.75, 1), na.rm = TRUE),
                                     include.lowest = TRUE,
                                     labels = c("Q1 (Low)", "Q2", "Q3", "Q4 (High)"))
                } else {
                    cov_groups <- as.factor(covariate)
                }

                # Calculate stratified ROC curves
                private$.calculateStratifiedROC(predictor, outcome_binary, cov_groups, cov_name)
            }

            # Populate interpretation
            private$.populateInterpretation()
        },

        .initInstructions = function() {
            instructions <- self$results$instructions
            html <- "<h3>ROC Regression (Covariate-Adjusted ROC)</h3>
            <p>Adjust ROC analysis for confounders and patient characteristics.</p>

            <h4>When to Use ROC Regression:</h4>
            <ul>
                <li><b>Multi-center studies:</b> Adjust for center/scanner effects</li>
                <li><b>Digital pathology:</b> Account for staining/batch effects</li>
                <li><b>Heterogeneous populations:</b> Age/stage-specific accuracy</li>
                <li><b>Confounder control:</b> Unbiased test comparisons</li>
            </ul>

            <h4>Applications:</h4>
            <ul>
                <li>Scanner harmonization in digital pathology</li>
                <li>Age-adjusted biomarker performance</li>
                <li>Stage-specific diagnostic accuracy</li>
                <li>Multi-institutional validation studies</li>
            </ul>

            <p><b>Note:</b> Implementation requires ROCnReg R package.</p>"

            instructions$setContent(html)
        },

        .populateInterpretation = function() {
            interpretation <- self$results$interpretation
            html <- "<h4>Interpretation</h4>
            <p>Stratified ROC analysis shows diagnostic accuracy across covariate levels.</p>
            <p>Different AUCs across strata indicate heterogeneous test performance.</p>
            <p>Use homogeneity tests to determine if adjustment for covariates is necessary.</p>"
            interpretation$setContent(html)
        },

        .calculateStratifiedROC = function(predictor, outcome, groups, cov_name) {
            # Calculate ROC curves for each group
            group_levels <- levels(groups)
            n_groups <- length(group_levels)

            if (n_groups < 2) return()

            # Storage for AUC values
            auc_values <- numeric(n_groups)
            se_values <- numeric(n_groups)
            n_diseased <- integer(n_groups)
            n_healthy <- integer(n_groups)

            for (i in seq_along(group_levels)) {
                group_idx <- groups == group_levels[i]

                if (sum(group_idx, na.rm = TRUE) < 10) next

                group_pred <- predictor[group_idx]
                group_outcome <- outcome[group_idx]

                # Remove any remaining NAs
                complete <- complete.cases(group_pred, group_outcome)
                group_pred <- group_pred[complete]
                group_outcome <- group_outcome[complete]

                # Calculate AUC using pROC if available, otherwise manual calculation
                if (requireNamespace("pROC", quietly = TRUE)) {
                    tryCatch({
                        roc_obj <- pROC::roc(group_outcome, group_pred, quiet = TRUE)
                        auc_values[i] <- as.numeric(pROC::auc(roc_obj))
                        ci_obj <- pROC::ci.auc(roc_obj, quiet = TRUE)
                        se_values[i] <- (ci_obj[3] - ci_obj[1]) / (2 * 1.96)
                    }, error = function(e) {
                        auc_values[i] <- NA
                        se_values[i] <- NA
                    })
                } else {
                    # Manual AUC calculation (Mann-Whitney U)
                    diseased <- group_pred[group_outcome == 1]
                    healthy <- group_pred[group_outcome == 0]

                    if (length(diseased) > 0 && length(healthy) > 0) {
                        n1 <- length(diseased)
                        n0 <- length(healthy)

                        # Mann-Whitney U statistic
                        rank_sum <- sum(rank(c(diseased, healthy))[1:n1])
                        u_stat <- rank_sum - (n1 * (n1 + 1)) / 2
                        auc_values[i] <- u_stat / (n1 * n0)

                        # SE approximation
                        se_values[i] <- sqrt((auc_values[i] * (1 - auc_values[i]) +
                                            (n1 - 1) * (auc_values[i]^2 - auc_values[i]^2) +
                                            (n0 - 1) * (auc_values[i]^2 - auc_values[i]^2)) / (n1 * n0))
                    }
                }

                n_diseased[i] <- sum(group_outcome == 1)
                n_healthy[i] <- sum(group_outcome == 0)
            }

            # Test for homogeneity of AUCs (chi-square test)
            valid_aucs <- !is.na(auc_values)
            if (sum(valid_aucs) >= 2) {
                # DeLong test for comparing AUCs
                valid_auc <- auc_values[valid_aucs]
                valid_se <- se_values[valid_aucs]
                valid_n_diseased <- n_diseased[valid_aucs]
                valid_n_healthy <- n_healthy[valid_aucs]

                # Chi-square test statistic for heterogeneity
                mean_auc <- weighted.mean(valid_auc, w = 1/valid_se^2, na.rm = TRUE)
                q_stat <- sum((valid_auc - mean_auc)^2 / valid_se^2, na.rm = TRUE)
                df <- sum(valid_aucs) - 1
                p_homogeneity <- 1 - pchisq(q_stat, df)

                # Populate summary table
                table <- self$results$stratifiedSummary

                table$addRow(rowKey = cov_name, values = list(
                    covariate = cov_name,
                    n_groups = n_groups,
                    auc_range_min = min(valid_auc, na.rm = TRUE),
                    auc_range_max = max(valid_auc, na.rm = TRUE),
                    pooled_auc = mean_auc,
                    q_statistic = q_stat,
                    df = df,
                    p_homogeneity = p_homogeneity,
                    heterogeneous = ifelse(p_homogeneity < 0.05, "Yes", "No")
                ))

                # Populate group-specific table
                group_table <- self$results$groupSpecificAUC

                for (i in seq_along(group_levels)) {
                    if (!is.na(auc_values[i])) {
                        ci_lower <- max(0, auc_values[i] - 1.96 * se_values[i])
                        ci_upper <- min(1, auc_values[i] + 1.96 * se_values[i])

                        group_table$addRow(rowKey = paste0(cov_name, "_", i), values = list(
                            covariate = cov_name,
                            group = as.character(group_levels[i]),
                            n_diseased = n_diseased[i],
                            n_healthy = n_healthy[i],
                            auc = auc_values[i],
                            auc_se = se_values[i],
                            ci_lower = ci_lower,
                            ci_upper = ci_upper
                        ))
                    }
                }
            }
        },

        .plotCovariateROCs = function(image, ...) {
            # TODO: Plot stratified ROC curves
        },

        .plotAUCByCovariate = function(image, ...) {
            # TODO: Plot AUC by covariate level
        },

        .plotEffectEstimates = function(image, ...) {
            # TODO: Plot covariate effect estimates
        }
    )
)
