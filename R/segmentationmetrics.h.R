
# This file is automatically generated, you probably don't want to edit this

segmentationmetricsOptions <- if (requireNamespace("jmvcore", quietly=TRUE)) R6::R6Class(
    "segmentationmetricsOptions",
    inherit = jmvcore::Options,
    public = list(
        initialize = function(
            prediction_mask = NULL,
            ground_truth_mask = NULL,
            image_id = NULL,
            segmentation_type = "binary",
            positive_class = NULL,
            dice_coefficient = TRUE,
            jaccard_index = TRUE,
            volumetric_similarity = FALSE,
            sensitivity_specificity = TRUE,
            hausdorff_distance = TRUE,
            average_hausdorff = TRUE,
            surface_distance = TRUE,
            surface_overlap = FALSE,
            boundary_tolerance = 2,
            pixel_size_provided = FALSE,
            pixel_size_x = 0.5,
            pixel_size_y = 0.5,
            class_specific_metrics = TRUE,
            macro_average = TRUE,
            weighted_average = TRUE,
            object_detection_metrics = FALSE,
            iou_threshold = 0.5,
            count_metrics = FALSE,
            confidence_intervals = TRUE,
            bootstrap_ci = FALSE,
            bootstrap_samples = 1000,
            confidence_level = 0.95,
            quality_thresholds = TRUE,
            dice_threshold_excellent = 0.9,
            dice_threshold_good = 0.8,
            dice_threshold_acceptable = 0.7,
            stratified_analysis = FALSE,
            stratify_by = NULL,
            outlier_detection = TRUE,
            outlier_method = "iqr",
            plot_metric_distribution = TRUE,
            plot_scatter_comparison = TRUE,
            plot_boundary_error = TRUE,
            plot_confusion_matrix = FALSE,
            plot_performance_by_class = FALSE,
            application_context = "general",
            show_interpretation = TRUE,
            paired_analysis = FALSE,
            comparison_method = NULL,
            missing_handling = "complete",
            random_seed = 123, ...) {

            super$initialize(
                package="ClinicoPath",
                name="segmentationmetrics",
                requiresData=TRUE,
                ...)

            private$..prediction_mask <- jmvcore::OptionVariable$new(
                "prediction_mask",
                prediction_mask,
                suggested=list(
                    "nominal",
                    "ordinal"),
                permitted=list(
                    "factor",
                    "numeric"))
            private$..ground_truth_mask <- jmvcore::OptionVariable$new(
                "ground_truth_mask",
                ground_truth_mask,
                suggested=list(
                    "nominal",
                    "ordinal"),
                permitted=list(
                    "factor",
                    "numeric"))
            private$..image_id <- jmvcore::OptionVariable$new(
                "image_id",
                image_id,
                suggested=list(
                    "nominal"),
                permitted=list(
                    "factor"))
            private$..segmentation_type <- jmvcore::OptionList$new(
                "segmentation_type",
                segmentation_type,
                options=list(
                    "binary",
                    "multiclass",
                    "instance"),
                default="binary")
            private$..positive_class <- jmvcore::OptionLevel$new(
                "positive_class",
                positive_class,
                variable="(prediction_mask)")
            private$..dice_coefficient <- jmvcore::OptionBool$new(
                "dice_coefficient",
                dice_coefficient,
                default=TRUE)
            private$..jaccard_index <- jmvcore::OptionBool$new(
                "jaccard_index",
                jaccard_index,
                default=TRUE)
            private$..volumetric_similarity <- jmvcore::OptionBool$new(
                "volumetric_similarity",
                volumetric_similarity,
                default=FALSE)
            private$..sensitivity_specificity <- jmvcore::OptionBool$new(
                "sensitivity_specificity",
                sensitivity_specificity,
                default=TRUE)
            private$..hausdorff_distance <- jmvcore::OptionBool$new(
                "hausdorff_distance",
                hausdorff_distance,
                default=TRUE)
            private$..average_hausdorff <- jmvcore::OptionBool$new(
                "average_hausdorff",
                average_hausdorff,
                default=TRUE)
            private$..surface_distance <- jmvcore::OptionBool$new(
                "surface_distance",
                surface_distance,
                default=TRUE)
            private$..surface_overlap <- jmvcore::OptionBool$new(
                "surface_overlap",
                surface_overlap,
                default=FALSE)
            private$..boundary_tolerance <- jmvcore::OptionNumber$new(
                "boundary_tolerance",
                boundary_tolerance,
                default=2,
                min=0.5,
                max=20)
            private$..pixel_size_provided <- jmvcore::OptionBool$new(
                "pixel_size_provided",
                pixel_size_provided,
                default=FALSE)
            private$..pixel_size_x <- jmvcore::OptionNumber$new(
                "pixel_size_x",
                pixel_size_x,
                default=0.5,
                min=0.01,
                max=10)
            private$..pixel_size_y <- jmvcore::OptionNumber$new(
                "pixel_size_y",
                pixel_size_y,
                default=0.5,
                min=0.01,
                max=10)
            private$..class_specific_metrics <- jmvcore::OptionBool$new(
                "class_specific_metrics",
                class_specific_metrics,
                default=TRUE)
            private$..macro_average <- jmvcore::OptionBool$new(
                "macro_average",
                macro_average,
                default=TRUE)
            private$..weighted_average <- jmvcore::OptionBool$new(
                "weighted_average",
                weighted_average,
                default=TRUE)
            private$..object_detection_metrics <- jmvcore::OptionBool$new(
                "object_detection_metrics",
                object_detection_metrics,
                default=FALSE)
            private$..iou_threshold <- jmvcore::OptionNumber$new(
                "iou_threshold",
                iou_threshold,
                default=0.5,
                min=0.1,
                max=0.95)
            private$..count_metrics <- jmvcore::OptionBool$new(
                "count_metrics",
                count_metrics,
                default=FALSE)
            private$..confidence_intervals <- jmvcore::OptionBool$new(
                "confidence_intervals",
                confidence_intervals,
                default=TRUE)
            private$..bootstrap_ci <- jmvcore::OptionBool$new(
                "bootstrap_ci",
                bootstrap_ci,
                default=FALSE)
            private$..bootstrap_samples <- jmvcore::OptionInteger$new(
                "bootstrap_samples",
                bootstrap_samples,
                default=1000,
                min=100,
                max=10000)
            private$..confidence_level <- jmvcore::OptionNumber$new(
                "confidence_level",
                confidence_level,
                default=0.95,
                min=0.8,
                max=0.99)
            private$..quality_thresholds <- jmvcore::OptionBool$new(
                "quality_thresholds",
                quality_thresholds,
                default=TRUE)
            private$..dice_threshold_excellent <- jmvcore::OptionNumber$new(
                "dice_threshold_excellent",
                dice_threshold_excellent,
                default=0.9,
                min=0.5,
                max=1)
            private$..dice_threshold_good <- jmvcore::OptionNumber$new(
                "dice_threshold_good",
                dice_threshold_good,
                default=0.8,
                min=0.5,
                max=1)
            private$..dice_threshold_acceptable <- jmvcore::OptionNumber$new(
                "dice_threshold_acceptable",
                dice_threshold_acceptable,
                default=0.7,
                min=0.5,
                max=1)
            private$..stratified_analysis <- jmvcore::OptionBool$new(
                "stratified_analysis",
                stratified_analysis,
                default=FALSE)
            private$..stratify_by <- jmvcore::OptionVariable$new(
                "stratify_by",
                stratify_by,
                suggested=list(
                    "nominal",
                    "ordinal"),
                permitted=list(
                    "factor"))
            private$..outlier_detection <- jmvcore::OptionBool$new(
                "outlier_detection",
                outlier_detection,
                default=TRUE)
            private$..outlier_method <- jmvcore::OptionList$new(
                "outlier_method",
                outlier_method,
                options=list(
                    "iqr",
                    "zscore",
                    "modified_zscore"),
                default="iqr")
            private$..plot_metric_distribution <- jmvcore::OptionBool$new(
                "plot_metric_distribution",
                plot_metric_distribution,
                default=TRUE)
            private$..plot_scatter_comparison <- jmvcore::OptionBool$new(
                "plot_scatter_comparison",
                plot_scatter_comparison,
                default=TRUE)
            private$..plot_boundary_error <- jmvcore::OptionBool$new(
                "plot_boundary_error",
                plot_boundary_error,
                default=TRUE)
            private$..plot_confusion_matrix <- jmvcore::OptionBool$new(
                "plot_confusion_matrix",
                plot_confusion_matrix,
                default=FALSE)
            private$..plot_performance_by_class <- jmvcore::OptionBool$new(
                "plot_performance_by_class",
                plot_performance_by_class,
                default=FALSE)
            private$..application_context <- jmvcore::OptionList$new(
                "application_context",
                application_context,
                options=list(
                    "general",
                    "tumor",
                    "gland",
                    "nuclei",
                    "tissue",
                    "stain"),
                default="general")
            private$..show_interpretation <- jmvcore::OptionBool$new(
                "show_interpretation",
                show_interpretation,
                default=TRUE)
            private$..paired_analysis <- jmvcore::OptionBool$new(
                "paired_analysis",
                paired_analysis,
                default=FALSE)
            private$..comparison_method <- jmvcore::OptionVariable$new(
                "comparison_method",
                comparison_method,
                suggested=list(
                    "nominal"),
                permitted=list(
                    "factor"))
            private$..missing_handling <- jmvcore::OptionList$new(
                "missing_handling",
                missing_handling,
                options=list(
                    "complete",
                    "exclude_image"),
                default="complete")
            private$..random_seed <- jmvcore::OptionInteger$new(
                "random_seed",
                random_seed,
                default=123,
                min=1,
                max=999999)

            self$.addOption(private$..prediction_mask)
            self$.addOption(private$..ground_truth_mask)
            self$.addOption(private$..image_id)
            self$.addOption(private$..segmentation_type)
            self$.addOption(private$..positive_class)
            self$.addOption(private$..dice_coefficient)
            self$.addOption(private$..jaccard_index)
            self$.addOption(private$..volumetric_similarity)
            self$.addOption(private$..sensitivity_specificity)
            self$.addOption(private$..hausdorff_distance)
            self$.addOption(private$..average_hausdorff)
            self$.addOption(private$..surface_distance)
            self$.addOption(private$..surface_overlap)
            self$.addOption(private$..boundary_tolerance)
            self$.addOption(private$..pixel_size_provided)
            self$.addOption(private$..pixel_size_x)
            self$.addOption(private$..pixel_size_y)
            self$.addOption(private$..class_specific_metrics)
            self$.addOption(private$..macro_average)
            self$.addOption(private$..weighted_average)
            self$.addOption(private$..object_detection_metrics)
            self$.addOption(private$..iou_threshold)
            self$.addOption(private$..count_metrics)
            self$.addOption(private$..confidence_intervals)
            self$.addOption(private$..bootstrap_ci)
            self$.addOption(private$..bootstrap_samples)
            self$.addOption(private$..confidence_level)
            self$.addOption(private$..quality_thresholds)
            self$.addOption(private$..dice_threshold_excellent)
            self$.addOption(private$..dice_threshold_good)
            self$.addOption(private$..dice_threshold_acceptable)
            self$.addOption(private$..stratified_analysis)
            self$.addOption(private$..stratify_by)
            self$.addOption(private$..outlier_detection)
            self$.addOption(private$..outlier_method)
            self$.addOption(private$..plot_metric_distribution)
            self$.addOption(private$..plot_scatter_comparison)
            self$.addOption(private$..plot_boundary_error)
            self$.addOption(private$..plot_confusion_matrix)
            self$.addOption(private$..plot_performance_by_class)
            self$.addOption(private$..application_context)
            self$.addOption(private$..show_interpretation)
            self$.addOption(private$..paired_analysis)
            self$.addOption(private$..comparison_method)
            self$.addOption(private$..missing_handling)
            self$.addOption(private$..random_seed)
        }),
    active = list(
        prediction_mask = function() private$..prediction_mask$value,
        ground_truth_mask = function() private$..ground_truth_mask$value,
        image_id = function() private$..image_id$value,
        segmentation_type = function() private$..segmentation_type$value,
        positive_class = function() private$..positive_class$value,
        dice_coefficient = function() private$..dice_coefficient$value,
        jaccard_index = function() private$..jaccard_index$value,
        volumetric_similarity = function() private$..volumetric_similarity$value,
        sensitivity_specificity = function() private$..sensitivity_specificity$value,
        hausdorff_distance = function() private$..hausdorff_distance$value,
        average_hausdorff = function() private$..average_hausdorff$value,
        surface_distance = function() private$..surface_distance$value,
        surface_overlap = function() private$..surface_overlap$value,
        boundary_tolerance = function() private$..boundary_tolerance$value,
        pixel_size_provided = function() private$..pixel_size_provided$value,
        pixel_size_x = function() private$..pixel_size_x$value,
        pixel_size_y = function() private$..pixel_size_y$value,
        class_specific_metrics = function() private$..class_specific_metrics$value,
        macro_average = function() private$..macro_average$value,
        weighted_average = function() private$..weighted_average$value,
        object_detection_metrics = function() private$..object_detection_metrics$value,
        iou_threshold = function() private$..iou_threshold$value,
        count_metrics = function() private$..count_metrics$value,
        confidence_intervals = function() private$..confidence_intervals$value,
        bootstrap_ci = function() private$..bootstrap_ci$value,
        bootstrap_samples = function() private$..bootstrap_samples$value,
        confidence_level = function() private$..confidence_level$value,
        quality_thresholds = function() private$..quality_thresholds$value,
        dice_threshold_excellent = function() private$..dice_threshold_excellent$value,
        dice_threshold_good = function() private$..dice_threshold_good$value,
        dice_threshold_acceptable = function() private$..dice_threshold_acceptable$value,
        stratified_analysis = function() private$..stratified_analysis$value,
        stratify_by = function() private$..stratify_by$value,
        outlier_detection = function() private$..outlier_detection$value,
        outlier_method = function() private$..outlier_method$value,
        plot_metric_distribution = function() private$..plot_metric_distribution$value,
        plot_scatter_comparison = function() private$..plot_scatter_comparison$value,
        plot_boundary_error = function() private$..plot_boundary_error$value,
        plot_confusion_matrix = function() private$..plot_confusion_matrix$value,
        plot_performance_by_class = function() private$..plot_performance_by_class$value,
        application_context = function() private$..application_context$value,
        show_interpretation = function() private$..show_interpretation$value,
        paired_analysis = function() private$..paired_analysis$value,
        comparison_method = function() private$..comparison_method$value,
        missing_handling = function() private$..missing_handling$value,
        random_seed = function() private$..random_seed$value),
    private = list(
        ..prediction_mask = NA,
        ..ground_truth_mask = NA,
        ..image_id = NA,
        ..segmentation_type = NA,
        ..positive_class = NA,
        ..dice_coefficient = NA,
        ..jaccard_index = NA,
        ..volumetric_similarity = NA,
        ..sensitivity_specificity = NA,
        ..hausdorff_distance = NA,
        ..average_hausdorff = NA,
        ..surface_distance = NA,
        ..surface_overlap = NA,
        ..boundary_tolerance = NA,
        ..pixel_size_provided = NA,
        ..pixel_size_x = NA,
        ..pixel_size_y = NA,
        ..class_specific_metrics = NA,
        ..macro_average = NA,
        ..weighted_average = NA,
        ..object_detection_metrics = NA,
        ..iou_threshold = NA,
        ..count_metrics = NA,
        ..confidence_intervals = NA,
        ..bootstrap_ci = NA,
        ..bootstrap_samples = NA,
        ..confidence_level = NA,
        ..quality_thresholds = NA,
        ..dice_threshold_excellent = NA,
        ..dice_threshold_good = NA,
        ..dice_threshold_acceptable = NA,
        ..stratified_analysis = NA,
        ..stratify_by = NA,
        ..outlier_detection = NA,
        ..outlier_method = NA,
        ..plot_metric_distribution = NA,
        ..plot_scatter_comparison = NA,
        ..plot_boundary_error = NA,
        ..plot_confusion_matrix = NA,
        ..plot_performance_by_class = NA,
        ..application_context = NA,
        ..show_interpretation = NA,
        ..paired_analysis = NA,
        ..comparison_method = NA,
        ..missing_handling = NA,
        ..random_seed = NA)
)

segmentationmetricsResults <- if (requireNamespace("jmvcore", quietly=TRUE)) R6::R6Class(
    "segmentationmetricsResults",
    inherit = jmvcore::Group,
    active = list(
        instructions = function() private$.items[["instructions"]],
        overallSummary = function() private$.items[["overallSummary"]],
        overlapMetricsTable = function() private$.items[["overlapMetricsTable"]],
        distanceMetricsTable = function() private$.items[["distanceMetricsTable"]],
        multiclassMetricsTable = function() private$.items[["multiclassMetricsTable"]],
        instanceMetricsTable = function() private$.items[["instanceMetricsTable"]],
        qualityAssessmentTable = function() private$.items[["qualityAssessmentTable"]],
        outlierImagesTable = function() private$.items[["outlierImagesTable"]],
        stratifiedAnalysisTable = function() private$.items[["stratifiedAnalysisTable"]],
        comparisonTable = function() private$.items[["comparisonTable"]],
        metricDistributionPlot = function() private$.items[["metricDistributionPlot"]],
        scatterComparisonPlot = function() private$.items[["scatterComparisonPlot"]],
        boundaryErrorPlot = function() private$.items[["boundaryErrorPlot"]],
        confusionMatrixPlot = function() private$.items[["confusionMatrixPlot"]],
        performanceByClassPlot = function() private$.items[["performanceByClassPlot"]],
        clinicalInterpretation = function() private$.items[["clinicalInterpretation"]]),
    private = list(),
    public=list(
        initialize=function(options) {
            super$initialize(
                options=options,
                name="",
                title="Segmentation Metrics (Dice, IoU, Hausdorff)",
                refs=list(
                    "ggplot2",
                    "dplyr",
                    "tidyr",
                    "ClinicoPathJamoviModule"))
            self$add(jmvcore::Html$new(
                options=options,
                name="instructions",
                title="Instructions",
                visible=TRUE))
            self$add(jmvcore::Table$new(
                options=options,
                name="overallSummary",
                title="Overall Segmentation Performance",
                visible=TRUE,
                columns=list(
                    list(
                        `name`="metric", 
                        `title`="Metric", 
                        `type`="text"),
                    list(
                        `name`="mean", 
                        `title`="Mean", 
                        `type`="number", 
                        `format`="zto"),
                    list(
                        `name`="sd", 
                        `title`="SD", 
                        `type`="number", 
                        `format`="zto"),
                    list(
                        `name`="median", 
                        `title`="Median", 
                        `type`="number", 
                        `format`="zto"),
                    list(
                        `name`="ci_lower", 
                        `title`="95% CI Lower", 
                        `type`="number", 
                        `format`="zto"),
                    list(
                        `name`="ci_upper", 
                        `title`="95% CI Upper", 
                        `type`="number", 
                        `format`="zto"),
                    list(
                        `name`="min", 
                        `title`="Min", 
                        `type`="number", 
                        `format`="zto"),
                    list(
                        `name`="max", 
                        `title`="Max", 
                        `type`="number", 
                        `format`="zto"))))
            self$add(jmvcore::Table$new(
                options=options,
                name="overlapMetricsTable",
                title="Overlap Metrics (Dice & IoU)",
                visible=TRUE,
                columns=list(
                    list(
                        `name`="image_id", 
                        `title`="Image ID", 
                        `type`="text"),
                    list(
                        `name`="dice", 
                        `title`="Dice Coefficient", 
                        `type`="number", 
                        `format`="zto", 
                        `visible`="(dice_coefficient)"),
                    list(
                        `name`="iou", 
                        `title`="IoU (Jaccard)", 
                        `type`="number", 
                        `format`="zto", 
                        `visible`="(jaccard_index)"),
                    list(
                        `name`="sensitivity", 
                        `title`="Sensitivity", 
                        `type`="number", 
                        `format`="pc", 
                        `visible`="(sensitivity_specificity)"),
                    list(
                        `name`="specificity", 
                        `title`="Specificity", 
                        `type`="number", 
                        `format`="pc", 
                        `visible`="(sensitivity_specificity)"),
                    list(
                        `name`="quality_category", 
                        `title`="Quality", 
                        `type`="text", 
                        `visible`="(quality_thresholds)"))))
            self$add(jmvcore::Table$new(
                options=options,
                name="distanceMetricsTable",
                title="Distance Metrics (Boundary Accuracy)",
                visible="(hausdorff_distance || surface_distance)",
                columns=list(
                    list(
                        `name`="image_id", 
                        `title`="Image ID", 
                        `type`="text"),
                    list(
                        `name`="hausdorff_max", 
                        `title`="Hausdorff (max)", 
                        `type`="number", 
                        `format`="zto", 
                        `visible`="(hausdorff_distance)"),
                    list(
                        `name`="hausdorff_95", 
                        `title`="Hausdorff (95%)", 
                        `type`="number", 
                        `format`="zto", 
                        `visible`="(average_hausdorff)"),
                    list(
                        `name`="avg_surface_dist", 
                        `title`="Avg Surface Dist", 
                        `type`="number", 
                        `format`="zto", 
                        `visible`="(surface_distance)"),
                    list(
                        `name`="surface_dice", 
                        `title`="Surface Dice", 
                        `type`="number", 
                        `format`="zto", 
                        `visible`="(surface_overlap)"),
                    list(
                        `name`="units", 
                        `title`="Units", 
                        `type`="text"))))
            self$add(jmvcore::Table$new(
                options=options,
                name="multiclassMetricsTable",
                title="Multi-class Performance by Class",
                visible="(class_specific_metrics && segmentation_type:multiclass)",
                columns=list(
                    list(
                        `name`="class", 
                        `title`="Class", 
                        `type`="text"),
                    list(
                        `name`="n_pixels", 
                        `title`="N Pixels", 
                        `type`="integer"),
                    list(
                        `name`="dice", 
                        `title`="Dice", 
                        `type`="number", 
                        `format`="zto"),
                    list(
                        `name`="iou", 
                        `title`="IoU", 
                        `type`="number", 
                        `format`="zto"),
                    list(
                        `name`="sensitivity", 
                        `title`="Sensitivity", 
                        `type`="number", 
                        `format`="pc"),
                    list(
                        `name`="specificity", 
                        `title`="Specificity", 
                        `type`="number", 
                        `format`="pc"))))
            self$add(jmvcore::Table$new(
                options=options,
                name="instanceMetricsTable",
                title="Instance Segmentation Metrics",
                visible="(object_detection_metrics && segmentation_type:instance)",
                columns=list(
                    list(
                        `name`="image_id", 
                        `title`="Image ID", 
                        `type`="text"),
                    list(
                        `name`="n_true_objects", 
                        `title`="True Objects", 
                        `type`="integer"),
                    list(
                        `name`="n_pred_objects", 
                        `title`="Pred Objects", 
                        `type`="integer"),
                    list(
                        `name`="true_positives", 
                        `title`="True Positives", 
                        `type`="integer"),
                    list(
                        `name`="false_positives", 
                        `title`="False Positives", 
                        `type`="integer"),
                    list(
                        `name`="false_negatives", 
                        `title`="False Negatives", 
                        `type`="integer"),
                    list(
                        `name`="precision", 
                        `title`="Precision", 
                        `type`="number", 
                        `format`="pc"),
                    list(
                        `name`="recall", 
                        `title`="Recall", 
                        `type`="number", 
                        `format`="pc"),
                    list(
                        `name`="f1_score", 
                        `title`="F1-Score", 
                        `type`="number", 
                        `format`="zto"))))
            self$add(jmvcore::Table$new(
                options=options,
                name="qualityAssessmentTable",
                title="Quality Assessment Summary",
                visible="(quality_thresholds)",
                columns=list(
                    list(
                        `name`="quality_category", 
                        `title`="Quality Category", 
                        `type`="text"),
                    list(
                        `name`="n_images", 
                        `title`="N Images", 
                        `type`="integer"),
                    list(
                        `name`="percentage", 
                        `title`="Percentage", 
                        `type`="number", 
                        `format`="pc"),
                    list(
                        `name`="dice_range", 
                        `title`="Dice Range", 
                        `type`="text"))))
            self$add(jmvcore::Table$new(
                options=options,
                name="outlierImagesTable",
                title="Outlier Images (Poor Performance)",
                visible="(outlier_detection)",
                columns=list(
                    list(
                        `name`="image_id", 
                        `title`="Image ID", 
                        `type`="text"),
                    list(
                        `name`="dice", 
                        `title`="Dice", 
                        `type`="number", 
                        `format`="zto"),
                    list(
                        `name`="iou", 
                        `title`="IoU", 
                        `type`="number", 
                        `format`="zto"),
                    list(
                        `name`="outlier_score", 
                        `title`="Outlier Score", 
                        `type`="number", 
                        `format`="zto"),
                    list(
                        `name`="reason", 
                        `title`="Reason", 
                        `type`="text"))))
            self$add(jmvcore::Table$new(
                options=options,
                name="stratifiedAnalysisTable",
                title="Stratified Analysis",
                visible="(stratified_analysis)",
                columns=list(
                    list(
                        `name`="stratum", 
                        `title`="Stratum", 
                        `type`="text"),
                    list(
                        `name`="n_images", 
                        `title`="N Images", 
                        `type`="integer"),
                    list(
                        `name`="mean_dice", 
                        `title`="Mean Dice", 
                        `type`="number", 
                        `format`="zto"),
                    list(
                        `name`="mean_iou", 
                        `title`="Mean IoU", 
                        `type`="number", 
                        `format`="zto"),
                    list(
                        `name`="sd_dice", 
                        `title`="SD Dice", 
                        `type`="number", 
                        `format`="zto"))))
            self$add(jmvcore::Table$new(
                options=options,
                name="comparisonTable",
                title="Method Comparison (Paired Analysis)",
                visible="(paired_analysis)",
                columns=list(
                    list(
                        `name`="comparison", 
                        `title`="Comparison", 
                        `type`="text"),
                    list(
                        `name`="mean_diff_dice", 
                        `title`="Mean Diff (Dice)", 
                        `type`="number", 
                        `format`="zto"),
                    list(
                        `name`="ci_lower", 
                        `title`="95% CI Lower", 
                        `type`="number", 
                        `format`="zto"),
                    list(
                        `name`="ci_upper", 
                        `title`="95% CI Upper", 
                        `type`="number", 
                        `format`="zto"),
                    list(
                        `name`="p_value", 
                        `title`="p-value", 
                        `type`="number", 
                        `format`="zto,pvalue"),
                    list(
                        `name`="conclusion", 
                        `title`="Conclusion", 
                        `type`="text"))))
            self$add(jmvcore::Image$new(
                options=options,
                name="metricDistributionPlot",
                title="Metric Distribution Across Images",
                width=700,
                height=500,
                renderFun=".plotMetricDistribution",
                visible="(plot_metric_distribution)"))
            self$add(jmvcore::Image$new(
                options=options,
                name="scatterComparisonPlot",
                title="Dice vs IoU Scatter Plot",
                width=600,
                height=600,
                renderFun=".plotScatterComparison",
                visible="(plot_scatter_comparison)"))
            self$add(jmvcore::Image$new(
                options=options,
                name="boundaryErrorPlot",
                title="Boundary Error Analysis",
                width=700,
                height=500,
                renderFun=".plotBoundaryError",
                visible="(plot_boundary_error)"))
            self$add(jmvcore::Image$new(
                options=options,
                name="confusionMatrixPlot",
                title="Pixel-wise Confusion Matrix",
                width=600,
                height=600,
                renderFun=".plotConfusionMatrix",
                visible="(plot_confusion_matrix)"))
            self$add(jmvcore::Image$new(
                options=options,
                name="performanceByClassPlot",
                title="Performance by Class",
                width=700,
                height=500,
                renderFun=".plotPerformanceByClass",
                visible="(plot_performance_by_class)"))
            self$add(jmvcore::Html$new(
                options=options,
                name="clinicalInterpretation",
                title="Clinical Interpretation & Recommendations",
                visible="(show_interpretation)"))}))

segmentationmetricsBase <- if (requireNamespace("jmvcore", quietly=TRUE)) R6::R6Class(
    "segmentationmetricsBase",
    inherit = jmvcore::Analysis,
    public = list(
        initialize = function(options, data=NULL, datasetId="", analysisId="", revision=0) {
            super$initialize(
                package = "ClinicoPath",
                name = "segmentationmetrics",
                version = c(0,0,32),
                options = options,
                results = segmentationmetricsResults$new(options=options),
                data = data,
                datasetId = datasetId,
                analysisId = analysisId,
                revision = revision,
                pause = NULL,
                completeWhenFilled = FALSE,
                requiresMissings = FALSE,
                weightsSupport = 'auto')
        }))

#' Segmentation Metrics (Dice, IoU, Hausdorff)
#'
#' Comprehensive validation metrics for image segmentation tasks in digital 
#' pathology and AI-based tissue analysis. Evaluates overlap and boundary 
#' accuracy between AI-predicted segmentations and expert-annotated ground 
#' truth. Essential metrics include Dice Coefficient (F1-score for spatial 
#' overlap), Jaccard Index (IoU - Intersection over Union), Hausdorff Distance 
#' (maximum boundary deviation), and Surface Distance metrics. Designed for 
#' tumor boundary delineation, gland segmentation, cell nuclei detection, 
#' tissue region classification, and any pixel-level or region-based 
#' segmentation task. Supports binary segmentation (single structure), 
#' multi-class segmentation (multiple tissue types), and instance segmentation 
#' (individual object detection). Provides statistical analysis across 
#' multiple images, stratification by image characteristics (magnification, 
#' staining, scanner), and clinical interpretation of segmentation quality. 
#' Critical for validating AI algorithms before deployment in diagnostic 
#' workflows, comparing segmentation methods, and establishing performance 
#' benchmarks for digital pathology systems.
#' 
#'
#' @examples
#' result <- segmentationmetrics(
#'     data = segmentation_results,
#'     prediction_mask = "ai_segmentation",
#'     ground_truth_mask = "expert_annotation",
#'     image_id = "slide_id",
#'     metric_type = "all"
#' )
#'
#' @param data The data as a data frame.
#' @param prediction_mask AI-predicted segmentation mask. For binary
#'   segmentation, this is a binary variable (0/1 or background/foreground). For
#'   multi-class, this contains class labels. Can be pixel-level or region-level
#'   data.
#' @param ground_truth_mask Expert-annotated ground truth segmentation mask.
#'   Must have the same encoding scheme as prediction_mask.
#' @param image_id Variable identifying individual images or regions. Used to
#'   aggregate metrics per image and calculate summary statistics across images.
#' @param segmentation_type Type of segmentation task. Binary for single
#'   structure (e.g., tumor vs background), multi-class for multiple tissue
#'   types (e.g., epithelium/stroma/necrosis), instance for individual object
#'   detection (e.g., separate cell nuclei).
#' @param positive_class For binary segmentation, specify which level
#'   represents the foreground/ structure of interest (e.g., tumor, gland,
#'   nucleus).
#' @param dice_coefficient Calculate Dice coefficient (also known as F1-score
#'   for segmentation). Measures spatial overlap: Dice = 2|A∩B| / (|A|+|B|).
#'   Range 0-1, where 1 = perfect overlap. Most commonly used segmentation
#'   metric.
#' @param jaccard_index Calculate Jaccard Index (Intersection over Union).
#'   Measures overlap: IoU = |A∩B| / |A∪B|. Range 0-1. Related to Dice: IoU =
#'   Dice/(2-Dice). Standard metric in computer vision and AI segmentation.
#' @param volumetric_similarity Calculate Volumetric Similarity coefficient
#'   for 3D segmentation or area-based similarity in 2D. Useful for volume/area
#'   preservation analysis.
#' @param sensitivity_specificity Calculate pixel-wise sensitivity (true
#'   positive rate) and specificity (true negative rate). Shows
#'   over-segmentation vs under-segmentation.
#' @param hausdorff_distance Calculate Hausdorff Distance - maximum distance
#'   from predicted boundary to ground truth boundary. Sensitive to outliers.
#'   Measures worst-case boundary error. Reported in pixels or mm if pixel size
#'   provided.
#' @param average_hausdorff Calculate Average Hausdorff Distance (95th
#'   percentile). More robust to outliers than maximum Hausdorff. Better
#'   represents typical boundary error.
#' @param surface_distance Calculate average distance between predicted and
#'   ground truth boundaries. Mean of all point-to-surface distances. Provides
#'   average boundary error.
#' @param surface_overlap Calculate Surface Dice (boundary-focused Dice). Only
#'   considers points near boundaries. Emphasizes boundary accuracy over volume
#'   accuracy.
#' @param boundary_tolerance Tolerance distance for surface/boundary metrics
#'   in pixels. Points within this distance are considered boundary points.
#'   Typical: 1-5 pixels depending on magnification.
#' @param pixel_size_provided Whether pixel/voxel physical dimensions are
#'   available for converting pixel-based metrics to physical distances
#'   (micrometers, millimeters).
#' @param pixel_size_x Physical size of one pixel in X dimension
#'   (micrometers). Used to convert pixel-based distances to micrometers.
#'   Typical WSI: 0.25-0.5 μm/pixel.
#' @param pixel_size_y Physical size of one pixel in Y dimension
#'   (micrometers).
#' @param class_specific_metrics For multi-class segmentation, calculate
#'   metrics separately for each class (one-vs-rest approach). Shows performance
#'   per tissue type.
#' @param macro_average Calculate macro-average (unweighted mean) of metrics
#'   across all classes. Treats all classes equally regardless of size.
#' @param weighted_average Calculate weighted average of metrics, weighted by
#'   class prevalence/size. Emphasizes performance on larger structures.
#' @param object_detection_metrics For instance segmentation, calculate
#'   object-level detection metrics: precision, recall, F1-score based on IoU
#'   threshold for matching objects.
#' @param iou_threshold Minimum IoU between predicted and ground truth objects
#'   to consider them matched. Standard: 0.5 for object detection, 0.7 for
#'   strict matching.
#' @param count_metrics Calculate object counting accuracy for instance
#'   segmentation (e.g., cell count accuracy, absolute/relative counting error).
#' @param confidence_intervals Calculate confidence intervals for metrics
#'   across images using bootstrap or normal approximation.
#' @param bootstrap_ci Use bootstrap resampling for confidence intervals
#'   instead of normal approximation. More accurate for small sample sizes or
#'   skewed distributions.
#' @param bootstrap_samples Number of bootstrap samples for confidence
#'   interval estimation.
#' @param confidence_level Confidence level for interval estimation (default
#'   95\%).
#' @param quality_thresholds Apply clinical quality thresholds to categorize
#'   segmentation performance (excellent/good/acceptable/poor) based on Dice/IoU
#'   values.
#' @param dice_threshold_excellent Dice coefficient threshold for "excellent"
#'   segmentation quality. Typical: ≥0.90 for clinical deployment.
#' @param dice_threshold_good Dice coefficient threshold for "good"
#'   segmentation quality.
#' @param dice_threshold_acceptable Dice coefficient threshold for minimally
#'   "acceptable" segmentation. Below this may require human review.
#' @param stratified_analysis Perform stratified analysis by image
#'   characteristics (scanner, magnification, staining protocol, tissue type) to
#'   assess consistency.
#' @param stratify_by Variable for stratified analysis (e.g., scanner_type,
#'   magnification, stain).
#' @param outlier_detection Detect outlier images with unusually poor
#'   segmentation performance. Flags images requiring expert review.
#' @param outlier_method Method for outlier detection across images.
#' @param plot_metric_distribution Plot distribution of metrics across images
#'   (histogram/violin plot). Shows variability in segmentation quality.
#' @param plot_scatter_comparison Scatter plot showing relationship between
#'   Dice and IoU across images.
#' @param plot_boundary_error Plot Hausdorff and surface distances to
#'   visualize boundary accuracy.
#' @param plot_confusion_matrix For multi-class segmentation, show confusion
#'   matrix of pixel classifications.
#' @param plot_performance_by_class Bar plot showing metrics for each class in
#'   multi-class segmentation.
#' @param application_context Clinical/research application context for
#'   interpretation guidance.
#' @param show_interpretation Provide interpretation of results including
#'   recommendations for clinical deployment based on performance metrics.
#' @param paired_analysis Perform paired statistical tests comparing
#'   segmentation performance between different AI models or methods on the same
#'   images.
#' @param comparison_method Variable identifying different segmentation
#'   methods for comparison.
#' @param missing_handling How to handle images with missing or incomplete
#'   segmentations.
#' @param random_seed Random seed for bootstrap sampling and other stochastic
#'   procedures.
#' @return A results object containing:
#' \tabular{llllll}{
#'   \code{results$instructions} \tab \tab \tab \tab \tab a html \cr
#'   \code{results$overallSummary} \tab \tab \tab \tab \tab a table \cr
#'   \code{results$overlapMetricsTable} \tab \tab \tab \tab \tab a table \cr
#'   \code{results$distanceMetricsTable} \tab \tab \tab \tab \tab a table \cr
#'   \code{results$multiclassMetricsTable} \tab \tab \tab \tab \tab a table \cr
#'   \code{results$instanceMetricsTable} \tab \tab \tab \tab \tab a table \cr
#'   \code{results$qualityAssessmentTable} \tab \tab \tab \tab \tab a table \cr
#'   \code{results$outlierImagesTable} \tab \tab \tab \tab \tab a table \cr
#'   \code{results$stratifiedAnalysisTable} \tab \tab \tab \tab \tab a table \cr
#'   \code{results$comparisonTable} \tab \tab \tab \tab \tab a table \cr
#'   \code{results$metricDistributionPlot} \tab \tab \tab \tab \tab an image \cr
#'   \code{results$scatterComparisonPlot} \tab \tab \tab \tab \tab an image \cr
#'   \code{results$boundaryErrorPlot} \tab \tab \tab \tab \tab an image \cr
#'   \code{results$confusionMatrixPlot} \tab \tab \tab \tab \tab an image \cr
#'   \code{results$performanceByClassPlot} \tab \tab \tab \tab \tab an image \cr
#'   \code{results$clinicalInterpretation} \tab \tab \tab \tab \tab a html \cr
#' }
#'
#' Tables can be converted to data frames with \code{asDF} or \code{\link{as.data.frame}}. For example:
#'
#' \code{results$overallSummary$asDF}
#'
#' \code{as.data.frame(results$overallSummary)}
#'
#' @export
segmentationmetrics <- function(
    data,
    prediction_mask,
    ground_truth_mask,
    image_id,
    segmentation_type = "binary",
    positive_class,
    dice_coefficient = TRUE,
    jaccard_index = TRUE,
    volumetric_similarity = FALSE,
    sensitivity_specificity = TRUE,
    hausdorff_distance = TRUE,
    average_hausdorff = TRUE,
    surface_distance = TRUE,
    surface_overlap = FALSE,
    boundary_tolerance = 2,
    pixel_size_provided = FALSE,
    pixel_size_x = 0.5,
    pixel_size_y = 0.5,
    class_specific_metrics = TRUE,
    macro_average = TRUE,
    weighted_average = TRUE,
    object_detection_metrics = FALSE,
    iou_threshold = 0.5,
    count_metrics = FALSE,
    confidence_intervals = TRUE,
    bootstrap_ci = FALSE,
    bootstrap_samples = 1000,
    confidence_level = 0.95,
    quality_thresholds = TRUE,
    dice_threshold_excellent = 0.9,
    dice_threshold_good = 0.8,
    dice_threshold_acceptable = 0.7,
    stratified_analysis = FALSE,
    stratify_by,
    outlier_detection = TRUE,
    outlier_method = "iqr",
    plot_metric_distribution = TRUE,
    plot_scatter_comparison = TRUE,
    plot_boundary_error = TRUE,
    plot_confusion_matrix = FALSE,
    plot_performance_by_class = FALSE,
    application_context = "general",
    show_interpretation = TRUE,
    paired_analysis = FALSE,
    comparison_method,
    missing_handling = "complete",
    random_seed = 123) {

    if ( ! requireNamespace("jmvcore", quietly=TRUE))
        stop("segmentationmetrics requires jmvcore to be installed (restart may be required)")

    if ( ! missing(prediction_mask)) prediction_mask <- jmvcore::resolveQuo(jmvcore::enquo(prediction_mask))
    if ( ! missing(ground_truth_mask)) ground_truth_mask <- jmvcore::resolveQuo(jmvcore::enquo(ground_truth_mask))
    if ( ! missing(image_id)) image_id <- jmvcore::resolveQuo(jmvcore::enquo(image_id))
    if ( ! missing(stratify_by)) stratify_by <- jmvcore::resolveQuo(jmvcore::enquo(stratify_by))
    if ( ! missing(comparison_method)) comparison_method <- jmvcore::resolveQuo(jmvcore::enquo(comparison_method))
    if (missing(data))
        data <- jmvcore::marshalData(
            parent.frame(),
            `if`( ! missing(prediction_mask), prediction_mask, NULL),
            `if`( ! missing(ground_truth_mask), ground_truth_mask, NULL),
            `if`( ! missing(image_id), image_id, NULL),
            `if`( ! missing(stratify_by), stratify_by, NULL),
            `if`( ! missing(comparison_method), comparison_method, NULL))

    for (v in image_id) if (v %in% names(data)) data[[v]] <- as.factor(data[[v]])
    for (v in stratify_by) if (v %in% names(data)) data[[v]] <- as.factor(data[[v]])
    for (v in comparison_method) if (v %in% names(data)) data[[v]] <- as.factor(data[[v]])

    options <- segmentationmetricsOptions$new(
        prediction_mask = prediction_mask,
        ground_truth_mask = ground_truth_mask,
        image_id = image_id,
        segmentation_type = segmentation_type,
        positive_class = positive_class,
        dice_coefficient = dice_coefficient,
        jaccard_index = jaccard_index,
        volumetric_similarity = volumetric_similarity,
        sensitivity_specificity = sensitivity_specificity,
        hausdorff_distance = hausdorff_distance,
        average_hausdorff = average_hausdorff,
        surface_distance = surface_distance,
        surface_overlap = surface_overlap,
        boundary_tolerance = boundary_tolerance,
        pixel_size_provided = pixel_size_provided,
        pixel_size_x = pixel_size_x,
        pixel_size_y = pixel_size_y,
        class_specific_metrics = class_specific_metrics,
        macro_average = macro_average,
        weighted_average = weighted_average,
        object_detection_metrics = object_detection_metrics,
        iou_threshold = iou_threshold,
        count_metrics = count_metrics,
        confidence_intervals = confidence_intervals,
        bootstrap_ci = bootstrap_ci,
        bootstrap_samples = bootstrap_samples,
        confidence_level = confidence_level,
        quality_thresholds = quality_thresholds,
        dice_threshold_excellent = dice_threshold_excellent,
        dice_threshold_good = dice_threshold_good,
        dice_threshold_acceptable = dice_threshold_acceptable,
        stratified_analysis = stratified_analysis,
        stratify_by = stratify_by,
        outlier_detection = outlier_detection,
        outlier_method = outlier_method,
        plot_metric_distribution = plot_metric_distribution,
        plot_scatter_comparison = plot_scatter_comparison,
        plot_boundary_error = plot_boundary_error,
        plot_confusion_matrix = plot_confusion_matrix,
        plot_performance_by_class = plot_performance_by_class,
        application_context = application_context,
        show_interpretation = show_interpretation,
        paired_analysis = paired_analysis,
        comparison_method = comparison_method,
        missing_handling = missing_handling,
        random_seed = random_seed)

    analysis <- segmentationmetricsClass$new(
        options = options,
        data = data)

    analysis$run()

    analysis$results
}

