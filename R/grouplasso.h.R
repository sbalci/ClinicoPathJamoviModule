
# This file is automatically generated, you probably don't want to edit this

grouplassoOptions <- if (requireNamespace("jmvcore", quietly=TRUE)) R6::R6Class(
    "grouplassoOptions",
    inherit = jmvcore::Options,
    public = list(
        initialize = function(
            time = NULL,
            event = NULL,
            predictors = NULL,
            strata = NULL,
            group_definition = "automatic",
            group_structure = "",
            factor_grouping = TRUE,
            penalty_type = "group_lasso",
            alpha = 0.5,
            group_weights = "sqrt_size",
            custom_weights = "",
            cv_folds = 10,
            cv_measure = "deviance",
            lambda_sequence = "auto",
            n_lambda = 50,
            lambda_min_ratio = 0.01,
            algorithm = "coordinate",
            max_iterations = 1000,
            tolerance = 0.000001,
            selection_threshold = 1e-8,
            stability_selection = FALSE,
            bootstrap_samples = 100,
            stability_threshold = 0.6,
            nested_cv = FALSE,
            inner_cv_folds = 5,
            permutation_test = FALSE,
            n_permutations = 100,
            show_group_summary = TRUE,
            show_coefficients = TRUE,
            show_path_summary = TRUE,
            show_cv_results = TRUE,
            plot_regularization_path = TRUE,
            plot_cv_curve = TRUE,
            plot_group_importance = TRUE,
            plot_stability = FALSE,
            plot_group_structure = FALSE,
            standardize = TRUE,
            center_groups = FALSE,
            adaptive_weights_method = "ridge",
            warm_start = TRUE,
            parallel_computing = FALSE,
            random_seed = 123, ...) {

            super$initialize(
                package="ClinicoPath",
                name="grouplasso",
                requiresData=TRUE,
                ...)

            private$..time <- jmvcore::OptionVariable$new(
                "time",
                time,
                suggested=list(
                    "continuous"),
                permitted=list(
                    "numeric"))
            private$..event <- jmvcore::OptionVariable$new(
                "event",
                event,
                suggested=list(
                    "ordinal",
                    "nominal"),
                permitted=list(
                    "factor",
                    "numeric"))
            private$..predictors <- jmvcore::OptionVariables$new(
                "predictors",
                predictors,
                suggested=list(
                    "continuous",
                    "ordinal",
                    "nominal"),
                permitted=list(
                    "numeric",
                    "factor"))
            private$..strata <- jmvcore::OptionVariable$new(
                "strata",
                strata,
                suggested=list(
                    "nominal",
                    "ordinal"),
                permitted=list(
                    "factor"))
            private$..group_definition <- jmvcore::OptionList$new(
                "group_definition",
                group_definition,
                options=list(
                    "automatic",
                    "custom",
                    "factor_based",
                    "biological"),
                default="automatic")
            private$..group_structure <- jmvcore::OptionString$new(
                "group_structure",
                group_structure,
                default="")
            private$..factor_grouping <- jmvcore::OptionBool$new(
                "factor_grouping",
                factor_grouping,
                default=TRUE)
            private$..penalty_type <- jmvcore::OptionList$new(
                "penalty_type",
                penalty_type,
                options=list(
                    "group_lasso",
                    "sparse_group",
                    "adaptive_group",
                    "overlapping"),
                default="group_lasso")
            private$..alpha <- jmvcore::OptionNumber$new(
                "alpha",
                alpha,
                default=0.5,
                min=0,
                max=1)
            private$..group_weights <- jmvcore::OptionList$new(
                "group_weights",
                group_weights,
                options=list(
                    "equal",
                    "sqrt_size",
                    "group_size",
                    "adaptive",
                    "custom"),
                default="sqrt_size")
            private$..custom_weights <- jmvcore::OptionString$new(
                "custom_weights",
                custom_weights,
                default="")
            private$..cv_folds <- jmvcore::OptionInteger$new(
                "cv_folds",
                cv_folds,
                default=10,
                min=3,
                max=20)
            private$..cv_measure <- jmvcore::OptionList$new(
                "cv_measure",
                cv_measure,
                options=list(
                    "deviance",
                    "C",
                    "brier"),
                default="deviance")
            private$..lambda_sequence <- jmvcore::OptionList$new(
                "lambda_sequence",
                lambda_sequence,
                options=list(
                    "auto",
                    "custom",
                    "single"),
                default="auto")
            private$..n_lambda <- jmvcore::OptionInteger$new(
                "n_lambda",
                n_lambda,
                default=50,
                min=10,
                max=200)
            private$..lambda_min_ratio <- jmvcore::OptionNumber$new(
                "lambda_min_ratio",
                lambda_min_ratio,
                default=0.01,
                min=0.000001,
                max=0.1)
            private$..algorithm <- jmvcore::OptionList$new(
                "algorithm",
                algorithm,
                options=list(
                    "coordinate",
                    "proximal",
                    "admm"),
                default="coordinate")
            private$..max_iterations <- jmvcore::OptionInteger$new(
                "max_iterations",
                max_iterations,
                default=1000,
                min=100,
                max=10000)
            private$..tolerance <- jmvcore::OptionNumber$new(
                "tolerance",
                tolerance,
                default=0.000001,
                min=1e-10,
                max=0.001)
            private$..selection_threshold <- jmvcore::OptionNumber$new(
                "selection_threshold",
                selection_threshold,
                default=1e-8,
                min=1e-12,
                max=0.001)
            private$..stability_selection <- jmvcore::OptionBool$new(
                "stability_selection",
                stability_selection,
                default=FALSE)
            private$..bootstrap_samples <- jmvcore::OptionInteger$new(
                "bootstrap_samples",
                bootstrap_samples,
                default=100,
                min=50,
                max=1000)
            private$..stability_threshold <- jmvcore::OptionNumber$new(
                "stability_threshold",
                stability_threshold,
                default=0.6,
                min=0.5,
                max=0.95)
            private$..nested_cv <- jmvcore::OptionBool$new(
                "nested_cv",
                nested_cv,
                default=FALSE)
            private$..inner_cv_folds <- jmvcore::OptionInteger$new(
                "inner_cv_folds",
                inner_cv_folds,
                default=5,
                min=3,
                max=10)
            private$..permutation_test <- jmvcore::OptionBool$new(
                "permutation_test",
                permutation_test,
                default=FALSE)
            private$..n_permutations <- jmvcore::OptionInteger$new(
                "n_permutations",
                n_permutations,
                default=100,
                min=50,
                max=1000)
            private$..show_group_summary <- jmvcore::OptionBool$new(
                "show_group_summary",
                show_group_summary,
                default=TRUE)
            private$..show_coefficients <- jmvcore::OptionBool$new(
                "show_coefficients",
                show_coefficients,
                default=TRUE)
            private$..show_path_summary <- jmvcore::OptionBool$new(
                "show_path_summary",
                show_path_summary,
                default=TRUE)
            private$..show_cv_results <- jmvcore::OptionBool$new(
                "show_cv_results",
                show_cv_results,
                default=TRUE)
            private$..plot_regularization_path <- jmvcore::OptionBool$new(
                "plot_regularization_path",
                plot_regularization_path,
                default=TRUE)
            private$..plot_cv_curve <- jmvcore::OptionBool$new(
                "plot_cv_curve",
                plot_cv_curve,
                default=TRUE)
            private$..plot_group_importance <- jmvcore::OptionBool$new(
                "plot_group_importance",
                plot_group_importance,
                default=TRUE)
            private$..plot_stability <- jmvcore::OptionBool$new(
                "plot_stability",
                plot_stability,
                default=FALSE)
            private$..plot_group_structure <- jmvcore::OptionBool$new(
                "plot_group_structure",
                plot_group_structure,
                default=FALSE)
            private$..standardize <- jmvcore::OptionBool$new(
                "standardize",
                standardize,
                default=TRUE)
            private$..center_groups <- jmvcore::OptionBool$new(
                "center_groups",
                center_groups,
                default=FALSE)
            private$..adaptive_weights_method <- jmvcore::OptionList$new(
                "adaptive_weights_method",
                adaptive_weights_method,
                options=list(
                    "ridge",
                    "univariate",
                    "ols"),
                default="ridge")
            private$..warm_start <- jmvcore::OptionBool$new(
                "warm_start",
                warm_start,
                default=TRUE)
            private$..parallel_computing <- jmvcore::OptionBool$new(
                "parallel_computing",
                parallel_computing,
                default=FALSE)
            private$..random_seed <- jmvcore::OptionInteger$new(
                "random_seed",
                random_seed,
                default=123,
                min=1,
                max=999999)

            self$.addOption(private$..time)
            self$.addOption(private$..event)
            self$.addOption(private$..predictors)
            self$.addOption(private$..strata)
            self$.addOption(private$..group_definition)
            self$.addOption(private$..group_structure)
            self$.addOption(private$..factor_grouping)
            self$.addOption(private$..penalty_type)
            self$.addOption(private$..alpha)
            self$.addOption(private$..group_weights)
            self$.addOption(private$..custom_weights)
            self$.addOption(private$..cv_folds)
            self$.addOption(private$..cv_measure)
            self$.addOption(private$..lambda_sequence)
            self$.addOption(private$..n_lambda)
            self$.addOption(private$..lambda_min_ratio)
            self$.addOption(private$..algorithm)
            self$.addOption(private$..max_iterations)
            self$.addOption(private$..tolerance)
            self$.addOption(private$..selection_threshold)
            self$.addOption(private$..stability_selection)
            self$.addOption(private$..bootstrap_samples)
            self$.addOption(private$..stability_threshold)
            self$.addOption(private$..nested_cv)
            self$.addOption(private$..inner_cv_folds)
            self$.addOption(private$..permutation_test)
            self$.addOption(private$..n_permutations)
            self$.addOption(private$..show_group_summary)
            self$.addOption(private$..show_coefficients)
            self$.addOption(private$..show_path_summary)
            self$.addOption(private$..show_cv_results)
            self$.addOption(private$..plot_regularization_path)
            self$.addOption(private$..plot_cv_curve)
            self$.addOption(private$..plot_group_importance)
            self$.addOption(private$..plot_stability)
            self$.addOption(private$..plot_group_structure)
            self$.addOption(private$..standardize)
            self$.addOption(private$..center_groups)
            self$.addOption(private$..adaptive_weights_method)
            self$.addOption(private$..warm_start)
            self$.addOption(private$..parallel_computing)
            self$.addOption(private$..random_seed)
        }),
    active = list(
        time = function() private$..time$value,
        event = function() private$..event$value,
        predictors = function() private$..predictors$value,
        strata = function() private$..strata$value,
        group_definition = function() private$..group_definition$value,
        group_structure = function() private$..group_structure$value,
        factor_grouping = function() private$..factor_grouping$value,
        penalty_type = function() private$..penalty_type$value,
        alpha = function() private$..alpha$value,
        group_weights = function() private$..group_weights$value,
        custom_weights = function() private$..custom_weights$value,
        cv_folds = function() private$..cv_folds$value,
        cv_measure = function() private$..cv_measure$value,
        lambda_sequence = function() private$..lambda_sequence$value,
        n_lambda = function() private$..n_lambda$value,
        lambda_min_ratio = function() private$..lambda_min_ratio$value,
        algorithm = function() private$..algorithm$value,
        max_iterations = function() private$..max_iterations$value,
        tolerance = function() private$..tolerance$value,
        selection_threshold = function() private$..selection_threshold$value,
        stability_selection = function() private$..stability_selection$value,
        bootstrap_samples = function() private$..bootstrap_samples$value,
        stability_threshold = function() private$..stability_threshold$value,
        nested_cv = function() private$..nested_cv$value,
        inner_cv_folds = function() private$..inner_cv_folds$value,
        permutation_test = function() private$..permutation_test$value,
        n_permutations = function() private$..n_permutations$value,
        show_group_summary = function() private$..show_group_summary$value,
        show_coefficients = function() private$..show_coefficients$value,
        show_path_summary = function() private$..show_path_summary$value,
        show_cv_results = function() private$..show_cv_results$value,
        plot_regularization_path = function() private$..plot_regularization_path$value,
        plot_cv_curve = function() private$..plot_cv_curve$value,
        plot_group_importance = function() private$..plot_group_importance$value,
        plot_stability = function() private$..plot_stability$value,
        plot_group_structure = function() private$..plot_group_structure$value,
        standardize = function() private$..standardize$value,
        center_groups = function() private$..center_groups$value,
        adaptive_weights_method = function() private$..adaptive_weights_method$value,
        warm_start = function() private$..warm_start$value,
        parallel_computing = function() private$..parallel_computing$value,
        random_seed = function() private$..random_seed$value),
    private = list(
        ..time = NA,
        ..event = NA,
        ..predictors = NA,
        ..strata = NA,
        ..group_definition = NA,
        ..group_structure = NA,
        ..factor_grouping = NA,
        ..penalty_type = NA,
        ..alpha = NA,
        ..group_weights = NA,
        ..custom_weights = NA,
        ..cv_folds = NA,
        ..cv_measure = NA,
        ..lambda_sequence = NA,
        ..n_lambda = NA,
        ..lambda_min_ratio = NA,
        ..algorithm = NA,
        ..max_iterations = NA,
        ..tolerance = NA,
        ..selection_threshold = NA,
        ..stability_selection = NA,
        ..bootstrap_samples = NA,
        ..stability_threshold = NA,
        ..nested_cv = NA,
        ..inner_cv_folds = NA,
        ..permutation_test = NA,
        ..n_permutations = NA,
        ..show_group_summary = NA,
        ..show_coefficients = NA,
        ..show_path_summary = NA,
        ..show_cv_results = NA,
        ..plot_regularization_path = NA,
        ..plot_cv_curve = NA,
        ..plot_group_importance = NA,
        ..plot_stability = NA,
        ..plot_group_structure = NA,
        ..standardize = NA,
        ..center_groups = NA,
        ..adaptive_weights_method = NA,
        ..warm_start = NA,
        ..parallel_computing = NA,
        ..random_seed = NA)
)

grouplassoResults <- if (requireNamespace("jmvcore", quietly=TRUE)) R6::R6Class(
    "grouplassoResults",
    inherit = jmvcore::Group,
    active = list(
        instructions = function() private$.items[["instructions"]],
        todo = function() private$.items[["todo"]],
        groupSummary = function() private$.items[["groupSummary"]],
        coefficients = function() private$.items[["coefficients"]],
        pathSummary = function() private$.items[["pathSummary"]],
        cvResults = function() private$.items[["cvResults"]],
        stabilityResults = function() private$.items[["stabilityResults"]],
        modelPerformance = function() private$.items[["modelPerformance"]],
        nestedCVResults = function() private$.items[["nestedCVResults"]],
        permutationResults = function() private$.items[["permutationResults"]],
        pathPlot = function() private$.items[["pathPlot"]],
        cvPlot = function() private$.items[["cvPlot"]],
        importancePlot = function() private$.items[["importancePlot"]],
        stabilityPlot = function() private$.items[["stabilityPlot"]],
        groupStructurePlot = function() private$.items[["groupStructurePlot"]]),
    private = list(),
    public=list(
        initialize=function(options) {
            super$initialize(
                options=options,
                name="",
                title="Analysis Results")
            self$add(jmvcore::Html$new(
                options=options,
                name="instructions",
                title="Instructions",
                visible=FALSE))
            self$add(jmvcore::Html$new(
                options=options,
                name="todo",
                title="Analysis Todo",
                visible=FALSE))
            self$add(jmvcore::Table$new(
                options=options,
                name="groupSummary",
                title="Group Structure Summary",
                visible="(show_group_summary)",
                clearWith=list(
                    "predictors",
                    "group_definition",
                    "group_structure"),
                columns=list(
                    list(
                        `name`="group_id", 
                        `title`="Group ID", 
                        `type`="integer"),
                    list(
                        `name`="group_name", 
                        `title`="Group Name", 
                        `type`="text"),
                    list(
                        `name`="variables", 
                        `title`="Variables", 
                        `type`="text"),
                    list(
                        `name`="group_size", 
                        `title`="Size", 
                        `type`="integer"),
                    list(
                        `name`="group_weight", 
                        `title`="Weight", 
                        `type`="number", 
                        `format`="zto"),
                    list(
                        `name`="selected", 
                        `title`="Selected", 
                        `type`="text"),
                    list(
                        `name`="selection_order", 
                        `title`="Entry Order", 
                        `type`="integer"))))
            self$add(jmvcore::Table$new(
                options=options,
                name="coefficients",
                title="Group LASSO Coefficients",
                visible="(show_coefficients)",
                clearWith=list(
                    "time",
                    "event",
                    "predictors",
                    "penalty_type",
                    "cv_folds"),
                columns=list(
                    list(
                        `name`="group_id", 
                        `title`="Group", 
                        `type`="integer"),
                    list(
                        `name`="variable", 
                        `title`="Variable", 
                        `type`="text"),
                    list(
                        `name`="coefficient", 
                        `title`="Coefficient", 
                        `type`="number", 
                        `format`="zto"),
                    list(
                        `name`="exp_coefficient", 
                        `title`="Hazard Ratio", 
                        `type`="number", 
                        `format`="zto"),
                    list(
                        `name`="group_norm", 
                        `title`="Group Norm", 
                        `type`="number", 
                        `format`="zto"),
                    list(
                        `name`="relative_importance", 
                        `title`="Relative Importance", 
                        `type`="number", 
                        `format`="zto"),
                    list(
                        `name`="selected", 
                        `title`="Selected", 
                        `type`="text"))))
            self$add(jmvcore::Table$new(
                options=options,
                name="pathSummary",
                title="Regularization Path Summary",
                visible="(show_path_summary)",
                clearWith=list(
                    "lambda_sequence",
                    "n_lambda",
                    "penalty_type"),
                columns=list(
                    list(
                        `name`="step", 
                        `title`="Step", 
                        `type`="integer"),
                    list(
                        `name`="lambda", 
                        `title`="Lambda", 
                        `type`="number", 
                        `format`="zto"),
                    list(
                        `name`="n_groups_selected", 
                        `title`="Groups Selected", 
                        `type`="integer"),
                    list(
                        `name`="n_variables_selected", 
                        `title`="Variables Selected", 
                        `type`="integer"),
                    list(
                        `name`="deviance", 
                        `title`="Deviance", 
                        `type`="number", 
                        `format`="zto"),
                    list(
                        `name`="df", 
                        `title`="Degrees of Freedom", 
                        `type`="number", 
                        `format`="zto"))))
            self$add(jmvcore::Table$new(
                options=options,
                name="cvResults",
                title="Cross-Validation Results",
                visible="(show_cv_results)",
                clearWith=list(
                    "cv_folds",
                    "cv_measure",
                    "lambda_sequence"),
                columns=list(
                    list(
                        `name`="criterion", 
                        `title`="Criterion", 
                        `type`="text"),
                    list(
                        `name`="lambda_min", 
                        `title`="Lambda Min", 
                        `type`="number", 
                        `format`="zto"),
                    list(
                        `name`="lambda_1se", 
                        `title`="Lambda 1SE", 
                        `type`="number", 
                        `format`="zto"),
                    list(
                        `name`="cv_error_min", 
                        `title`="Min CV Error", 
                        `type`="number", 
                        `format`="zto"),
                    list(
                        `name`="cv_error_1se", 
                        `title`="1SE CV Error", 
                        `type`="number", 
                        `format`="zto"),
                    list(
                        `name`="groups_min", 
                        `title`="Groups (Min)", 
                        `type`="integer"),
                    list(
                        `name`="groups_1se", 
                        `title`="Groups (1SE)", 
                        `type`="integer"))))
            self$add(jmvcore::Table$new(
                options=options,
                name="stabilityResults",
                title="Stability Selection Results",
                visible="(stability_selection)",
                clearWith=list(
                    "stability_threshold",
                    "bootstrap_samples"),
                columns=list(
                    list(
                        `name`="group_id", 
                        `title`="Group ID", 
                        `type`="integer"),
                    list(
                        `name`="group_name", 
                        `title`="Group Name", 
                        `type`="text"),
                    list(
                        `name`="selection_frequency", 
                        `title`="Selection Frequency", 
                        `type`="number", 
                        `format`="pc"),
                    list(
                        `name`="stability_score", 
                        `title`="Stability Score", 
                        `type`="number", 
                        `format`="zto"),
                    list(
                        `name`="stable_selection", 
                        `title`="Stable Selection", 
                        `type`="text"),
                    list(
                        `name`="first_selected", 
                        `title`="First Selected (Lambda)", 
                        `type`="number", 
                        `format`="zto"))))
            self$add(jmvcore::Table$new(
                options=options,
                name="modelPerformance",
                title="Model Performance",
                clearWith=list(
                    "time",
                    "event",
                    "predictors",
                    "penalty_type"),
                columns=list(
                    list(
                        `name`="metric", 
                        `title`="Metric", 
                        `type`="text"),
                    list(
                        `name`="value", 
                        `title`="Value", 
                        `type`="number", 
                        `format`="zto"),
                    list(
                        `name`="confidence_interval", 
                        `title`="95% CI", 
                        `type`="text"),
                    list(
                        `name`="description", 
                        `title`="Description", 
                        `type`="text"))))
            self$add(jmvcore::Table$new(
                options=options,
                name="nestedCVResults",
                title="Nested Cross-Validation",
                visible="(nested_cv)",
                clearWith=list(
                    "cv_folds",
                    "inner_cv_folds",
                    "nested_cv"),
                columns=list(
                    list(
                        `name`="outer_fold", 
                        `title`="Outer Fold", 
                        `type`="integer"),
                    list(
                        `name`="optimal_lambda", 
                        `title`="Optimal Lambda", 
                        `type`="number", 
                        `format`="zto"),
                    list(
                        `name`="n_groups_selected", 
                        `title`="Groups Selected", 
                        `type`="integer"),
                    list(
                        `name`="performance", 
                        `title`="Performance", 
                        `type`="number", 
                        `format`="zto"),
                    list(
                        `name`="training_error", 
                        `title`="Training Error", 
                        `type`="number", 
                        `format`="zto"))))
            self$add(jmvcore::Table$new(
                options=options,
                name="permutationResults",
                title="Permutation Test Results",
                visible="(permutation_test)",
                clearWith=list(
                    "n_permutations",
                    "permutation_test"),
                columns=list(
                    list(
                        `name`="test_statistic", 
                        `title`="Test Statistic", 
                        `type`="text"),
                    list(
                        `name`="observed_value", 
                        `title`="Observed Value", 
                        `type`="number", 
                        `format`="zto"),
                    list(
                        `name`="permutation_mean", 
                        `title`="Permutation Mean", 
                        `type`="number", 
                        `format`="zto"),
                    list(
                        `name`="permutation_sd", 
                        `title`="Permutation SD", 
                        `type`="number", 
                        `format`="zto"),
                    list(
                        `name`="p_value", 
                        `title`="p-value", 
                        `type`="number", 
                        `format`="zto"))))
            self$add(jmvcore::Image$new(
                options=options,
                name="pathPlot",
                title="Group Regularization Path",
                width=600,
                height=500,
                visible="(plot_regularization_path)",
                requiresData=TRUE,
                clearWith=list(
                    "predictors",
                    "penalty_type",
                    "lambda_sequence")))
            self$add(jmvcore::Image$new(
                options=options,
                name="cvPlot",
                title="Cross-Validation Curve",
                width=500,
                height=400,
                visible="(plot_cv_curve)",
                requiresData=TRUE,
                clearWith=list(
                    "cv_folds",
                    "cv_measure")))
            self$add(jmvcore::Image$new(
                options=options,
                name="importancePlot",
                title="Group Importance",
                width=500,
                height=400,
                visible="(plot_group_importance)",
                requiresData=TRUE,
                clearWith=list(
                    "show_coefficients",
                    "penalty_type")))
            self$add(jmvcore::Image$new(
                options=options,
                name="stabilityPlot",
                title="Stability Selection",
                width=500,
                height=400,
                visible="(plot_stability)",
                requiresData=TRUE,
                clearWith=list(
                    "stability_selection",
                    "stability_threshold")))
            self$add(jmvcore::Image$new(
                options=options,
                name="groupStructurePlot",
                title="Group Structure Visualization",
                width=600,
                height=400,
                visible="(plot_group_structure)",
                requiresData=TRUE,
                clearWith=list(
                    "group_definition",
                    "group_structure")))}))

grouplassoBase <- if (requireNamespace("jmvcore", quietly=TRUE)) R6::R6Class(
    "grouplassoBase",
    inherit = jmvcore::Analysis,
    public = list(
        initialize = function(options, data=NULL, datasetId="", analysisId="", revision=0) {
            super$initialize(
                package = "ClinicoPath",
                name = "grouplasso",
                version = c(0,0,31),
                options = options,
                results = grouplassoResults$new(options=options),
                data = data,
                datasetId = datasetId,
                analysisId = analysisId,
                revision = revision,
                pause = NULL,
                completeWhenFilled = FALSE,
                requiresMissings = FALSE,
                weightsSupport = 'auto')
        }))

#' Group LASSO for Survival Analysis
#'
#' Group LASSO for Cox proportional hazards models enabling simultaneous 
#' selection of pre-defined variable groups while maintaining within-group 
#' structure. This method extends traditional LASSO by applying penalties at 
#' the group level, making it ideal for categorical variables with multiple 
#' dummy codes, grouped biomarkers, or structured predictors like gene 
#' pathways. The implementation supports overlapping groups, adaptive group 
#' weights, sparse group LASSO combining group and individual penalties, and 
#' comprehensive cross-validation for optimal penalty selection. Particularly 
#' valuable for genomic survival analysis, clinical prediction models with 
#' natural variable groupings, and scenarios requiring interpretable 
#' group-wise feature selection with preserved biological or clinical 
#' structure.
#' 
#'
#' @examples
#' result <- grouplasso(
#'     data = mydata,
#'     time = "time_to_event",
#'     event = "event_indicator",
#'     predictors = c("age", "stage", "biomarker1", "biomarker2"),
#'     group_structure = "age:1, stage:2, biomarker1:3, biomarker2:3",
#'     penalty_type = "group_lasso",
#'     cv_folds = 10
#' )
#'
#' @param data The data as a data frame.
#' @param time Time to event variable (numeric). For right-censored data, this
#'   is the  time from study entry to event or censoring.
#' @param event Event indicator variable. For survival analysis: 0 = censored,
#'   1 = event. For competing risks: 0 = censored, 1+ = different event types.
#' @param predictors Variables to include in the group LASSO Cox model.
#'   Variables can be grouped based on biological, clinical, or statistical
#'   criteria. Factor variables are automatically converted to dummy variables.
#' @param strata Optional stratification variable for stratified Cox
#'   regression. Creates separate baseline hazards for each stratum.
#' @param group_definition Method for defining variable groups. Automatic
#'   groups by data type, custom allows manual specification, factor-based
#'   groups dummy variables from same factor, biological supports pathway-based
#'   groupings.
#' @param group_structure Custom group assignment as comma-separated list.
#'   Format: 'var1:group1, var2:group1, var3:group2'. Only used when
#'   group_definition is 'custom'. Groups can overlap.
#' @param factor_grouping Automatically group dummy variables from the same
#'   factor variable. Ensures that factor variables are selected/excluded as
#'   complete units.
#' @param penalty_type Type of group penalty. Group LASSO selects entire
#'   groups, sparse group combines group and individual penalties, adaptive uses
#'   data-driven weights, overlapping handles variables belonging to multiple
#'   groups.
#' @param alpha Mixing parameter for sparse group LASSO. 0 = pure group LASSO,
#'   1 = pure individual LASSO, intermediate values combine both penalties. Only
#'   used for sparse group LASSO.
#' @param group_weights Method for calculating group-specific penalty weights.
#'   Square root of group size is standard, adaptive uses initial estimates,
#'   custom allows user-specified weights.
#' @param custom_weights Custom weights for each group as comma-separated
#'   values. Order should match group numbering. Only used with custom weights.
#' @param cv_folds Number of folds for cross-validation to select optimal
#'   penalty parameter. More folds provide better estimates but increase
#'   computation time.
#' @param cv_measure Performance measure for cross-validation. Deviance is
#'   standard for Cox models, C-index focuses on discrimination, Brier score
#'   provides calibration-aware selection.
#' @param lambda_sequence Specification of penalty parameter sequence.
#'   Automatic uses data-driven range, custom allows user-defined range.
#' @param n_lambda Number of lambda values in the regularization path. More
#'   values provide finer resolution but increase computation time.
#' @param lambda_min_ratio Ratio of smallest to largest lambda in automatic
#'   sequence. Smaller values explore stronger penalties.
#' @param algorithm Optimization algorithm for group LASSO. Coordinate descent
#'   is standard and efficient, proximal gradient handles complex penalties,
#'   ADMM works well for overlapping groups.
#' @param max_iterations Maximum iterations for optimization algorithm.
#'   Increase if convergence warnings occur.
#' @param tolerance Convergence tolerance for optimization. Smaller values
#'   provide more precise solutions but increase computation time.
#' @param selection_threshold Threshold for determining selected groups.
#'   Groups with maximum coefficient magnitude below this value are considered
#'   unselected.
#' @param stability_selection Perform stability selection across bootstrap
#'   samples to identify robust group selection patterns and reduce selection
#'   variability.
#' @param bootstrap_samples Number of bootstrap samples for stability
#'   selection. More samples provide more stable group selection.
#' @param stability_threshold Minimum selection frequency for groups in
#'   stability selection. Higher thresholds provide more conservative selection.
#' @param nested_cv Perform nested cross-validation for unbiased performance
#'   estimation. Provides honest assessment of model performance with optimal
#'   penalties.
#' @param inner_cv_folds Number of inner CV folds for nested cross-validation.
#'   Used for penalty selection within each outer fold.
#' @param permutation_test Perform permutation test to assess statistical
#'   significance of group selection and overall model performance.
#' @param n_permutations Number of permutations for significance testing. More
#'   permutations provide more accurate p-values.
#' @param show_group_summary Display summary of group definitions, sizes, and
#'   selection status with penalty parameter information.
#' @param show_coefficients Display coefficient estimates for selected
#'   variables organized by groups with selection indicators.
#' @param show_path_summary Display summary of regularization path showing
#'   group entry and exit points along penalty sequence.
#' @param show_cv_results Display cross-validation results including optimal
#'   penalty selection and performance metrics.
#' @param plot_regularization_path Plot group-wise coefficient paths showing
#'   how groups enter/exit the model as penalty increases.
#' @param plot_cv_curve Plot cross-validation performance curve with optimal
#'   penalty selection and confidence bands.
#' @param plot_group_importance Visualize relative importance of selected
#'   groups based on coefficient norms and selection frequency.
#' @param plot_stability Plot stability selection results showing group
#'   selection frequencies across bootstrap samples.
#' @param plot_group_structure Visualize group structure and variable
#'   assignments with overlap indicators for complex grouping schemes.
#' @param standardize Standardize variables before fitting. Recommended for
#'   optimal penalty performance across different variable scales.
#' @param center_groups Center variables within their respective groups before
#'   applying penalties. Can improve performance for heterogeneous groups.
#' @param adaptive_weights_method Method for calculating adaptive weights for
#'   groups. Ridge provides stable estimates, univariate uses marginal effects.
#' @param warm_start Use warm start initialization for faster convergence
#'   along the regularization path.
#' @param parallel_computing Use parallel computing for cross-validation and
#'   bootstrap procedures to reduce computation time.
#' @param random_seed Random seed for cross-validation folds and bootstrap
#'   sampling. Ensures reproducible results across analyses.
#' @return A results object containing:
#' \tabular{llllll}{
#'   \code{results$instructions} \tab \tab \tab \tab \tab a html \cr
#'   \code{results$todo} \tab \tab \tab \tab \tab a html \cr
#'   \code{results$groupSummary} \tab \tab \tab \tab \tab a table \cr
#'   \code{results$coefficients} \tab \tab \tab \tab \tab a table \cr
#'   \code{results$pathSummary} \tab \tab \tab \tab \tab a table \cr
#'   \code{results$cvResults} \tab \tab \tab \tab \tab a table \cr
#'   \code{results$stabilityResults} \tab \tab \tab \tab \tab a table \cr
#'   \code{results$modelPerformance} \tab \tab \tab \tab \tab a table \cr
#'   \code{results$nestedCVResults} \tab \tab \tab \tab \tab a table \cr
#'   \code{results$permutationResults} \tab \tab \tab \tab \tab a table \cr
#'   \code{results$pathPlot} \tab \tab \tab \tab \tab an image \cr
#'   \code{results$cvPlot} \tab \tab \tab \tab \tab an image \cr
#'   \code{results$importancePlot} \tab \tab \tab \tab \tab an image \cr
#'   \code{results$stabilityPlot} \tab \tab \tab \tab \tab an image \cr
#'   \code{results$groupStructurePlot} \tab \tab \tab \tab \tab an image \cr
#' }
#'
#' Tables can be converted to data frames with \code{asDF} or \code{\link{as.data.frame}}. For example:
#'
#' \code{results$groupSummary$asDF}
#'
#' \code{as.data.frame(results$groupSummary)}
#'
#' @export
grouplasso <- function(
    data,
    time,
    event,
    predictors,
    strata,
    group_definition = "automatic",
    group_structure = "",
    factor_grouping = TRUE,
    penalty_type = "group_lasso",
    alpha = 0.5,
    group_weights = "sqrt_size",
    custom_weights = "",
    cv_folds = 10,
    cv_measure = "deviance",
    lambda_sequence = "auto",
    n_lambda = 50,
    lambda_min_ratio = 0.01,
    algorithm = "coordinate",
    max_iterations = 1000,
    tolerance = 0.000001,
    selection_threshold = 1e-8,
    stability_selection = FALSE,
    bootstrap_samples = 100,
    stability_threshold = 0.6,
    nested_cv = FALSE,
    inner_cv_folds = 5,
    permutation_test = FALSE,
    n_permutations = 100,
    show_group_summary = TRUE,
    show_coefficients = TRUE,
    show_path_summary = TRUE,
    show_cv_results = TRUE,
    plot_regularization_path = TRUE,
    plot_cv_curve = TRUE,
    plot_group_importance = TRUE,
    plot_stability = FALSE,
    plot_group_structure = FALSE,
    standardize = TRUE,
    center_groups = FALSE,
    adaptive_weights_method = "ridge",
    warm_start = TRUE,
    parallel_computing = FALSE,
    random_seed = 123) {

    if ( ! requireNamespace("jmvcore", quietly=TRUE))
        stop("grouplasso requires jmvcore to be installed (restart may be required)")

    if ( ! missing(time)) time <- jmvcore::resolveQuo(jmvcore::enquo(time))
    if ( ! missing(event)) event <- jmvcore::resolveQuo(jmvcore::enquo(event))
    if ( ! missing(predictors)) predictors <- jmvcore::resolveQuo(jmvcore::enquo(predictors))
    if ( ! missing(strata)) strata <- jmvcore::resolveQuo(jmvcore::enquo(strata))
    if (missing(data))
        data <- jmvcore::marshalData(
            parent.frame(),
            `if`( ! missing(time), time, NULL),
            `if`( ! missing(event), event, NULL),
            `if`( ! missing(predictors), predictors, NULL),
            `if`( ! missing(strata), strata, NULL))

    for (v in strata) if (v %in% names(data)) data[[v]] <- as.factor(data[[v]])

    options <- grouplassoOptions$new(
        time = time,
        event = event,
        predictors = predictors,
        strata = strata,
        group_definition = group_definition,
        group_structure = group_structure,
        factor_grouping = factor_grouping,
        penalty_type = penalty_type,
        alpha = alpha,
        group_weights = group_weights,
        custom_weights = custom_weights,
        cv_folds = cv_folds,
        cv_measure = cv_measure,
        lambda_sequence = lambda_sequence,
        n_lambda = n_lambda,
        lambda_min_ratio = lambda_min_ratio,
        algorithm = algorithm,
        max_iterations = max_iterations,
        tolerance = tolerance,
        selection_threshold = selection_threshold,
        stability_selection = stability_selection,
        bootstrap_samples = bootstrap_samples,
        stability_threshold = stability_threshold,
        nested_cv = nested_cv,
        inner_cv_folds = inner_cv_folds,
        permutation_test = permutation_test,
        n_permutations = n_permutations,
        show_group_summary = show_group_summary,
        show_coefficients = show_coefficients,
        show_path_summary = show_path_summary,
        show_cv_results = show_cv_results,
        plot_regularization_path = plot_regularization_path,
        plot_cv_curve = plot_cv_curve,
        plot_group_importance = plot_group_importance,
        plot_stability = plot_stability,
        plot_group_structure = plot_group_structure,
        standardize = standardize,
        center_groups = center_groups,
        adaptive_weights_method = adaptive_weights_method,
        warm_start = warm_start,
        parallel_computing = parallel_computing,
        random_seed = random_seed)

    analysis <- grouplassoClass$new(
        options = options,
        data = data)

    analysis$run()

    analysis$results
}

