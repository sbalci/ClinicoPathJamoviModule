# A Comprehensive Guide to Writing `.b.R` Files for jamovi Development

This document provides a comprehensive guide to writing `.b.R` files for jamovi module development. This file is the heart of your analysis, containing the R code that performs the calculations and generates the results.

## 1. Introduction: The Role of the `.b.R` File

The `.b.R` file is the "engine" of your jamovi analysis. It's an R script that defines an R6 class responsible for:

*   Initializing the analysis.
*   Running the analysis whenever the user changes an option.
*   Handling the data provided by the user.
*   Performing the statistical calculations.
*   Populating the results objects (tables, plots, etc.) that you defined in your `.r.yaml` file.

## 2. The R6 Class Structure

Every `.b.R` file defines an R6 class that inherits from a base class. The base class is automatically generated by jamovi and is named after your analysis (e.g., `survivalBase`).

```R
survivalClass <- if (requireNamespace('jmvcore'))
    R6::R6Class(
        "survivalClass",
        inherit = survivalBase,
        private = list(
            # ... analysis logic ...
        )
    )
```

*   `"survivalClass"`: The name of your analysis class.
*   `inherit = survivalBase`:  Specifies that this class inherits from the `survivalBase` class. This is how your analysis gets all the jamovi-specific functionality.
*   `private = list(...)`:  All of your analysis logic, including functions and variables, goes inside this `private` list.

## 3. The Core Functions: `.init()` and `.run()`

There are two main functions that you will use to control the lifecycle of your analysis:

### The `.init()` Function

The `.init()` function is called **once** when the analysis is first loaded. It's the perfect place for one-time setup tasks.

```R
.init = function() {
    if (self$options$ph_cox) {
        self$results$cox_ph$setVisible(TRUE)
    }

    if (!(self$options$ph_cox)) {
        self$results$cox_ph$setVisible(FALSE)
    }
}
```

In this example from `survival.b.R`, the `.init()` function sets the initial visibility of a results object based on the value of an option.

### The `.run()` Function

The `.run()` function is the main workhorse of your analysis. It's called **every time the user changes an option** in the UI. The typical workflow inside `.run()` is as follows:

1.  **Input Validation:** Check if the user has provided all the necessary inputs. If not, you can display a message and `return()` early.
2.  **Data Preparation:** Access the data using `self$data` and prepare it for analysis. This might involve cleaning the data, transforming variables, or filtering rows.
3.  **Run the Analysis:** Perform the statistical calculations using the prepared data and the options selected by the user.
4.  **Populate Results:** Populate the results objects (tables, plots, etc.) with the results of your analysis.

## 4. Accessing UI Options and Data

### Accessing Options

You can access the values of the UI options you defined in your `.a.yaml` file using `self$options$...`. For example, to get the value of the `explanatory` variable selector:

```R
explanatory_variable <- self$options$explanatory
```

### Handling Data

The user's dataset is available to you as a data frame called `self$data`. You can work with this data frame using standard R functions and packages.

```R
# Get the data
mydata <- self$data

# Get a specific column
outcome_column <- self$data[[self$options$outcome]]
```

## 5. Populating Results

You can access the results objects you defined in your `.r.yaml` file using `self$results$...`.

*   **Tables:** `self$results$tableName$addRow(...)`
*   **Plots:** `self$results$plotName$setState(...)`
*   **HTML/Preformatted:** `self$results$itemName$setContent(...)`

Refer to the previous guides on creating tables and plots for more details on how to populate them.

## 6. State Management for Plots

As described in the plots guide, you use `image$setState()` to pass data to your plot rendering functions. This is a key concept for managing the state of your analysis and separating the data preparation from the rendering logic.

```R
# In .run()
plotData <- list(
    "name1time" = name1time,
    "name2outcome" = name2outcome,
    "name3explanatory" = name3explanatory,
    "cleanData" = cleanData
)

image <- self$results$plot
image$setState(plotData)

# In .plot()
.plot = function(image, ...) {
    results <- image$state
    # ... use results to create the plot ...
}
```

## 7. Helper Functions

For any non-trivial analysis, it's essential to break down your code into smaller, manageable helper functions. In `survival.b.R`, you can see several helper functions, all defined within the `private` list:

*   `.getData()`: A function to get and label the data.
*   `.definemytime()`: A function to define the survival time variable.
*   `.definemyoutcome()`: A function to define the outcome variable.
*   `.cleandata()`: A function that calls the other helper functions to prepare the data for analysis.
*   `.medianSurv()`, `.cox()`, `.survTable()`: Functions to perform specific parts of the analysis.
*   `.plot()`, `.plot2()`, etc.: Functions to render the various plots.

This modular approach makes your code easier to read, debug, and maintain.

## 8. A Complete Example: Walkthrough of `survival.b.R`

Let's walk through a simplified version of the `survival.b.R` file to see how all the pieces fit together.

```R
survivalClass <- R6::R6Class(
    "survivalClass",
    inherit = survivalBase,
    private = list(

        .run = function() {

            # 1. Input Validation
            if (is.null(self$options$outcome) || is.null(self$options$elapsedtime)) {
                # Display a "to-do" message and exit
                private$.todo()
                return()
            }

            # 2. Data Preparation
            results <- private$.cleandata()
            if (is.null(results)) {
                return()
            }

            # 3. Run Analysis and Populate Results
            private$.medianSurv(results)
            private$.cox(results)
            private$.survTable(results)

            # 4. Set State for Plots
            plotData <- list(
                # ... data for plotting ...
            )
            self$results$plot$setState(plotData)
        },

        .cleandata = function() {
            # ... code to clean and prepare the data ...
            return(list_of_clean_data_and_variable_names)
        },

        .medianSurv = function(results) {
            # ... code to calculate median survival ...

            # Populate the median survival table
            medianTable <- self$results$medianTable
            for (i in seq_along(data_frame[, 1, drop = T])) {
                medianTable$addRow(rowKey = i, values = c(data_frame[i,]))
            }
        },

        .plot = function(image, ggtheme, theme, ...) {
            # ... code to generate the plot using image$state ...
            print(plot)
            TRUE
        }
    )
)
```

This example demonstrates the core principles of a `.b.R` file: a `.run` function that orchestrates the analysis, helper functions to do the heavy lifting, and the use of `self$options` and `self$results` to interact with the UI and the output.

By following these guidelines and studying the examples in this project, you can write robust and efficient `.b.R` files for your jamovi modules.
